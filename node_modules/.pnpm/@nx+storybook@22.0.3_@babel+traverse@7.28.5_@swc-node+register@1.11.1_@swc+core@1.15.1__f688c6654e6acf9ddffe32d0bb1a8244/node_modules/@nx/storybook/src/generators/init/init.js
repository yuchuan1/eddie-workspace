"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initGenerator = initGenerator;
exports.initGeneratorInternal = initGeneratorInternal;
const devkit_1 = require("@nx/devkit");
const add_plugin_1 = require("@nx/devkit/src/utils/add-plugin");
const semver_1 = require("semver");
const plugin_1 = require("../../plugins/plugin");
const utilities_1 = require("../../utils/utilities");
const versions_1 = require("../../utils/versions");
const update_gitignore_1 = require("./lib/update-gitignore");
function checkDependenciesInstalled(host, schema) {
    const devDependencies = {
        '@nx/storybook': versions_1.nxVersion,
        '@nx/web': versions_1.nxVersion,
    };
    let storybookVersionToInstall = versions_1.storybookVersion;
    if ((0, utilities_1.storybookMajorVersion)() >= 7 &&
        (0, utilities_1.getInstalledStorybookVersion)() &&
        (0, semver_1.gte)((0, utilities_1.getInstalledStorybookVersion)(), '7.0.0')) {
        storybookVersionToInstall = (0, utilities_1.getInstalledStorybookVersion)();
    }
    devDependencies['storybook'] = storybookVersionToInstall;
    return (0, devkit_1.addDependenciesToPackageJson)(host, {}, devDependencies, undefined, schema.keepExistingVersions);
}
function addCacheableOperation(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const cacheableOperations = nxJson.tasksRunnerOptions?.default?.options?.cacheableOperations;
    if (cacheableOperations && !cacheableOperations.includes('build-storybook')) {
        nxJson.tasksRunnerOptions.default.options.cacheableOperations.push('build-storybook');
    }
    nxJson.targetDefaults ??= {};
    nxJson.targetDefaults['build-storybook'] ??= {};
    nxJson.targetDefaults['build-storybook'].cache = true;
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
function moveToDevDependencies(tree) {
    let updated = false;
    (0, devkit_1.updateJson)(tree, 'package.json', (packageJson) => {
        packageJson.dependencies = packageJson.dependencies || {};
        packageJson.devDependencies = packageJson.devDependencies || {};
        if (packageJson.dependencies['@nx/storybook']) {
            packageJson.devDependencies['@nx/storybook'] =
                packageJson.dependencies['@nx/storybook'];
            delete packageJson.dependencies['@nx/storybook'];
            updated = true;
        }
        return packageJson;
    });
    return updated ? () => (0, devkit_1.installPackagesTask)(tree) : () => { };
}
function initGenerator(tree, schema) {
    return initGeneratorInternal(tree, { addPlugin: false, ...schema });
}
async function initGeneratorInternal(tree, schema) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const addPluginDefault = process.env.NX_ADD_PLUGINS !== 'false' &&
        nxJson.useInferencePlugins !== false;
    schema.addPlugin ??= addPluginDefault;
    if (schema.addPlugin) {
        await (0, add_plugin_1.addPlugin)(tree, await (0, devkit_1.createProjectGraphAsync)(), '@nx/storybook/plugin', plugin_1.createNodesV2, {
            serveStorybookTargetName: [
                'storybook',
                'serve:storybook',
                'serve-storybook',
                'storybook:serve',
                'storybook-serve',
            ],
            buildStorybookTargetName: [
                'build-storybook',
                'build:storybook',
                'storybook:build',
            ],
            testStorybookTargetName: [
                'test-storybook',
                'test:storybook',
                'storybook:test',
            ],
            staticStorybookTargetName: [
                'static-storybook',
                'static:storybook',
                'storybook:static',
            ],
            buildDepsTargetName: [
                'build-deps',
                'storybook:build-deps',
                'storybook-build-deps',
            ],
            watchDepsTargetName: [
                'watch-deps',
                'storybook:watch-deps',
                'storybook-watch-deps',
            ],
        }, schema.updatePackageScripts);
        (0, update_gitignore_1.updateGitignore)(tree);
    }
    else {
        addCacheableOperation(tree);
    }
    const tasks = [];
    if (!schema.skipPackageJson) {
        tasks.push(moveToDevDependencies(tree));
        tasks.push(checkDependenciesInstalled(tree, schema));
    }
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = initGenerator;
