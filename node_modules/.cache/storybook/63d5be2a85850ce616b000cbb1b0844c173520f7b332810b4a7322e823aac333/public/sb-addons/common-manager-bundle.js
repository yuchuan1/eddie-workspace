try{
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __require = /* @__PURE__ */ ((x3) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x3, {
    get: (a3, b3) => (typeof require < "u" ? require : a3)[b3]
  }) : x3)(function(x3) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __esm = (fn2, res) => function() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: !0 });
  };

  // <define:module>
  var init_define_module = __esm({
    "<define:module>"() {
    }
  });

  // <define:process.env>
  var init_define_process_env = __esm({
    "<define:process.env>"() {
    }
  });

  // <define:process.env.NODE_PATH>
  var init_define_process_env_NODE_PATH = __esm({
    "<define:process.env.NODE_PATH>"() {
    }
  });

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-MM7DTO55.js
  var __create, __defProp2, __getOwnPropDesc, __getOwnPropNames2, __getProtoOf, __hasOwnProp, __name, __require2, __commonJS, __export2, __copyProps, __toESM, init_chunk_MM7DTO55 = __esm({
    "node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-MM7DTO55.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      __create = Object.create, __defProp2 = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames2 = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __name = (target, value2) => __defProp2(target, "name", { value: value2, configurable: !0 }), __require2 = ((x3) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(x3, {
        get: (a3, b3) => (typeof __require < "u" ? __require : a3)[b3]
      }) : x3)(function(x3) {
        if (typeof __require < "u") return __require.apply(this, arguments);
        throw Error('Dynamic require of "' + x3 + '" is not supported');
      }), __commonJS = (cb, mod) => function() {
        return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      }, __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: !0 });
      }, __copyProps = (to, from, except, desc) => {
        if (from && typeof from == "object" || typeof from == "function")
          for (let key of __getOwnPropNames2(from))
            !__hasOwnProp.call(to, key) && key !== except && __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        return to;
      }, __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: !0 }) : target,
        mod
      ));
    }
  });

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-U46RQHA4.js
  var getControlId, getControlSetterButtonId, init_chunk_U46RQHA4 = __esm({
    "node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-U46RQHA4.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      getControlId = __name((value2) => `control-${value2.replace(/\s+/g, "-")}`, "getControlId"), getControlSetterButtonId = __name((value2) => `set-${value2.replace(/\s+/g, "-")}`, "getControlSetterButtonId");
    }
  });

  // global-externals:react
  var react_default, Children, Component, Fragment, Profiler, PureComponent, StrictMode, Suspense, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, act, cloneElement, createContext, createElement, createFactory, createRef, forwardRef, isValidElement, lazy, memo, startTransition, unstable_act, useCallback, useContext, useDebugValue, useDeferredValue, useEffect, useId, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, useSyncExternalStore, useTransition, version, init_react = __esm({
    "global-externals:react"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      react_default = __REACT__, { Children, Component, Fragment, Profiler, PureComponent, StrictMode, Suspense, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, act, cloneElement, createContext, createElement, createFactory, createRef, forwardRef, isValidElement, lazy, memo, startTransition, unstable_act, useCallback, useContext, useDebugValue, useDeferredValue, useEffect, useId, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, useSyncExternalStore, useTransition, version } = __REACT__;
    }
  });

  // global-externals:storybook/internal/components
  var components_exports = {};
  __export(components_exports, {
    A: () => A,
    ActionBar: () => ActionBar,
    AddonPanel: () => AddonPanel,
    Badge: () => Badge,
    Bar: () => Bar,
    Blockquote: () => Blockquote,
    Button: () => Button,
    ClipboardCode: () => ClipboardCode,
    Code: () => Code,
    DL: () => DL,
    Div: () => Div,
    DocumentWrapper: () => DocumentWrapper,
    EmptyTabContent: () => EmptyTabContent,
    ErrorFormatter: () => ErrorFormatter,
    FlexBar: () => FlexBar,
    Form: () => Form,
    H1: () => H1,
    H2: () => H2,
    H3: () => H3,
    H4: () => H4,
    H5: () => H5,
    H6: () => H6,
    HR: () => HR,
    IconButton: () => IconButton,
    Img: () => Img,
    LI: () => LI,
    Link: () => Link,
    ListItem: () => ListItem,
    Loader: () => Loader,
    Modal: () => Modal,
    OL: () => OL,
    P: () => P,
    Placeholder: () => Placeholder,
    Pre: () => Pre,
    ProgressSpinner: () => ProgressSpinner,
    ResetWrapper: () => ResetWrapper,
    ScrollArea: () => ScrollArea,
    Separator: () => Separator,
    Spaced: () => Spaced,
    Span: () => Span,
    StorybookIcon: () => StorybookIcon,
    StorybookLogo: () => StorybookLogo,
    SyntaxHighlighter: () => SyntaxHighlighter,
    TT: () => TT,
    TabBar: () => TabBar,
    TabButton: () => TabButton,
    TabWrapper: () => TabWrapper,
    Table: () => Table,
    Tabs: () => Tabs,
    TabsState: () => TabsState,
    TooltipLinkList: () => TooltipLinkList,
    TooltipMessage: () => TooltipMessage,
    TooltipNote: () => TooltipNote,
    UL: () => UL,
    WithTooltip: () => WithTooltip,
    WithTooltipPure: () => WithTooltipPure,
    Zoom: () => Zoom,
    codeCommon: () => codeCommon,
    components: () => components,
    createCopyToClipboardFunction: () => createCopyToClipboardFunction,
    default: () => components_default,
    getStoryHref: () => getStoryHref,
    interleaveSeparators: () => interleaveSeparators,
    nameSpaceClassNames: () => nameSpaceClassNames,
    resetComponents: () => resetComponents,
    withReset: () => withReset
  });
  var components_default, A, ActionBar, AddonPanel, Badge, Bar, Blockquote, Button, ClipboardCode, Code, DL, Div, DocumentWrapper, EmptyTabContent, ErrorFormatter, FlexBar, Form, H1, H2, H3, H4, H5, H6, HR, IconButton, Img, LI, Link, ListItem, Loader, Modal, OL, P, Placeholder, Pre, ProgressSpinner, ResetWrapper, ScrollArea, Separator, Spaced, Span, StorybookIcon, StorybookLogo, SyntaxHighlighter, TT, TabBar, TabButton, TabWrapper, Table, Tabs, TabsState, TooltipLinkList, TooltipMessage, TooltipNote, UL, WithTooltip, WithTooltipPure, Zoom, codeCommon, components, createCopyToClipboardFunction, getStoryHref, interleaveSeparators, nameSpaceClassNames, resetComponents, withReset, init_components = __esm({
    "global-externals:storybook/internal/components"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      components_default = __STORYBOOK_COMPONENTS__, { A, ActionBar, AddonPanel, Badge, Bar, Blockquote, Button, ClipboardCode, Code, DL, Div, DocumentWrapper, EmptyTabContent, ErrorFormatter, FlexBar, Form, H1, H2, H3, H4, H5, H6, HR, IconButton, Img, LI, Link, ListItem, Loader, Modal, OL, P, Placeholder, Pre, ProgressSpinner, ResetWrapper, ScrollArea, Separator, Spaced, Span, StorybookIcon, StorybookLogo, SyntaxHighlighter, TT, TabBar, TabButton, TabWrapper, Table, Tabs, TabsState, TooltipLinkList, TooltipMessage, TooltipNote, UL, WithTooltip, WithTooltipPure, Zoom, codeCommon, components, createCopyToClipboardFunction, getStoryHref, interleaveSeparators, nameSpaceClassNames, resetComponents, withReset } = __STORYBOOK_COMPONENTS__;
    }
  });

  // global-externals:@storybook/icons
  var icons_default, AccessibilityAltIcon, AccessibilityIcon, AccessibilityIgnoredIcon, AddIcon, AdminIcon, AlertAltIcon, AlertIcon, AlignLeftIcon, AlignRightIcon, AppleIcon, ArrowBottomLeftIcon, ArrowBottomRightIcon, ArrowDownIcon, ArrowLeftIcon, ArrowRightIcon, ArrowSolidDownIcon, ArrowSolidLeftIcon, ArrowSolidRightIcon, ArrowSolidUpIcon, ArrowTopLeftIcon, ArrowTopRightIcon, ArrowUpIcon, AzureDevOpsIcon, BackIcon, BasketIcon, BatchAcceptIcon, BatchDenyIcon, BeakerIcon, BellIcon, BitbucketIcon, BoldIcon, BookIcon, BookmarkHollowIcon, BookmarkIcon, BottomBarIcon, BottomBarToggleIcon, BoxIcon, BranchIcon, BrowserIcon, BugIcon, ButtonIcon, CPUIcon, CalendarIcon, CameraIcon, CameraStabilizeIcon, CategoryIcon, CertificateIcon, ChangedIcon, ChatIcon, CheckIcon, ChevronDownIcon, ChevronLeftIcon, ChevronRightIcon, ChevronSmallDownIcon, ChevronSmallLeftIcon, ChevronSmallRightIcon, ChevronSmallUpIcon, ChevronUpIcon, ChromaticIcon, ChromeIcon, CircleHollowIcon, CircleIcon, ClearIcon, CloseAltIcon, CloseIcon, CloudHollowIcon, CloudIcon, CogIcon, CollapseIcon, CommandIcon, CommentAddIcon, CommentIcon, CommentsIcon, CommitIcon, CompassIcon, ComponentDrivenIcon, ComponentIcon, ContrastIcon, ContrastIgnoredIcon, ControlsIcon, CopyIcon, CreditIcon, CrossIcon, DashboardIcon, DatabaseIcon, DeleteIcon, DiamondIcon, DirectionIcon, DiscordIcon, DocChartIcon, DocListIcon, DocumentIcon, DownloadIcon, DragIcon, EditIcon, EditorIcon, EllipsisIcon, EmailIcon, ExpandAltIcon, ExpandIcon, EyeCloseIcon, EyeIcon, FaceHappyIcon, FaceNeutralIcon, FaceSadIcon, FacebookIcon, FailedIcon, FastForwardIcon, FigmaIcon, FilterIcon, FlagIcon, FolderIcon, FormIcon, GDriveIcon, GiftIcon, GithubIcon, GitlabIcon, GlobeIcon, GoogleIcon, GraphBarIcon, GraphLineIcon, GraphqlIcon, GridAltIcon, GridIcon, GrowIcon, HeartHollowIcon, HeartIcon, HomeIcon, HourglassIcon, InfoIcon, ItalicIcon, JumpToIcon, KeyIcon, LightningIcon, LightningOffIcon, LinkBrokenIcon, LinkIcon, LinkedinIcon, LinuxIcon, ListOrderedIcon, ListUnorderedIcon, LocationIcon, LockIcon, MarkdownIcon, MarkupIcon, MediumIcon, MemoryIcon, MenuIcon, MergeIcon, MirrorIcon, MobileIcon, MoonIcon, NutIcon, OutboxIcon, OutlineIcon, PaintBrushAltIcon, PaintBrushIcon, PaperClipIcon, ParagraphIcon, PassedIcon, PhoneIcon, PhotoDragIcon, PhotoIcon, PhotoStabilizeIcon, PinAltIcon, PinIcon, PlayAllHollowIcon, PlayBackIcon, PlayHollowIcon, PlayIcon, PlayNextIcon, PlusIcon, PointerDefaultIcon, PointerHandIcon, PowerIcon, PrintIcon, ProceedIcon, ProfileIcon, PullRequestIcon, QuestionIcon, RSSIcon, RedirectIcon, ReduxIcon, RefreshIcon, ReplyIcon, RepoIcon, RequestChangeIcon, RewindIcon, RulerIcon, SaveIcon, SearchIcon, ShareAltIcon, ShareIcon, ShieldIcon, SideBySideIcon, SidebarAltIcon, SidebarAltToggleIcon, SidebarIcon, SidebarToggleIcon, SortDownIcon, SortUpIcon, SpeakerIcon, StackedIcon, StarHollowIcon, StarIcon, StatusFailIcon, StatusIcon, StatusPassIcon, StatusWarnIcon, StickerIcon, StopAltHollowIcon, StopAltIcon, StopIcon, StorybookIcon2, StructureIcon, SubtractIcon, SunIcon, SupportIcon, SweepIcon, SwitchAltIcon, SyncIcon, TabletIcon, ThumbsUpIcon, TimeIcon, TimerIcon, TransferIcon, TrashIcon, TwitterIcon, TypeIcon, UbuntuIcon, UndoIcon, UnfoldIcon, UnlockIcon, UnpinIcon, UploadIcon, UserAddIcon, UserAltIcon, UserIcon, UsersIcon, VSCodeIcon, VerifiedIcon, VideoIcon, WandIcon, WatchIcon, WindowsIcon, WrenchIcon, XIcon, YoutubeIcon, ZoomIcon, ZoomOutIcon, ZoomResetIcon, iconList, init_icons = __esm({
    "global-externals:@storybook/icons"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      icons_default = __STORYBOOK_ICONS__, { AccessibilityAltIcon, AccessibilityIcon, AccessibilityIgnoredIcon, AddIcon, AdminIcon, AlertAltIcon, AlertIcon, AlignLeftIcon, AlignRightIcon, AppleIcon, ArrowBottomLeftIcon, ArrowBottomRightIcon, ArrowDownIcon, ArrowLeftIcon, ArrowRightIcon, ArrowSolidDownIcon, ArrowSolidLeftIcon, ArrowSolidRightIcon, ArrowSolidUpIcon, ArrowTopLeftIcon, ArrowTopRightIcon, ArrowUpIcon, AzureDevOpsIcon, BackIcon, BasketIcon, BatchAcceptIcon, BatchDenyIcon, BeakerIcon, BellIcon, BitbucketIcon, BoldIcon, BookIcon, BookmarkHollowIcon, BookmarkIcon, BottomBarIcon, BottomBarToggleIcon, BoxIcon, BranchIcon, BrowserIcon, BugIcon, ButtonIcon, CPUIcon, CalendarIcon, CameraIcon, CameraStabilizeIcon, CategoryIcon, CertificateIcon, ChangedIcon, ChatIcon, CheckIcon, ChevronDownIcon, ChevronLeftIcon, ChevronRightIcon, ChevronSmallDownIcon, ChevronSmallLeftIcon, ChevronSmallRightIcon, ChevronSmallUpIcon, ChevronUpIcon, ChromaticIcon, ChromeIcon, CircleHollowIcon, CircleIcon, ClearIcon, CloseAltIcon, CloseIcon, CloudHollowIcon, CloudIcon, CogIcon, CollapseIcon, CommandIcon, CommentAddIcon, CommentIcon, CommentsIcon, CommitIcon, CompassIcon, ComponentDrivenIcon, ComponentIcon, ContrastIcon, ContrastIgnoredIcon, ControlsIcon, CopyIcon, CreditIcon, CrossIcon, DashboardIcon, DatabaseIcon, DeleteIcon, DiamondIcon, DirectionIcon, DiscordIcon, DocChartIcon, DocListIcon, DocumentIcon, DownloadIcon, DragIcon, EditIcon, EditorIcon, EllipsisIcon, EmailIcon, ExpandAltIcon, ExpandIcon, EyeCloseIcon, EyeIcon, FaceHappyIcon, FaceNeutralIcon, FaceSadIcon, FacebookIcon, FailedIcon, FastForwardIcon, FigmaIcon, FilterIcon, FlagIcon, FolderIcon, FormIcon, GDriveIcon, GiftIcon, GithubIcon, GitlabIcon, GlobeIcon, GoogleIcon, GraphBarIcon, GraphLineIcon, GraphqlIcon, GridAltIcon, GridIcon, GrowIcon, HeartHollowIcon, HeartIcon, HomeIcon, HourglassIcon, InfoIcon, ItalicIcon, JumpToIcon, KeyIcon, LightningIcon, LightningOffIcon, LinkBrokenIcon, LinkIcon, LinkedinIcon, LinuxIcon, ListOrderedIcon, ListUnorderedIcon, LocationIcon, LockIcon, MarkdownIcon, MarkupIcon, MediumIcon, MemoryIcon, MenuIcon, MergeIcon, MirrorIcon, MobileIcon, MoonIcon, NutIcon, OutboxIcon, OutlineIcon, PaintBrushAltIcon, PaintBrushIcon, PaperClipIcon, ParagraphIcon, PassedIcon, PhoneIcon, PhotoDragIcon, PhotoIcon, PhotoStabilizeIcon, PinAltIcon, PinIcon, PlayAllHollowIcon, PlayBackIcon, PlayHollowIcon, PlayIcon, PlayNextIcon, PlusIcon, PointerDefaultIcon, PointerHandIcon, PowerIcon, PrintIcon, ProceedIcon, ProfileIcon, PullRequestIcon, QuestionIcon, RSSIcon, RedirectIcon, ReduxIcon, RefreshIcon, ReplyIcon, RepoIcon, RequestChangeIcon, RewindIcon, RulerIcon, SaveIcon, SearchIcon, ShareAltIcon, ShareIcon, ShieldIcon, SideBySideIcon, SidebarAltIcon, SidebarAltToggleIcon, SidebarIcon, SidebarToggleIcon, SortDownIcon, SortUpIcon, SpeakerIcon, StackedIcon, StarHollowIcon, StarIcon, StatusFailIcon, StatusIcon, StatusPassIcon, StatusWarnIcon, StickerIcon, StopAltHollowIcon, StopAltIcon, StopIcon, StorybookIcon: StorybookIcon2, StructureIcon, SubtractIcon, SunIcon, SupportIcon, SweepIcon, SwitchAltIcon, SyncIcon, TabletIcon, ThumbsUpIcon, TimeIcon, TimerIcon, TransferIcon, TrashIcon, TwitterIcon, TypeIcon, UbuntuIcon, UndoIcon, UnfoldIcon, UnlockIcon, UnpinIcon, UploadIcon, UserAddIcon, UserAltIcon, UserIcon, UsersIcon, VSCodeIcon, VerifiedIcon, VideoIcon, WandIcon, WatchIcon, WindowsIcon, WrenchIcon, XIcon, YoutubeIcon, ZoomIcon, ZoomOutIcon, ZoomResetIcon, iconList } = __STORYBOOK_ICONS__;
    }
  });

  // global-externals:storybook/theming
  var theming_default, CacheProvider, ClassNames, Global, ThemeProvider, background, color, convert, create, createCache, createGlobal, createReset, css, darken2, ensure, ignoreSsrWarning, isPropValid, jsx, keyframes, lighten2, styled, themes, typography, useTheme, withTheme, init_theming = __esm({
    "global-externals:storybook/theming"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      theming_default = __STORYBOOK_THEMING__, { CacheProvider, ClassNames, Global, ThemeProvider, background, color, convert, create, createCache, createGlobal, createReset, css, darken: darken2, ensure, ignoreSsrWarning, isPropValid, jsx, keyframes, lighten: lighten2, styled, themes, typography, useTheme, withTheme } = __STORYBOOK_THEMING__;
    }
  });

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-AB7OOPUX.js
  function noop() {
  }
  var init_chunk_AB7OOPUX = __esm({
    "node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-AB7OOPUX.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_MM7DTO55();
      __name(noop, "noop");
    }
  });

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/Color-7ZNS6F6B.js
  var Color_7ZNS6F6B_exports = {};
  __export(Color_7ZNS6F6B_exports, {
    ColorControl: () => ColorControl,
    default: () => Color_default
  });
  function debounce(func, debounceMs, { signal, edges } = {}) {
    let pendingThis, pendingArgs = null, leading = edges != null && edges.includes("leading"), trailing = edges == null || edges.includes("trailing"), invoke = __name(() => {
      pendingArgs !== null && (func.apply(pendingThis, pendingArgs), pendingThis = void 0, pendingArgs = null);
    }, "invoke"), onTimerEnd = __name(() => {
      trailing && invoke(), cancel();
    }, "onTimerEnd"), timeoutId = null, schedule = __name(() => {
      timeoutId != null && clearTimeout(timeoutId), timeoutId = setTimeout(() => {
        timeoutId = null, onTimerEnd();
      }, debounceMs);
    }, "schedule"), cancelTimer = __name(() => {
      timeoutId !== null && (clearTimeout(timeoutId), timeoutId = null);
    }, "cancelTimer"), cancel = __name(() => {
      cancelTimer(), pendingThis = void 0, pendingArgs = null;
    }, "cancel"), flush = __name(() => {
      invoke();
    }, "flush"), debounced = __name(function(...args) {
      if (signal?.aborted)
        return;
      pendingThis = this, pendingArgs = args;
      let isFirstCall = timeoutId == null;
      schedule(), leading && isFirstCall && invoke();
    }, "debounced");
    return debounced.schedule = schedule, debounced.cancel = cancel, debounced.flush = flush, signal?.addEventListener("abort", cancel, { once: !0 }), debounced;
  }
  function partial(func, ...partialArgs) {
    return partialImpl(func, placeholderSymbol, ...partialArgs);
  }
  function partialImpl(func, placeholder, ...partialArgs) {
    let partialed = __name(function(...providedArgs) {
      let providedArgsIndex = 0, substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg), remainingArgs = providedArgs.slice(providedArgsIndex);
      return func.apply(this, substitutedArgs.concat(remainingArgs));
    }, "partialed");
    return func.prototype && (partialed.prototype = Object.create(func.prototype)), partialed;
  }
  function partialRight(func, ...partialArgs) {
    return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
  }
  function partialRightImpl(func, placeholder, ...partialArgs) {
    let partialedRight = __name(function(...providedArgs) {
      let placeholderLength = partialArgs.filter((arg) => arg === placeholder).length, rangeLength = Math.max(providedArgs.length - placeholderLength, 0), remainingArgs = providedArgs.slice(0, rangeLength), providedArgsIndex = rangeLength, substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
      return func.apply(this, remainingArgs.concat(substitutedArgs));
    }, "partialedRight");
    return func.prototype && (partialedRight.prototype = Object.create(func.prototype)), partialedRight;
  }
  function u() {
    return (u = Object.assign || function(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = arguments[r2];
        for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  function c(e2, r2) {
    if (e2 == null) return {};
    var t2, n2, o2 = {}, a22 = Object.keys(e2);
    for (n2 = 0; n2 < a22.length; n2++) r2.indexOf(t2 = a22[n2]) >= 0 || (o2[t2] = e2[t2]);
    return o2;
  }
  function i(e2) {
    var t2 = useRef(e2), n2 = useRef(function(e3) {
      t2.current && t2.current(e3);
    });
    return t2.current = e2, n2.current;
  }
  function Y(e2, t2, l2) {
    var u22 = i(l2), c22 = useState(function() {
      return e2.toHsva(t2);
    }), s22 = c22[0], f22 = c22[1], v22 = useRef({ color: t2, hsva: s22 });
    useEffect(function() {
      if (!e2.equal(t2, v22.current.color)) {
        var r2 = e2.toHsva(t2);
        v22.current = { hsva: r2, color: t2 }, f22(r2);
      }
    }, [t2, e2]), useEffect(function() {
      var r2;
      F(s22, v22.current.hsva) || e2.equal(r2 = e2.fromHsva(s22), v22.current.color) || (v22.current = { hsva: s22, color: r2 }, u22(r2));
    }, [s22, e2, u22]);
    var d22 = useCallback(function(e3) {
      f22(function(r2) {
        return Object.assign({}, r2, e3);
      });
    }, []);
    return [s22, d22];
  }
  var require_color_name, require_conversions, require_route, require_color_convert, import_color_convert, placeholderSymbol, placeholderSymbol2, DEFAULT_RETRIES, s2, f2, v, d, h2, m, g, p2, b, _, x, C2, E, H, N, w, y, q, k, I, z, D, K, L, S, T, F, P2, X, R, V, $, J, Q, U, W, Z, ee, re, le, ue, Ee, He, Wrapper, PickerTooltip, TooltipContent, Note, Swatches, SwatchColor, swatchBackground, Swatch, Input, ToggleIcon, ColorSpace, COLOR_SPACES, COLOR_REGEXP2, RGB_REGEXP, HSL_REGEXP, HEX_REGEXP2, SHORTHEX_REGEXP, ColorPicker, fallbackColor, stringToArgs, parseRgb, parseHsl, parseHexOrKeyword, parseValue, getRealValue, useColorInput, id, usePresets, ColorControl, Color_default, init_Color_7ZNS6F6B = __esm({
    "node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/Color-7ZNS6F6B.js"() {
      init_define_module();
      init_define_process_env();
      init_define_process_env_NODE_PATH();
      init_chunk_U46RQHA4();
      init_chunk_AB7OOPUX();
      init_chunk_MM7DTO55();
      init_react();
      init_components();
      init_icons();
      init_react();
      init_theming();
      require_color_name = __commonJS({
        "../node_modules/color-name/index.js"(exports, module) {
          "use strict";
          module.exports = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
          };
        }
      }), require_conversions = __commonJS({
        "../node_modules/color-convert/conversions.js"(exports, module) {
          var cssKeywords = require_color_name(), reverseKeywords = {};
          for (let key of Object.keys(cssKeywords))
            reverseKeywords[cssKeywords[key]] = key;
          var convert23 = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          };
          module.exports = convert23;
          for (let model of Object.keys(convert23)) {
            if (!("channels" in convert23[model]))
              throw new Error("missing channels property: " + model);
            if (!("labels" in convert23[model]))
              throw new Error("missing channel labels property: " + model);
            if (convert23[model].labels.length !== convert23[model].channels)
              throw new Error("channel and label counts mismatch: " + model);
            let { channels, labels } = convert23[model];
            delete convert23[model].channels, delete convert23[model].labels, Object.defineProperty(convert23[model], "channels", { value: channels }), Object.defineProperty(convert23[model], "labels", { value: labels });
          }
          convert23.rgb.hsl = function(rgb2) {
            let r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255, min = Math.min(r2, g22, b22), max = Math.max(r2, g22, b22), delta = max - min, h22, s22;
            max === min ? h22 = 0 : r2 === max ? h22 = (g22 - b22) / delta : g22 === max ? h22 = 2 + (b22 - r2) / delta : b22 === max && (h22 = 4 + (r2 - g22) / delta), h22 = Math.min(h22 * 60, 360), h22 < 0 && (h22 += 360);
            let l2 = (min + max) / 2;
            return max === min ? s22 = 0 : l2 <= 0.5 ? s22 = delta / (max + min) : s22 = delta / (2 - max - min), [h22, s22 * 100, l2 * 100];
          }, convert23.rgb.hsv = function(rgb2) {
            let rdif, gdif, bdif, h22, s22, r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255, v22 = Math.max(r2, g22, b22), diff2 = v22 - Math.min(r2, g22, b22), diffc = __name(function(c22) {
              return (v22 - c22) / 6 / diff2 + 1 / 2;
            }, "diffc");
            return diff2 === 0 ? (h22 = 0, s22 = 0) : (s22 = diff2 / v22, rdif = diffc(r2), gdif = diffc(g22), bdif = diffc(b22), r2 === v22 ? h22 = bdif - gdif : g22 === v22 ? h22 = 1 / 3 + rdif - bdif : b22 === v22 && (h22 = 2 / 3 + gdif - rdif), h22 < 0 ? h22 += 1 : h22 > 1 && (h22 -= 1)), [
              h22 * 360,
              s22 * 100,
              v22 * 100
            ];
          }, convert23.rgb.hwb = function(rgb2) {
            let r2 = rgb2[0], g22 = rgb2[1], b22 = rgb2[2], h22 = convert23.rgb.hsl(rgb2)[0], w22 = 1 / 255 * Math.min(r2, Math.min(g22, b22));
            return b22 = 1 - 1 / 255 * Math.max(r2, Math.max(g22, b22)), [h22, w22 * 100, b22 * 100];
          }, convert23.rgb.cmyk = function(rgb2) {
            let r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255, k22 = Math.min(1 - r2, 1 - g22, 1 - b22), c22 = (1 - r2 - k22) / (1 - k22) || 0, m22 = (1 - g22 - k22) / (1 - k22) || 0, y22 = (1 - b22 - k22) / (1 - k22) || 0;
            return [c22 * 100, m22 * 100, y22 * 100, k22 * 100];
          };
          function comparativeDistance(x22, y22) {
            return (x22[0] - y22[0]) ** 2 + (x22[1] - y22[1]) ** 2 + (x22[2] - y22[2]) ** 2;
          }
          __name(comparativeDistance, "comparativeDistance"), convert23.rgb.keyword = function(rgb2) {
            let reversed = reverseKeywords[rgb2];
            if (reversed)
              return reversed;
            let currentClosestDistance = 1 / 0, currentClosestKeyword;
            for (let keyword of Object.keys(cssKeywords)) {
              let value2 = cssKeywords[keyword], distance = comparativeDistance(rgb2, value2);
              distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
            }
            return currentClosestKeyword;
          }, convert23.keyword.rgb = function(keyword) {
            return cssKeywords[keyword];
          }, convert23.rgb.xyz = function(rgb2) {
            let r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255;
            r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92, g22 = g22 > 0.04045 ? ((g22 + 0.055) / 1.055) ** 2.4 : g22 / 12.92, b22 = b22 > 0.04045 ? ((b22 + 0.055) / 1.055) ** 2.4 : b22 / 12.92;
            let x22 = r2 * 0.4124 + g22 * 0.3576 + b22 * 0.1805, y22 = r2 * 0.2126 + g22 * 0.7152 + b22 * 0.0722, z22 = r2 * 0.0193 + g22 * 0.1192 + b22 * 0.9505;
            return [x22 * 100, y22 * 100, z22 * 100];
          }, convert23.rgb.lab = function(rgb2) {
            let xyz = convert23.rgb.xyz(rgb2), x22 = xyz[0], y22 = xyz[1], z22 = xyz[2];
            x22 /= 95.047, y22 /= 100, z22 /= 108.883, x22 = x22 > 8856e-6 ? x22 ** (1 / 3) : 7.787 * x22 + 16 / 116, y22 = y22 > 8856e-6 ? y22 ** (1 / 3) : 7.787 * y22 + 16 / 116, z22 = z22 > 8856e-6 ? z22 ** (1 / 3) : 7.787 * z22 + 16 / 116;
            let l2 = 116 * y22 - 16, a22 = 500 * (x22 - y22), b22 = 200 * (y22 - z22);
            return [l2, a22, b22];
          }, convert23.hsl.rgb = function(hsl2) {
            let h22 = hsl2[0] / 360, s22 = hsl2[1] / 100, l2 = hsl2[2] / 100, t2, t3, val;
            if (s22 === 0)
              return val = l2 * 255, [val, val, val];
            l2 < 0.5 ? t2 = l2 * (1 + s22) : t2 = l2 + s22 - l2 * s22;
            let t1 = 2 * l2 - t2, rgb2 = [0, 0, 0];
            for (let i22 = 0; i22 < 3; i22++)
              t3 = h22 + 1 / 3 * -(i22 - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb2[i22] = val * 255;
            return rgb2;
          }, convert23.hsl.hsv = function(hsl2) {
            let h22 = hsl2[0], s22 = hsl2[1] / 100, l2 = hsl2[2] / 100, smin = s22, lmin = Math.max(l2, 0.01);
            l2 *= 2, s22 *= l2 <= 1 ? l2 : 2 - l2, smin *= lmin <= 1 ? lmin : 2 - lmin;
            let v22 = (l2 + s22) / 2, sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s22 / (l2 + s22);
            return [h22, sv * 100, v22 * 100];
          }, convert23.hsv.rgb = function(hsv) {
            let h22 = hsv[0] / 60, s22 = hsv[1] / 100, v22 = hsv[2] / 100, hi = Math.floor(h22) % 6, f22 = h22 - Math.floor(h22), p22 = 255 * v22 * (1 - s22), q22 = 255 * v22 * (1 - s22 * f22), t2 = 255 * v22 * (1 - s22 * (1 - f22));
            switch (v22 *= 255, hi) {
              case 0:
                return [v22, t2, p22];
              case 1:
                return [q22, v22, p22];
              case 2:
                return [p22, v22, t2];
              case 3:
                return [p22, q22, v22];
              case 4:
                return [t2, p22, v22];
              case 5:
                return [v22, p22, q22];
            }
          }, convert23.hsv.hsl = function(hsv) {
            let h22 = hsv[0], s22 = hsv[1] / 100, v22 = hsv[2] / 100, vmin = Math.max(v22, 0.01), sl, l2;
            l2 = (2 - s22) * v22;
            let lmin = (2 - s22) * vmin;
            return sl = s22 * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l2 /= 2, [h22, sl * 100, l2 * 100];
          }, convert23.hwb.rgb = function(hwb) {
            let h22 = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, f22;
            ratio > 1 && (wh /= ratio, bl /= ratio);
            let i22 = Math.floor(6 * h22), v22 = 1 - bl;
            f22 = 6 * h22 - i22, (i22 & 1) !== 0 && (f22 = 1 - f22);
            let n2 = wh + f22 * (v22 - wh), r2, g22, b22;
            switch (i22) {
              default:
              case 6:
              case 0:
                r2 = v22, g22 = n2, b22 = wh;
                break;
              case 1:
                r2 = n2, g22 = v22, b22 = wh;
                break;
              case 2:
                r2 = wh, g22 = v22, b22 = n2;
                break;
              case 3:
                r2 = wh, g22 = n2, b22 = v22;
                break;
              case 4:
                r2 = n2, g22 = wh, b22 = v22;
                break;
              case 5:
                r2 = v22, g22 = wh, b22 = n2;
                break;
            }
            return [r2 * 255, g22 * 255, b22 * 255];
          }, convert23.cmyk.rgb = function(cmyk) {
            let c22 = cmyk[0] / 100, m22 = cmyk[1] / 100, y22 = cmyk[2] / 100, k22 = cmyk[3] / 100, r2 = 1 - Math.min(1, c22 * (1 - k22) + k22), g22 = 1 - Math.min(1, m22 * (1 - k22) + k22), b22 = 1 - Math.min(1, y22 * (1 - k22) + k22);
            return [r2 * 255, g22 * 255, b22 * 255];
          }, convert23.xyz.rgb = function(xyz) {
            let x22 = xyz[0] / 100, y22 = xyz[1] / 100, z22 = xyz[2] / 100, r2, g22, b22;
            return r2 = x22 * 3.2406 + y22 * -1.5372 + z22 * -0.4986, g22 = x22 * -0.9689 + y22 * 1.8758 + z22 * 0.0415, b22 = x22 * 0.0557 + y22 * -0.204 + z22 * 1.057, r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92, g22 = g22 > 31308e-7 ? 1.055 * g22 ** (1 / 2.4) - 0.055 : g22 * 12.92, b22 = b22 > 31308e-7 ? 1.055 * b22 ** (1 / 2.4) - 0.055 : b22 * 12.92, r2 = Math.min(Math.max(0, r2), 1), g22 = Math.min(Math.max(0, g22), 1), b22 = Math.min(Math.max(0, b22), 1), [r2 * 255, g22 * 255, b22 * 255];
          }, convert23.xyz.lab = function(xyz) {
            let x22 = xyz[0], y22 = xyz[1], z22 = xyz[2];
            x22 /= 95.047, y22 /= 100, z22 /= 108.883, x22 = x22 > 8856e-6 ? x22 ** (1 / 3) : 7.787 * x22 + 16 / 116, y22 = y22 > 8856e-6 ? y22 ** (1 / 3) : 7.787 * y22 + 16 / 116, z22 = z22 > 8856e-6 ? z22 ** (1 / 3) : 7.787 * z22 + 16 / 116;
            let l2 = 116 * y22 - 16, a22 = 500 * (x22 - y22), b22 = 200 * (y22 - z22);
            return [l2, a22, b22];
          }, convert23.lab.xyz = function(lab) {
            let l2 = lab[0], a22 = lab[1], b22 = lab[2], x22, y22, z22;
            y22 = (l2 + 16) / 116, x22 = a22 / 500 + y22, z22 = y22 - b22 / 200;
            let y222 = y22 ** 3, x222 = x22 ** 3, z222 = z22 ** 3;
            return y22 = y222 > 8856e-6 ? y222 : (y22 - 16 / 116) / 7.787, x22 = x222 > 8856e-6 ? x222 : (x22 - 16 / 116) / 7.787, z22 = z222 > 8856e-6 ? z222 : (z22 - 16 / 116) / 7.787, x22 *= 95.047, y22 *= 100, z22 *= 108.883, [x22, y22, z22];
          }, convert23.lab.lch = function(lab) {
            let l2 = lab[0], a22 = lab[1], b22 = lab[2], h22;
            h22 = Math.atan2(b22, a22) * 360 / 2 / Math.PI, h22 < 0 && (h22 += 360);
            let c22 = Math.sqrt(a22 * a22 + b22 * b22);
            return [l2, c22, h22];
          }, convert23.lch.lab = function(lch) {
            let l2 = lch[0], c22 = lch[1], hr = lch[2] / 360 * 2 * Math.PI, a22 = c22 * Math.cos(hr), b22 = c22 * Math.sin(hr);
            return [l2, a22, b22];
          }, convert23.rgb.ansi16 = function(args, saturation = null) {
            let [r2, g22, b22] = args, value2 = saturation === null ? convert23.rgb.hsv(args)[2] : saturation;
            if (value2 = Math.round(value2 / 50), value2 === 0)
              return 30;
            let ansi = 30 + (Math.round(b22 / 255) << 2 | Math.round(g22 / 255) << 1 | Math.round(r2 / 255));
            return value2 === 2 && (ansi += 60), ansi;
          }, convert23.hsv.ansi16 = function(args) {
            return convert23.rgb.ansi16(convert23.hsv.rgb(args), args[2]);
          }, convert23.rgb.ansi256 = function(args) {
            let r2 = args[0], g22 = args[1], b22 = args[2];
            return r2 === g22 && g22 === b22 ? r2 < 8 ? 16 : r2 > 248 ? 231 : Math.round((r2 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g22 / 255 * 5) + Math.round(b22 / 255 * 5);
          }, convert23.ansi16.rgb = function(args) {
            let color2 = args % 10;
            if (color2 === 0 || color2 === 7)
              return args > 50 && (color2 += 3.5), color2 = color2 / 10.5 * 255, [color2, color2, color2];
            let mult = (~~(args > 50) + 1) * 0.5, r2 = (color2 & 1) * mult * 255, g22 = (color2 >> 1 & 1) * mult * 255, b22 = (color2 >> 2 & 1) * mult * 255;
            return [r2, g22, b22];
          }, convert23.ansi256.rgb = function(args) {
            if (args >= 232) {
              let c22 = (args - 232) * 10 + 8;
              return [c22, c22, c22];
            }
            args -= 16;
            let rem2, r2 = Math.floor(args / 36) / 5 * 255, g22 = Math.floor((rem2 = args % 36) / 6) / 5 * 255, b22 = rem2 % 6 / 5 * 255;
            return [r2, g22, b22];
          }, convert23.rgb.hex = function(args) {
            let string = (((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255)).toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          }, convert23.hex.rgb = function(args) {
            let match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match)
              return [0, 0, 0];
            let colorString = match[0];
            match[0].length === 3 && (colorString = colorString.split("").map((char) => char + char).join(""));
            let integer = parseInt(colorString, 16), r2 = integer >> 16 & 255, g22 = integer >> 8 & 255, b22 = integer & 255;
            return [r2, g22, b22];
          }, convert23.rgb.hcg = function(rgb2) {
            let r2 = rgb2[0] / 255, g22 = rgb2[1] / 255, b22 = rgb2[2] / 255, max = Math.max(Math.max(r2, g22), b22), min = Math.min(Math.min(r2, g22), b22), chroma = max - min, grayscale, hue;
            return chroma < 1 ? grayscale = min / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max === r2 ? hue = (g22 - b22) / chroma % 6 : max === g22 ? hue = 2 + (b22 - r2) / chroma : hue = 4 + (r2 - g22) / chroma, hue /= 6, hue %= 1, [hue * 360, chroma * 100, grayscale * 100];
          }, convert23.hsl.hcg = function(hsl2) {
            let s22 = hsl2[1] / 100, l2 = hsl2[2] / 100, c22 = l2 < 0.5 ? 2 * s22 * l2 : 2 * s22 * (1 - l2), f22 = 0;
            return c22 < 1 && (f22 = (l2 - 0.5 * c22) / (1 - c22)), [hsl2[0], c22 * 100, f22 * 100];
          }, convert23.hsv.hcg = function(hsv) {
            let s22 = hsv[1] / 100, v22 = hsv[2] / 100, c22 = s22 * v22, f22 = 0;
            return c22 < 1 && (f22 = (v22 - c22) / (1 - c22)), [hsv[0], c22 * 100, f22 * 100];
          }, convert23.hcg.rgb = function(hcg) {
            let h22 = hcg[0] / 360, c22 = hcg[1] / 100, g22 = hcg[2] / 100;
            if (c22 === 0)
              return [g22 * 255, g22 * 255, g22 * 255];
            let pure = [0, 0, 0], hi = h22 % 1 * 6, v22 = hi % 1, w22 = 1 - v22, mg = 0;
            switch (Math.floor(hi)) {
              case 0:
                pure[0] = 1, pure[1] = v22, pure[2] = 0;
                break;
              case 1:
                pure[0] = w22, pure[1] = 1, pure[2] = 0;
                break;
              case 2:
                pure[0] = 0, pure[1] = 1, pure[2] = v22;
                break;
              case 3:
                pure[0] = 0, pure[1] = w22, pure[2] = 1;
                break;
              case 4:
                pure[0] = v22, pure[1] = 0, pure[2] = 1;
                break;
              default:
                pure[0] = 1, pure[1] = 0, pure[2] = w22;
            }
            return mg = (1 - c22) * g22, [
              (c22 * pure[0] + mg) * 255,
              (c22 * pure[1] + mg) * 255,
              (c22 * pure[2] + mg) * 255
            ];
          }, convert23.hcg.hsv = function(hcg) {
            let c22 = hcg[1] / 100, g22 = hcg[2] / 100, v22 = c22 + g22 * (1 - c22), f22 = 0;
            return v22 > 0 && (f22 = c22 / v22), [hcg[0], f22 * 100, v22 * 100];
          }, convert23.hcg.hsl = function(hcg) {
            let c22 = hcg[1] / 100, l2 = hcg[2] / 100 * (1 - c22) + 0.5 * c22, s22 = 0;
            return l2 > 0 && l2 < 0.5 ? s22 = c22 / (2 * l2) : l2 >= 0.5 && l2 < 1 && (s22 = c22 / (2 * (1 - l2))), [hcg[0], s22 * 100, l2 * 100];
          }, convert23.hcg.hwb = function(hcg) {
            let c22 = hcg[1] / 100, g22 = hcg[2] / 100, v22 = c22 + g22 * (1 - c22);
            return [hcg[0], (v22 - c22) * 100, (1 - v22) * 100];
          }, convert23.hwb.hcg = function(hwb) {
            let w22 = hwb[1] / 100, v22 = 1 - hwb[2] / 100, c22 = v22 - w22, g22 = 0;
            return c22 < 1 && (g22 = (v22 - c22) / (1 - c22)), [hwb[0], c22 * 100, g22 * 100];
          }, convert23.apple.rgb = function(apple) {
            return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
          }, convert23.rgb.apple = function(rgb2) {
            return [rgb2[0] / 255 * 65535, rgb2[1] / 255 * 65535, rgb2[2] / 255 * 65535];
          }, convert23.gray.rgb = function(args) {
            return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
          }, convert23.gray.hsl = function(args) {
            return [0, 0, args[0]];
          }, convert23.gray.hsv = convert23.gray.hsl, convert23.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          }, convert23.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          }, convert23.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          }, convert23.gray.hex = function(gray) {
            let val = Math.round(gray[0] / 100 * 255) & 255, string = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          }, convert23.rgb.gray = function(rgb2) {
            return [(rgb2[0] + rgb2[1] + rgb2[2]) / 3 / 255 * 100];
          };
        }
      }), require_route = __commonJS({
        "../node_modules/color-convert/route.js"(exports, module) {
          var conversions = require_conversions();
          function buildGraph() {
            let graph = {}, models = Object.keys(conversions);
            for (let len = models.length, i22 = 0; i22 < len; i22++)
              graph[models[i22]] = {
                // http://jsperf.com/1-vs-infinity
                // micro-opt, but this is simple.
                distance: -1,
                parent: null
              };
            return graph;
          }
          __name(buildGraph, "buildGraph");
          function deriveBFS(fromModel) {
            let graph = buildGraph(), queue = [fromModel];
            for (graph[fromModel].distance = 0; queue.length; ) {
              let current = queue.pop(), adjacents = Object.keys(conversions[current]);
              for (let len = adjacents.length, i22 = 0; i22 < len; i22++) {
                let adjacent = adjacents[i22], node = graph[adjacent];
                node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
              }
            }
            return graph;
          }
          __name(deriveBFS, "deriveBFS");
          function link(from, to) {
            return function(args) {
              return to(from(args));
            };
          }
          __name(link, "link");
          function wrapConversion(toModel, graph) {
            let path = [graph[toModel].parent, toModel], fn2 = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent;
            for (; graph[cur].parent; )
              path.unshift(graph[cur].parent), fn2 = link(conversions[graph[cur].parent][cur], fn2), cur = graph[cur].parent;
            return fn2.conversion = path, fn2;
          }
          __name(wrapConversion, "wrapConversion"), module.exports = function(fromModel) {
            let graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph);
            for (let len = models.length, i22 = 0; i22 < len; i22++) {
              let toModel = models[i22];
              graph[toModel].parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
            }
            return conversion;
          };
        }
      }), require_color_convert = __commonJS({
        "../node_modules/color-convert/index.js"(exports, module) {
          var conversions = require_conversions(), route = require_route(), convert23 = {}, models = Object.keys(conversions);
          function wrapRaw(fn2) {
            let wrappedFn = __name(function(...args) {
              let arg0 = args[0];
              return arg0 == null ? arg0 : (arg0.length > 1 && (args = arg0), fn2(args));
            }, "wrappedFn");
            return "conversion" in fn2 && (wrappedFn.conversion = fn2.conversion), wrappedFn;
          }
          __name(wrapRaw, "wrapRaw");
          function wrapRounded(fn2) {
            let wrappedFn = __name(function(...args) {
              let arg0 = args[0];
              if (arg0 == null)
                return arg0;
              arg0.length > 1 && (args = arg0);
              let result = fn2(args);
              if (typeof result == "object")
                for (let len = result.length, i22 = 0; i22 < len; i22++)
                  result[i22] = Math.round(result[i22]);
              return result;
            }, "wrappedFn");
            return "conversion" in fn2 && (wrappedFn.conversion = fn2.conversion), wrappedFn;
          }
          __name(wrapRounded, "wrapRounded"), models.forEach((fromModel) => {
            convert23[fromModel] = {}, Object.defineProperty(convert23[fromModel], "channels", { value: conversions[fromModel].channels }), Object.defineProperty(convert23[fromModel], "labels", { value: conversions[fromModel].labels });
            let routes = route(fromModel);
            Object.keys(routes).forEach((toModel) => {
              let fn2 = routes[toModel];
              convert23[fromModel][toModel] = wrapRounded(fn2), convert23[fromModel][toModel].raw = wrapRaw(fn2);
            });
          }), module.exports = convert23;
        }
      }), import_color_convert = __toESM(require_color_convert(), 1);
      __name(debounce, "debounce");
      __name(partial, "partial");
      __name(partialImpl, "partialImpl");
      placeholderSymbol = Symbol("partial.placeholder");
      partial.placeholder = placeholderSymbol;
      __name(partialRight, "partialRight");
      __name(partialRightImpl, "partialRightImpl");
      placeholderSymbol2 = Symbol("partialRight.placeholder");
      partialRight.placeholder = placeholderSymbol2;
      DEFAULT_RETRIES = Number.POSITIVE_INFINITY;
      __name(u, "u");
      __name(c, "c");
      __name(i, "i");
      s2 = __name(function(e2, r2, t2) {
        return r2 === void 0 && (r2 = 0), t2 === void 0 && (t2 = 1), e2 > t2 ? t2 : e2 < r2 ? r2 : e2;
      }, "s"), f2 = __name(function(e2) {
        return "touches" in e2;
      }, "f"), v = __name(function(e2) {
        return e2 && e2.ownerDocument.defaultView || self;
      }, "v"), d = __name(function(e2, r2, t2) {
        var n2 = e2.getBoundingClientRect(), o2 = f2(r2) ? (function(e3, r3) {
          for (var t3 = 0; t3 < e3.length; t3++) if (e3[t3].identifier === r3) return e3[t3];
          return e3[0];
        })(r2.touches, t2) : r2;
        return { left: s2((o2.pageX - (n2.left + v(e2).pageXOffset)) / n2.width), top: s2((o2.pageY - (n2.top + v(e2).pageYOffset)) / n2.height) };
      }, "d"), h2 = __name(function(e2) {
        !f2(e2) && e2.preventDefault();
      }, "h"), m = react_default.memo(function(o2) {
        var a22 = o2.onMove, l2 = o2.onKey, s22 = c(o2, ["onMove", "onKey"]), m22 = useRef(null), g22 = i(a22), p22 = i(l2), b22 = useRef(null), _22 = useRef(!1), x22 = useMemo(function() {
          var e2 = __name(function(e3) {
            h2(e3), (f2(e3) ? e3.touches.length > 0 : e3.buttons > 0) && m22.current ? g22(d(m22.current, e3, b22.current)) : t2(!1);
          }, "e"), r2 = __name(function() {
            return t2(!1);
          }, "r");
          function t2(t3) {
            var n2 = _22.current, o3 = v(m22.current), a3 = t3 ? o3.addEventListener : o3.removeEventListener;
            a3(n2 ? "touchmove" : "mousemove", e2), a3(n2 ? "touchend" : "mouseup", r2);
          }
          return __name(t2, "t"), [function(e3) {
            var r3 = e3.nativeEvent, n2 = m22.current;
            if (n2 && (h2(r3), !(function(e4, r4) {
              return r4 && !f2(e4);
            })(r3, _22.current) && n2)) {
              if (f2(r3)) {
                _22.current = !0;
                var o3 = r3.changedTouches || [];
                o3.length && (b22.current = o3[0].identifier);
              }
              n2.focus(), g22(d(n2, r3, b22.current)), t2(!0);
            }
          }, function(e3) {
            var r3 = e3.which || e3.keyCode;
            r3 < 37 || r3 > 40 || (e3.preventDefault(), p22({ left: r3 === 39 ? 0.05 : r3 === 37 ? -0.05 : 0, top: r3 === 40 ? 0.05 : r3 === 38 ? -0.05 : 0 }));
          }, t2];
        }, [p22, g22]), C22 = x22[0], E22 = x22[1], H22 = x22[2];
        return useEffect(function() {
          return H22;
        }, [H22]), react_default.createElement("div", u({}, s22, { onTouchStart: C22, onMouseDown: C22, className: "react-colorful__interactive", ref: m22, onKeyDown: E22, tabIndex: 0, role: "slider" }));
      }), g = __name(function(e2) {
        return e2.filter(Boolean).join(" ");
      }, "g"), p2 = __name(function(r2) {
        var t2 = r2.color, n2 = r2.left, o2 = r2.top, a22 = o2 === void 0 ? 0.5 : o2, l2 = g(["react-colorful__pointer", r2.className]);
        return react_default.createElement("div", { className: l2, style: { top: 100 * a22 + "%", left: 100 * n2 + "%" } }, react_default.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: t2 } }));
      }, "p"), b = __name(function(e2, r2, t2) {
        return r2 === void 0 && (r2 = 0), t2 === void 0 && (t2 = Math.pow(10, r2)), Math.round(t2 * e2) / t2;
      }, "b"), _ = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, x = __name(function(e2) {
        return L(C2(e2));
      }, "x"), C2 = __name(function(e2) {
        return e2[0] === "#" && (e2 = e2.substring(1)), e2.length < 6 ? { r: parseInt(e2[0] + e2[0], 16), g: parseInt(e2[1] + e2[1], 16), b: parseInt(e2[2] + e2[2], 16), a: e2.length === 4 ? b(parseInt(e2[3] + e2[3], 16) / 255, 2) : 1 } : { r: parseInt(e2.substring(0, 2), 16), g: parseInt(e2.substring(2, 4), 16), b: parseInt(e2.substring(4, 6), 16), a: e2.length === 8 ? b(parseInt(e2.substring(6, 8), 16) / 255, 2) : 1 };
      }, "C"), E = __name(function(e2, r2) {
        return r2 === void 0 && (r2 = "deg"), Number(e2) * (_[r2] || 1);
      }, "E"), H = __name(function(e2) {
        var r2 = /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e2);
        return r2 ? N({ h: E(r2[1], r2[2]), s: Number(r2[3]), l: Number(r2[4]), a: r2[5] === void 0 ? 1 : Number(r2[5]) / (r2[6] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 };
      }, "H"), N = __name(function(e2) {
        var r2 = e2.s, t2 = e2.l;
        return { h: e2.h, s: (r2 *= (t2 < 50 ? t2 : 100 - t2) / 100) > 0 ? 2 * r2 / (t2 + r2) * 100 : 0, v: t2 + r2, a: e2.a };
      }, "N"), w = __name(function(e2) {
        return K(I(e2));
      }, "w"), y = __name(function(e2) {
        var r2 = e2.s, t2 = e2.v, n2 = e2.a, o2 = (200 - r2) * t2 / 100;
        return { h: b(e2.h), s: b(o2 > 0 && o2 < 200 ? r2 * t2 / 100 / (o2 <= 100 ? o2 : 200 - o2) * 100 : 0), l: b(o2 / 2), a: b(n2, 2) };
      }, "y"), q = __name(function(e2) {
        var r2 = y(e2);
        return "hsl(" + r2.h + ", " + r2.s + "%, " + r2.l + "%)";
      }, "q"), k = __name(function(e2) {
        var r2 = y(e2);
        return "hsla(" + r2.h + ", " + r2.s + "%, " + r2.l + "%, " + r2.a + ")";
      }, "k"), I = __name(function(e2) {
        var r2 = e2.h, t2 = e2.s, n2 = e2.v, o2 = e2.a;
        r2 = r2 / 360 * 6, t2 /= 100, n2 /= 100;
        var a22 = Math.floor(r2), l2 = n2 * (1 - t2), u22 = n2 * (1 - (r2 - a22) * t2), c22 = n2 * (1 - (1 - r2 + a22) * t2), i22 = a22 % 6;
        return { r: b(255 * [n2, u22, l2, l2, c22, n2][i22]), g: b(255 * [c22, n2, n2, u22, l2, l2][i22]), b: b(255 * [l2, l2, c22, n2, n2, u22][i22]), a: b(o2, 2) };
      }, "I"), z = __name(function(e2) {
        var r2 = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e2);
        return r2 ? L({ r: Number(r2[1]) / (r2[2] ? 100 / 255 : 1), g: Number(r2[3]) / (r2[4] ? 100 / 255 : 1), b: Number(r2[5]) / (r2[6] ? 100 / 255 : 1), a: r2[7] === void 0 ? 1 : Number(r2[7]) / (r2[8] ? 100 : 1) }) : { h: 0, s: 0, v: 0, a: 1 };
      }, "z"), D = __name(function(e2) {
        var r2 = e2.toString(16);
        return r2.length < 2 ? "0" + r2 : r2;
      }, "D"), K = __name(function(e2) {
        var r2 = e2.r, t2 = e2.g, n2 = e2.b, o2 = e2.a, a22 = o2 < 1 ? D(b(255 * o2)) : "";
        return "#" + D(r2) + D(t2) + D(n2) + a22;
      }, "K"), L = __name(function(e2) {
        var r2 = e2.r, t2 = e2.g, n2 = e2.b, o2 = e2.a, a22 = Math.max(r2, t2, n2), l2 = a22 - Math.min(r2, t2, n2), u22 = l2 ? a22 === r2 ? (t2 - n2) / l2 : a22 === t2 ? 2 + (n2 - r2) / l2 : 4 + (r2 - t2) / l2 : 0;
        return { h: b(60 * (u22 < 0 ? u22 + 6 : u22)), s: b(a22 ? l2 / a22 * 100 : 0), v: b(a22 / 255 * 100), a: o2 };
      }, "L"), S = react_default.memo(function(r2) {
        var t2 = r2.hue, n2 = r2.onChange, o2 = g(["react-colorful__hue", r2.className]);
        return react_default.createElement("div", { className: o2 }, react_default.createElement(m, { onMove: __name(function(e2) {
          n2({ h: 360 * e2.left });
        }, "onMove"), onKey: __name(function(e2) {
          n2({ h: s2(t2 + 360 * e2.left, 0, 360) });
        }, "onKey"), "aria-label": "Hue", "aria-valuenow": b(t2), "aria-valuemax": "360", "aria-valuemin": "0" }, react_default.createElement(p2, { className: "react-colorful__hue-pointer", left: t2 / 360, color: q({ h: t2, s: 100, v: 100, a: 1 }) })));
      }), T = react_default.memo(function(r2) {
        var t2 = r2.hsva, n2 = r2.onChange, o2 = { backgroundColor: q({ h: t2.h, s: 100, v: 100, a: 1 }) };
        return react_default.createElement("div", { className: "react-colorful__saturation", style: o2 }, react_default.createElement(m, { onMove: __name(function(e2) {
          n2({ s: 100 * e2.left, v: 100 - 100 * e2.top });
        }, "onMove"), onKey: __name(function(e2) {
          n2({ s: s2(t2.s + 100 * e2.left, 0, 100), v: s2(t2.v - 100 * e2.top, 0, 100) });
        }, "onKey"), "aria-label": "Color", "aria-valuetext": "Saturation " + b(t2.s) + "%, Brightness " + b(t2.v) + "%" }, react_default.createElement(p2, { className: "react-colorful__saturation-pointer", top: 1 - t2.v / 100, left: t2.s / 100, color: q(t2) })));
      }), F = __name(function(e2, r2) {
        if (e2 === r2) return !0;
        for (var t2 in e2) if (e2[t2] !== r2[t2]) return !1;
        return !0;
      }, "F"), P2 = __name(function(e2, r2) {
        return e2.replace(/\s/g, "") === r2.replace(/\s/g, "");
      }, "P"), X = __name(function(e2, r2) {
        return e2.toLowerCase() === r2.toLowerCase() || F(C2(e2), C2(r2));
      }, "X");
      __name(Y, "Y");
      V = typeof window < "u" ? useLayoutEffect : useEffect, $ = __name(function() {
        return R || (typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0);
      }, "$"), J = /* @__PURE__ */ new Map(), Q = __name(function(e2) {
        V(function() {
          var r2 = e2.current ? e2.current.ownerDocument : document;
          if (r2 !== void 0 && !J.has(r2)) {
            var t2 = r2.createElement("style");
            t2.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, J.set(r2, t2);
            var n2 = $();
            n2 && t2.setAttribute("nonce", n2), r2.head.appendChild(t2);
          }
        }, []);
      }, "Q"), U = __name(function(t2) {
        var n2 = t2.className, o2 = t2.colorModel, a22 = t2.color, l2 = a22 === void 0 ? o2.defaultColor : a22, i22 = t2.onChange, s22 = c(t2, ["className", "colorModel", "color", "onChange"]), f22 = useRef(null);
        Q(f22);
        var v22 = Y(o2, l2, i22), d22 = v22[0], h22 = v22[1], m22 = g(["react-colorful", n2]);
        return react_default.createElement("div", u({}, s22, { ref: f22, className: m22 }), react_default.createElement(T, { hsva: d22, onChange: h22 }), react_default.createElement(S, { hue: d22.h, onChange: h22, className: "react-colorful__last-control" }));
      }, "U"), W = { defaultColor: "000", toHsva: x, fromHsva: __name(function(e2) {
        return w({ h: e2.h, s: e2.s, v: e2.v, a: 1 });
      }, "fromHsva"), equal: X }, Z = __name(function(r2) {
        return react_default.createElement(U, u({}, r2, { colorModel: W }));
      }, "Z"), ee = __name(function(r2) {
        var t2 = r2.className, n2 = r2.hsva, o2 = r2.onChange, a22 = { backgroundImage: "linear-gradient(90deg, " + k(Object.assign({}, n2, { a: 0 })) + ", " + k(Object.assign({}, n2, { a: 1 })) + ")" }, l2 = g(["react-colorful__alpha", t2]), u22 = b(100 * n2.a);
        return react_default.createElement("div", { className: l2 }, react_default.createElement("div", { className: "react-colorful__alpha-gradient", style: a22 }), react_default.createElement(m, { onMove: __name(function(e2) {
          o2({ a: e2.left });
        }, "onMove"), onKey: __name(function(e2) {
          o2({ a: s2(n2.a + e2.left) });
        }, "onKey"), "aria-label": "Alpha", "aria-valuetext": u22 + "%", "aria-valuenow": u22, "aria-valuemin": "0", "aria-valuemax": "100" }, react_default.createElement(p2, { className: "react-colorful__alpha-pointer", left: n2.a, color: k(n2) })));
      }, "ee"), re = __name(function(t2) {
        var n2 = t2.className, o2 = t2.colorModel, a22 = t2.color, l2 = a22 === void 0 ? o2.defaultColor : a22, i22 = t2.onChange, s22 = c(t2, ["className", "colorModel", "color", "onChange"]), f22 = useRef(null);
        Q(f22);
        var v22 = Y(o2, l2, i22), d22 = v22[0], h22 = v22[1], m22 = g(["react-colorful", n2]);
        return react_default.createElement("div", u({}, s22, { ref: f22, className: m22 }), react_default.createElement(T, { hsva: d22, onChange: h22 }), react_default.createElement(S, { hue: d22.h, onChange: h22 }), react_default.createElement(ee, { hsva: d22, onChange: h22, className: "react-colorful__last-control" }));
      }, "re"), le = { defaultColor: "hsla(0, 0%, 0%, 1)", toHsva: H, fromHsva: k, equal: P2 }, ue = __name(function(r2) {
        return react_default.createElement(re, u({}, r2, { colorModel: le }));
      }, "ue"), Ee = { defaultColor: "rgba(0, 0, 0, 1)", toHsva: z, fromHsva: __name(function(e2) {
        var r2 = I(e2);
        return "rgba(" + r2.r + ", " + r2.g + ", " + r2.b + ", " + r2.a + ")";
      }, "fromHsva"), equal: P2 }, He = __name(function(r2) {
        return react_default.createElement(re, u({}, r2, { colorModel: Ee }));
      }, "He"), Wrapper = styled.div({
        position: "relative",
        maxWidth: 250,
        '&[aria-readonly="true"]': {
          opacity: 0.5
        }
      }), PickerTooltip = styled(WithTooltip)({
        position: "absolute",
        zIndex: 1,
        top: 4,
        left: 4,
        "[aria-readonly=true] &": {
          cursor: "not-allowed"
        }
      }), TooltipContent = styled.div({
        width: 200,
        margin: 5,
        ".react-colorful__saturation": {
          borderRadius: "4px 4px 0 0"
        },
        ".react-colorful__hue": {
          boxShadow: "inset 0 0 0 1px rgb(0 0 0 / 5%)"
        },
        ".react-colorful__last-control": {
          borderRadius: "0 0 4px 4px"
        }
      }), Note = styled(TooltipNote)(({ theme: theme3 }) => ({
        fontFamily: theme3.typography.fonts.base
      })), Swatches = styled.div({
        display: "grid",
        gridTemplateColumns: "repeat(9, 16px)",
        gap: 6,
        padding: 3,
        marginTop: 5,
        width: 200
      }), SwatchColor = styled.div(({ theme: theme3, active }) => ({
        width: 16,
        height: 16,
        boxShadow: active ? `${theme3.appBorderColor} 0 0 0 1px inset, ${theme3.textMutedColor}50 0 0 0 4px` : `${theme3.appBorderColor} 0 0 0 1px inset`,
        borderRadius: theme3.appBorderRadius
      })), swatchBackground = `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`, Swatch = __name(({ value: value2, style, ...props }) => {
        let backgroundImage = `linear-gradient(${value2}, ${value2}), ${swatchBackground}, linear-gradient(#fff, #fff)`;
        return react_default.createElement(SwatchColor, { ...props, style: { ...style, backgroundImage } });
      }, "Swatch"), Input = styled(Form.Input)(({ theme: theme3, readOnly }) => ({
        width: "100%",
        paddingLeft: 30,
        paddingRight: 30,
        boxSizing: "border-box",
        fontFamily: theme3.typography.fonts.base
      })), ToggleIcon = styled(MarkupIcon)(({ theme: theme3 }) => ({
        position: "absolute",
        zIndex: 1,
        top: 6,
        right: 7,
        width: 20,
        height: 20,
        padding: 4,
        boxSizing: "border-box",
        cursor: "pointer",
        color: theme3.input.color
      })), ColorSpace = ((ColorSpace2) => (ColorSpace2.RGB = "rgb", ColorSpace2.HSL = "hsl", ColorSpace2.HEX = "hex", ColorSpace2))(ColorSpace || {}), COLOR_SPACES = Object.values(ColorSpace), COLOR_REGEXP2 = /\(([0-9]+),\s*([0-9]+)%?,\s*([0-9]+)%?,?\s*([0-9.]+)?\)/, RGB_REGEXP = /^\s*rgba?\(([0-9]+),\s*([0-9]+),\s*([0-9]+),?\s*([0-9.]+)?\)\s*$/i, HSL_REGEXP = /^\s*hsla?\(([0-9]+),\s*([0-9]+)%,\s*([0-9]+)%,?\s*([0-9.]+)?\)\s*$/i, HEX_REGEXP2 = /^\s*#?([0-9a-f]{3}|[0-9a-f]{6})\s*$/i, SHORTHEX_REGEXP = /^\s*#?([0-9a-f]{3})\s*$/i, ColorPicker = {
        hex: Z,
        rgb: He,
        hsl: ue
      }, fallbackColor = {
        hex: "transparent",
        rgb: "rgba(0, 0, 0, 0)",
        hsl: "hsla(0, 0%, 0%, 0)"
      }, stringToArgs = __name((value2) => {
        let match = value2?.match(COLOR_REGEXP2);
        if (!match)
          return [0, 0, 0, 1];
        let [, x22, y22, z22, a22 = 1] = match;
        return [x22, y22, z22, a22].map(Number);
      }, "stringToArgs"), parseRgb = __name((value2) => {
        let [r2, g22, b22, a22] = stringToArgs(value2), [h22, s22, l2] = import_color_convert.default.rgb.hsl([r2, g22, b22]) || [0, 0, 0];
        return {
          valid: !0,
          value: value2,
          keyword: import_color_convert.default.rgb.keyword([r2, g22, b22]),
          colorSpace: "rgb",
          rgb: value2,
          hsl: `hsla(${h22}, ${s22}%, ${l2}%, ${a22})`,
          hex: `#${import_color_convert.default.rgb.hex([r2, g22, b22]).toLowerCase()}`
        };
      }, "parseRgb"), parseHsl = __name((value2) => {
        let [h22, s22, l2, a22] = stringToArgs(value2), [r2, g22, b22] = import_color_convert.default.hsl.rgb([h22, s22, l2]) || [0, 0, 0];
        return {
          valid: !0,
          value: value2,
          keyword: import_color_convert.default.hsl.keyword([h22, s22, l2]),
          colorSpace: "hsl",
          rgb: `rgba(${r2}, ${g22}, ${b22}, ${a22})`,
          hsl: value2,
          hex: `#${import_color_convert.default.hsl.hex([h22, s22, l2]).toLowerCase()}`
        };
      }, "parseHsl"), parseHexOrKeyword = __name((value2) => {
        let plain = value2.replace("#", ""), rgb2 = import_color_convert.default.keyword.rgb(plain) || import_color_convert.default.hex.rgb(plain), hsl2 = import_color_convert.default.rgb.hsl(rgb2), mapped = value2;
        /[^#a-f0-9]/i.test(value2) ? mapped = plain : HEX_REGEXP2.test(value2) && (mapped = `#${plain}`);
        let valid = !0;
        if (mapped.startsWith("#"))
          valid = HEX_REGEXP2.test(mapped);
        else
          try {
            import_color_convert.default.keyword.hex(mapped);
          } catch {
            valid = !1;
          }
        return {
          valid,
          value: mapped,
          keyword: import_color_convert.default.rgb.keyword(rgb2),
          colorSpace: "hex",
          rgb: `rgba(${rgb2[0]}, ${rgb2[1]}, ${rgb2[2]}, 1)`,
          hsl: `hsla(${hsl2[0]}, ${hsl2[1]}%, ${hsl2[2]}%, 1)`,
          hex: mapped
        };
      }, "parseHexOrKeyword"), parseValue = __name((value2) => {
        if (value2)
          return RGB_REGEXP.test(value2) ? parseRgb(value2) : HSL_REGEXP.test(value2) ? parseHsl(value2) : parseHexOrKeyword(value2);
      }, "parseValue"), getRealValue = __name((value2, color2, colorSpace) => {
        if (!value2 || !color2?.valid)
          return fallbackColor[colorSpace];
        if (colorSpace !== "hex")
          return color2?.[colorSpace] || fallbackColor[colorSpace];
        if (!color2.hex.startsWith("#"))
          try {
            return `#${import_color_convert.default.keyword.hex(color2.hex)}`;
          } catch {
            return fallbackColor.hex;
          }
        let short = color2.hex.match(SHORTHEX_REGEXP);
        if (!short)
          return HEX_REGEXP2.test(color2.hex) ? color2.hex : fallbackColor.hex;
        let [r2, g22, b22] = short[1].split("");
        return `#${r2}${r2}${g22}${g22}${b22}${b22}`;
      }, "getRealValue"), useColorInput = __name((initialValue, onChange) => {
        let [value2, setValue] = useState(initialValue || ""), [color2, setColor] = useState(() => parseValue(value2)), [colorSpace, setColorSpace] = useState(
          color2?.colorSpace || "hex"
          /* HEX */
        );
        useEffect(() => {
          let nextValue = initialValue || "", nextColor = parseValue(nextValue);
          setValue(nextValue), setColor(nextColor), setColorSpace(
            nextColor?.colorSpace || "hex"
            /* HEX */
          );
        }, [initialValue]);
        let realValue = useMemo(
          () => getRealValue(value2, color2, colorSpace).toLowerCase(),
          [value2, color2, colorSpace]
        ), updateValue = useCallback(
          (update) => {
            let parsed = parseValue(update), v22 = parsed?.value || update || "";
            setValue(v22), v22 === "" && (setColor(void 0), onChange(void 0)), parsed && (setColor(parsed), setColorSpace(parsed.colorSpace), onChange(parsed.value));
          },
          [onChange]
        ), cycleColorSpace = useCallback(() => {
          let nextIndex = (COLOR_SPACES.indexOf(colorSpace) + 1) % COLOR_SPACES.length, nextSpace = COLOR_SPACES[nextIndex];
          setColorSpace(nextSpace);
          let updatedValue = color2?.[nextSpace] || "";
          setValue(updatedValue), onChange(updatedValue);
        }, [color2, colorSpace, onChange]);
        return { value: value2, realValue, updateValue, color: color2, colorSpace, cycleColorSpace };
      }, "useColorInput"), id = __name((value2) => value2.replace(/\s*/, "").toLowerCase(), "id"), usePresets = __name((presetColors, currentColor, colorSpace) => {
        let [selectedColors, setSelectedColors] = useState(currentColor?.valid ? [currentColor] : []);
        useEffect(() => {
          currentColor === void 0 && setSelectedColors([]);
        }, [currentColor]);
        let presets = useMemo(() => (presetColors || []).map((preset) => typeof preset == "string" ? parseValue(preset) : preset.title ? { ...parseValue(preset.color), keyword: preset.title } : parseValue(preset.color)).concat(selectedColors).filter(Boolean).slice(-27), [presetColors, selectedColors]), addPreset = useCallback(
          (color2) => {
            color2?.valid && (presets.some(
              (preset) => preset && preset[colorSpace] && id(preset[colorSpace] || "") === id(color2[colorSpace] || "")
            ) || setSelectedColors((arr) => arr.concat(color2)));
          },
          [colorSpace, presets]
        );
        return { presets, addPreset };
      }, "usePresets"), ColorControl = __name(({
        name,
        value: initialValue,
        onChange,
        onFocus,
        onBlur,
        presetColors,
        startOpen = !1,
        argType
      }) => {
        let debouncedOnChange = useCallback(debounce(onChange, 200), [onChange]), { value: value2, realValue, updateValue, color: color2, colorSpace, cycleColorSpace } = useColorInput(
          initialValue,
          debouncedOnChange
        ), { presets, addPreset } = usePresets(presetColors ?? [], color2, colorSpace), Picker = ColorPicker[colorSpace], readonly = !!argType?.table?.readonly;
        return react_default.createElement(Wrapper, { "aria-readonly": readonly }, react_default.createElement(
          PickerTooltip,
          {
            startOpen,
            trigger: readonly ? null : void 0,
            closeOnOutsideClick: !0,
            onVisibleChange: () => color2 && addPreset(color2),
            tooltip: react_default.createElement(TooltipContent, null, react_default.createElement(
              Picker,
              {
                color: realValue === "transparent" ? "#000000" : realValue,
                onChange: updateValue,
                onFocus,
                onBlur
              }
            ), presets.length > 0 && react_default.createElement(Swatches, null, presets.map((preset, index2) => react_default.createElement(
              WithTooltip,
              {
                key: `${preset?.value || index2}-${index2}`,
                hasChrome: !1,
                tooltip: react_default.createElement(Note, { note: preset?.keyword || preset?.value || "" })
              },
              react_default.createElement(
                Swatch,
                {
                  value: preset?.[colorSpace] || "",
                  active: !!(color2 && preset && preset[colorSpace] && id(preset[colorSpace] || "") === id(color2[colorSpace])),
                  onClick: () => preset && updateValue(preset.value || "")
                }
              )
            ))))
          },
          react_default.createElement(Swatch, { value: realValue, style: { margin: 4 } })
        ), react_default.createElement(
          Input,
          {
            id: getControlId(name),
            value: value2,
            onChange: (e2) => updateValue(e2.target.value),
            onFocus: (e2) => e2.target.select(),
            readOnly: readonly,
            placeholder: "Choose color..."
          }
        ), value2 ? react_default.createElement(ToggleIcon, { onClick: cycleColorSpace }) : null);
      }, "ColorControl"), Color_default = ColorControl;
    }
  });

  // node_modules/.cache/storybook/63d5be2a85850ce616b000cbb1b0844c173520f7b332810b4a7322e823aac333/sb-manager/storybook-core-server-presets-0/common-manager-bundle.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/core-server/presets/common-manager.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-L2D73C6Z.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-VAMFPZY3.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  function _objectWithoutPropertiesLoose(r2, e) {
    if (r2 == null) return {};
    var t = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (e.indexOf(n2) !== -1) continue;
      t[n2] = r2[n2];
    }
    return t;
  }
  __name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-L2D73C6Z.js
  init_chunk_MM7DTO55();
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o22) {
      return typeof o22;
    } : function(o22) {
      return o22 && typeof Symbol == "function" && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
    }, _typeof(o2);
  }
  __name(_typeof, "_typeof");
  function toPrimitive(t, r2) {
    if (_typeof(t) != "object" || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (e !== void 0) {
      var i3 = e.call(t, r2 || "default");
      if (_typeof(i3) != "object") return i3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r2 === "string" ? String : Number)(t);
  }
  __name(toPrimitive, "toPrimitive");
  function toPropertyKey(t) {
    var i3 = toPrimitive(t, "string");
    return _typeof(i3) == "symbol" ? i3 : i3 + "";
  }
  __name(toPropertyKey, "toPropertyKey");
  function _defineProperty(e, r2, t) {
    return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r2] = t, e;
  }
  __name(_defineProperty, "_defineProperty");
  function _objectWithoutProperties(e, t) {
    if (e == null) return {};
    var o2, r2, i3 = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], t.indexOf(o2) === -1 && {}.propertyIsEnumerable.call(e, o2) && (i3[o2] = e[o2]);
    }
    return i3;
  }
  __name(_objectWithoutProperties, "_objectWithoutProperties");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-SYS437NN.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var has = Object.prototype.hasOwnProperty;
  function find(iter, tar, key) {
    for (key of iter.keys())
      if (dequal(key, tar)) return key;
  }
  __name(find, "find");
  function dequal(foo, bar) {
    var ctor, len, tmp;
    if (foo === bar) return !0;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
      if (ctor === Date) return foo.getTime() === bar.getTime();
      if (ctor === RegExp) return foo.toString() === bar.toString();
      if (ctor === Array) {
        if ((len = foo.length) === bar.length)
          for (; len-- && dequal(foo[len], bar[len]); ) ;
        return len === -1;
      }
      if (ctor === Set) {
        if (foo.size !== bar.size)
          return !1;
        for (len of foo)
          if (tmp = len, tmp && typeof tmp == "object" && (tmp = find(bar, tmp), !tmp) || !bar.has(tmp)) return !1;
        return !0;
      }
      if (ctor === Map) {
        if (foo.size !== bar.size)
          return !1;
        for (len of foo)
          if (tmp = len[0], tmp && typeof tmp == "object" && (tmp = find(bar, tmp), !tmp) || !dequal(len[1], bar.get(tmp)))
            return !1;
        return !0;
      }
      if (ctor === ArrayBuffer)
        foo = new Uint8Array(foo), bar = new Uint8Array(bar);
      else if (ctor === DataView) {
        if ((len = foo.byteLength) === bar.byteLength)
          for (; len-- && foo.getInt8(len) === bar.getInt8(len); ) ;
        return len === -1;
      }
      if (ArrayBuffer.isView(foo)) {
        if ((len = foo.byteLength) === bar.byteLength)
          for (; len-- && foo[len] === bar[len]; ) ;
        return len === -1;
      }
      if (!ctor || typeof foo == "object") {
        len = 0;
        for (ctor in foo)
          if (has.call(foo, ctor) && ++len && !has.call(bar, ctor) || !(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return !1;
        return Object.keys(bar).length === len;
      }
    }
    return foo !== foo && bar !== bar;
  }
  __name(dequal, "dequal");
  function partition(arr, isInTruthy) {
    let truthy = [], falsy = [];
    for (let i3 = 0; i3 < arr.length; i3++) {
      let item = arr[i3];
      isInTruthy(item) ? truthy.push(item) : falsy.push(item);
    }
    return [truthy, falsy];
  }
  __name(partition, "partition");
  function countBy(arr, mapper) {
    let result = {};
    for (let i3 = 0; i3 < arr.length; i3++) {
      let item = arr[i3], key = mapper(item);
      result[key] = (result[key] ?? 0) + 1;
    }
    return result;
  }
  __name(countBy, "countBy");
  function uniq(arr) {
    return Array.from(new Set(arr));
  }
  __name(uniq, "uniq");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/core-server/presets/common-manager.js
  init_chunk_U46RQHA4();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-CADGRH3P.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID = "storybook/background", PARAM_KEY = "backgrounds", EVENTS = {
    UPDATE: `${ADDON_ID}/update`
  }, ADDON_ID2 = "storybook/measure-addon", TOOL_ID = `${ADDON_ID2}/tool`, PARAM_KEY2 = "measureEnabled", EVENTS2 = {
    RESULT: `${ADDON_ID2}/result`,
    REQUEST: `${ADDON_ID2}/request`,
    CLEAR: `${ADDON_ID2}/clear`
  }, ADDON_ID3 = "storybook/outline", PARAM_KEY3 = "outline", DEFAULT_BACKGROUNDS = {
    light: { name: "light", value: "#F8F8F8" },
    dark: { name: "dark", value: "#333" }
  };

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-OBXWFEPB.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-MH6AXFXB.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n2[r2] = t[r2]);
      }
      return n2;
    }, _extends.apply(null, arguments);
  }
  __name(_extends, "_extends");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-OBXWFEPB.js
  init_chunk_MM7DTO55();
  function _assertThisInitialized(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  __name(_assertThisInitialized, "_assertThisInitialized");
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, _setPrototypeOf(t, e);
  }
  __name(_setPrototypeOf, "_setPrototypeOf");
  function _inheritsLoose(t, o2) {
    t.prototype = Object.create(o2.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o2);
  }
  __name(_inheritsLoose, "_inheritsLoose");
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }
  __name(_getPrototypeOf, "_getPrototypeOf");
  function _isNativeFunction(t) {
    try {
      return Function.toString.call(t).indexOf("[native code]") !== -1;
    } catch {
      return typeof t == "function";
    }
  }
  __name(_isNativeFunction, "_isNativeFunction");
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (_isNativeReflectConstruct = __name(function() {
      return !!t;
    }, "_isNativeReflectConstruct"))();
  }
  __name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
  function _construct(t, e, r2) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o2 = [null];
    o2.push.apply(o2, e);
    var p4 = new (t.bind.apply(t, o2))();
    return r2 && _setPrototypeOf(p4, r2.prototype), p4;
  }
  __name(_construct, "_construct");
  function _wrapNativeSuper(t) {
    var r2 = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return _wrapNativeSuper = __name(function(t2) {
      if (t2 === null || !_isNativeFunction(t2)) return t2;
      if (typeof t2 != "function") throw new TypeError("Super expression must either be null or a function");
      if (r2 !== void 0) {
        if (r2.has(t2)) return r2.get(t2);
        r2.set(t2, Wrapper13);
      }
      function Wrapper13() {
        return _construct(t2, arguments, _getPrototypeOf(this).constructor);
      }
      return __name(Wrapper13, "Wrapper"), Wrapper13.prototype = Object.create(t2.prototype, {
        constructor: {
          value: Wrapper13,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf(Wrapper13, t2);
    }, "_wrapNativeSuper"), _wrapNativeSuper(t);
  }
  __name(_wrapNativeSuper, "_wrapNativeSuper");
  var ERRORS = {
    1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
    2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
    3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
    4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
    5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
    6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
    7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
    8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
    9: `Please provide a number of steps to the modularScale helper.

`,
    10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
    11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
    12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
    13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
    14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
    15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
    16: `You must provide a template to this method.

`,
    17: `You passed an unsupported selector state to this method.

`,
    18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
    19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
    20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
    21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    23: `fontFace expects a name of a font-family.

`,
    24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
    25: `fontFace expects localFonts to be an array.

`,
    26: `fontFace expects fileFormats to be an array.

`,
    27: `radialGradient requries at least 2 color-stops to properly render.

`,
    28: `Please supply a filename to retinaImage() as the first argument.

`,
    29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
    30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
    32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
    33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
    34: `borderRadius expects a radius value as a string or number as the second argument.

`,
    35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
    36: `Property must be a string value.

`,
    37: `Syntax Error at %s.

`,
    38: `Formula contains a function that needs parentheses at %s.

`,
    39: `Formula is missing closing parenthesis at %s.

`,
    40: `Formula has too many closing parentheses at %s.

`,
    41: `All values in a formula must have the same unit or be unitless.

`,
    42: `Please provide a number of steps to the modularScale helper.

`,
    43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
    44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
    45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
    46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
    47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
    48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
    49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
    50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
    51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
    52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
    53: `fontFace expects localFonts to be an array.

`,
    54: `fontFace expects fileFormats to be an array.

`,
    55: `fontFace expects a name of a font-family.

`,
    56: `linearGradient requries at least 2 color-stops to properly render.

`,
    57: `radialGradient requries at least 2 color-stops to properly render.

`,
    58: `Please supply a filename to retinaImage() as the first argument.

`,
    59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
    60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    61: `Property must be a string value.

`,
    62: `borderRadius expects a radius value as a string or number as the second argument.

`,
    63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
    64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
    65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
    66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
    67: `You must provide a template to this method.

`,
    68: `You passed an unsupported selector state to this method.

`,
    69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
    70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
    71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
    72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
    73: `Please provide a valid CSS variable.

`,
    74: `CSS variable not found and no default was provided.

`,
    75: `important requires a valid style object, got a %s instead.

`,
    76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
    77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
    78: `base must be set in "px" or "%" but you set it in "%s".
`
  };
  function format() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    var a3 = args[0], b3 = [], c3;
    for (c3 = 1; c3 < args.length; c3 += 1)
      b3.push(args[c3]);
    return b3.forEach(function(d3) {
      a3 = a3.replace(/%[a-z]/, d3);
    }), a3;
  }
  __name(format, "format");
  var PolishedError = (function(_Error) {
    _inheritsLoose(PolishedError2, _Error);
    function PolishedError2(code) {
      for (var _this, _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
        args[_key2 - 1] = arguments[_key2];
      return _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this, _assertThisInitialized(_this);
    }
    return __name(PolishedError2, "PolishedError"), PolishedError2;
  })(_wrapNativeSuper(Error));
  function endsWith(string, suffix) {
    return string.substr(-suffix.length) === suffix;
  }
  __name(endsWith, "endsWith");
  var cssRegex$1 = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
  function stripUnit(value2) {
    if (typeof value2 != "string") return value2;
    var matchedValue = value2.match(cssRegex$1);
    return matchedValue ? parseFloat(value2) : value2;
  }
  __name(stripUnit, "stripUnit");
  var pxtoFactory = __name(function(to) {
    return function(pxval, base) {
      base === void 0 && (base = "16px");
      var newPxval = pxval, newBase = base;
      if (typeof pxval == "string") {
        if (!endsWith(pxval, "px"))
          throw new PolishedError(69, to, pxval);
        newPxval = stripUnit(pxval);
      }
      if (typeof base == "string") {
        if (!endsWith(base, "px"))
          throw new PolishedError(70, to, base);
        newBase = stripUnit(base);
      }
      if (typeof newPxval == "string")
        throw new PolishedError(71, pxval, to);
      if (typeof newBase == "string")
        throw new PolishedError(72, base, to);
      return "" + newPxval / newBase + to;
    };
  }, "pxtoFactory"), pixelsto = pxtoFactory, em = pixelsto("em"), rem = pixelsto("rem");
  function colorToInt(color2) {
    return Math.round(color2 * 255);
  }
  __name(colorToInt, "colorToInt");
  function convertToInt(red, green, blue) {
    return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
  }
  __name(convertToInt, "convertToInt");
  function hslToRgb(hue, saturation, lightness, convert5) {
    if (convert5 === void 0 && (convert5 = convertToInt), saturation === 0)
      return convert5(lightness, lightness, lightness);
    var huePrime = (hue % 360 + 360) % 360 / 60, chroma = (1 - Math.abs(2 * lightness - 1)) * saturation, secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1)), red = 0, green = 0, blue = 0;
    huePrime >= 0 && huePrime < 1 ? (red = chroma, green = secondComponent) : huePrime >= 1 && huePrime < 2 ? (red = secondComponent, green = chroma) : huePrime >= 2 && huePrime < 3 ? (green = chroma, blue = secondComponent) : huePrime >= 3 && huePrime < 4 ? (green = secondComponent, blue = chroma) : huePrime >= 4 && huePrime < 5 ? (red = secondComponent, blue = chroma) : huePrime >= 5 && huePrime < 6 && (red = chroma, blue = secondComponent);
    var lightnessModification = lightness - chroma / 2, finalRed = red + lightnessModification, finalGreen = green + lightnessModification, finalBlue = blue + lightnessModification;
    return convert5(finalRed, finalGreen, finalBlue);
  }
  __name(hslToRgb, "hslToRgb");
  var namedColorMap = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "639",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  };
  function nameToHex(color2) {
    if (typeof color2 != "string") return color2;
    var normalizedColorName = color2.toLowerCase();
    return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color2;
  }
  __name(nameToHex, "nameToHex");
  var hexRegex = /^#[a-fA-F0-9]{6}$/, hexRgbaRegex = /^#[a-fA-F0-9]{8}$/, reducedHexRegex = /^#[a-fA-F0-9]{3}$/, reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/, rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
  function parseToRgb(color2) {
    if (typeof color2 != "string")
      throw new PolishedError(3);
    var normalizedColor = nameToHex(color2);
    if (normalizedColor.match(hexRegex))
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
      };
    if (normalizedColor.match(hexRgbaRegex)) {
      var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
        alpha
      };
    }
    if (normalizedColor.match(reducedHexRegex))
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
      };
    if (normalizedColor.match(reducedRgbaHexRegex)) {
      var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
        alpha: _alpha
      };
    }
    var rgbMatched = rgbRegex.exec(normalizedColor);
    if (rgbMatched)
      return {
        red: parseInt("" + rgbMatched[1], 10),
        green: parseInt("" + rgbMatched[2], 10),
        blue: parseInt("" + rgbMatched[3], 10)
      };
    var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
    if (rgbaMatched)
      return {
        red: parseInt("" + rgbaMatched[1], 10),
        green: parseInt("" + rgbaMatched[2], 10),
        blue: parseInt("" + rgbaMatched[3], 10),
        alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
      };
    var hslMatched = hslRegex.exec(normalizedColor);
    if (hslMatched) {
      var hue = parseInt("" + hslMatched[1], 10), saturation = parseInt("" + hslMatched[2], 10) / 100, lightness = parseInt("" + hslMatched[3], 10) / 100, rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")", hslRgbMatched = rgbRegex.exec(rgbColorString);
      if (!hslRgbMatched)
        throw new PolishedError(4, normalizedColor, rgbColorString);
      return {
        red: parseInt("" + hslRgbMatched[1], 10),
        green: parseInt("" + hslRgbMatched[2], 10),
        blue: parseInt("" + hslRgbMatched[3], 10)
      };
    }
    var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
    if (hslaMatched) {
      var _hue = parseInt("" + hslaMatched[1], 10), _saturation = parseInt("" + hslaMatched[2], 10) / 100, _lightness = parseInt("" + hslaMatched[3], 10) / 100, _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")", _hslRgbMatched = rgbRegex.exec(_rgbColorString);
      if (!_hslRgbMatched)
        throw new PolishedError(4, normalizedColor, _rgbColorString);
      return {
        red: parseInt("" + _hslRgbMatched[1], 10),
        green: parseInt("" + _hslRgbMatched[2], 10),
        blue: parseInt("" + _hslRgbMatched[3], 10),
        alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
      };
    }
    throw new PolishedError(5);
  }
  __name(parseToRgb, "parseToRgb");
  function rgbToHsl(color2) {
    var red = color2.red / 255, green = color2.green / 255, blue = color2.blue / 255, max = Math.max(red, green, blue), min = Math.min(red, green, blue), lightness = (max + min) / 2;
    if (max === min)
      return color2.alpha !== void 0 ? {
        hue: 0,
        saturation: 0,
        lightness,
        alpha: color2.alpha
      } : {
        hue: 0,
        saturation: 0,
        lightness
      };
    var hue, delta = max - min, saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
    switch (max) {
      case red:
        hue = (green - blue) / delta + (green < blue ? 6 : 0);
        break;
      case green:
        hue = (blue - red) / delta + 2;
        break;
      default:
        hue = (red - green) / delta + 4;
        break;
    }
    return hue *= 60, color2.alpha !== void 0 ? {
      hue,
      saturation,
      lightness,
      alpha: color2.alpha
    } : {
      hue,
      saturation,
      lightness
    };
  }
  __name(rgbToHsl, "rgbToHsl");
  function parseToHsl(color2) {
    return rgbToHsl(parseToRgb(color2));
  }
  __name(parseToHsl, "parseToHsl");
  var reduceHexValue = __name(function(value2) {
    return value2.length === 7 && value2[1] === value2[2] && value2[3] === value2[4] && value2[5] === value2[6] ? "#" + value2[1] + value2[3] + value2[5] : value2;
  }, "reduceHexValue"), reduceHexValue$1 = reduceHexValue;
  function numberToHex(value2) {
    var hex2 = value2.toString(16);
    return hex2.length === 1 ? "0" + hex2 : hex2;
  }
  __name(numberToHex, "numberToHex");
  function colorToHex(color2) {
    return numberToHex(Math.round(color2 * 255));
  }
  __name(colorToHex, "colorToHex");
  function convertToHex(red, green, blue) {
    return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
  }
  __name(convertToHex, "convertToHex");
  function hslToHex(hue, saturation, lightness) {
    return hslToRgb(hue, saturation, lightness, convertToHex);
  }
  __name(hslToHex, "hslToHex");
  function hsl(value2, saturation, lightness) {
    if (typeof value2 == "number" && typeof saturation == "number" && typeof lightness == "number")
      return hslToHex(value2, saturation, lightness);
    if (typeof value2 == "object" && saturation === void 0 && lightness === void 0)
      return hslToHex(value2.hue, value2.saturation, value2.lightness);
    throw new PolishedError(1);
  }
  __name(hsl, "hsl");
  function hsla(value2, saturation, lightness, alpha) {
    if (typeof value2 == "number" && typeof saturation == "number" && typeof lightness == "number" && typeof alpha == "number")
      return alpha >= 1 ? hslToHex(value2, saturation, lightness) : "rgba(" + hslToRgb(value2, saturation, lightness) + "," + alpha + ")";
    if (typeof value2 == "object" && saturation === void 0 && lightness === void 0 && alpha === void 0)
      return value2.alpha >= 1 ? hslToHex(value2.hue, value2.saturation, value2.lightness) : "rgba(" + hslToRgb(value2.hue, value2.saturation, value2.lightness) + "," + value2.alpha + ")";
    throw new PolishedError(2);
  }
  __name(hsla, "hsla");
  function rgb(value2, green, blue) {
    if (typeof value2 == "number" && typeof green == "number" && typeof blue == "number")
      return reduceHexValue$1("#" + numberToHex(value2) + numberToHex(green) + numberToHex(blue));
    if (typeof value2 == "object" && green === void 0 && blue === void 0)
      return reduceHexValue$1("#" + numberToHex(value2.red) + numberToHex(value2.green) + numberToHex(value2.blue));
    throw new PolishedError(6);
  }
  __name(rgb, "rgb");
  function rgba(firstValue, secondValue, thirdValue, fourthValue) {
    if (typeof firstValue == "string" && typeof secondValue == "number") {
      var rgbValue = parseToRgb(firstValue);
      return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
    } else {
      if (typeof firstValue == "number" && typeof secondValue == "number" && typeof thirdValue == "number" && typeof fourthValue == "number")
        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
      if (typeof firstValue == "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0)
        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
    }
    throw new PolishedError(7);
  }
  __name(rgba, "rgba");
  var isRgb = __name(function(color2) {
    return typeof color2.red == "number" && typeof color2.green == "number" && typeof color2.blue == "number" && (typeof color2.alpha != "number" || typeof color2.alpha > "u");
  }, "isRgb"), isRgba = __name(function(color2) {
    return typeof color2.red == "number" && typeof color2.green == "number" && typeof color2.blue == "number" && typeof color2.alpha == "number";
  }, "isRgba"), isHsl = __name(function(color2) {
    return typeof color2.hue == "number" && typeof color2.saturation == "number" && typeof color2.lightness == "number" && (typeof color2.alpha != "number" || typeof color2.alpha > "u");
  }, "isHsl"), isHsla = __name(function(color2) {
    return typeof color2.hue == "number" && typeof color2.saturation == "number" && typeof color2.lightness == "number" && typeof color2.alpha == "number";
  }, "isHsla");
  function toColorString(color2) {
    if (typeof color2 != "object") throw new PolishedError(8);
    if (isRgba(color2)) return rgba(color2);
    if (isRgb(color2)) return rgb(color2);
    if (isHsla(color2)) return hsla(color2);
    if (isHsl(color2)) return hsl(color2);
    throw new PolishedError(8);
  }
  __name(toColorString, "toColorString");
  function curried(f4, length2, acc) {
    return __name(function() {
      var combined = acc.concat(Array.prototype.slice.call(arguments));
      return combined.length >= length2 ? f4.apply(this, combined) : curried(f4, length2, combined);
    }, "fn");
  }
  __name(curried, "curried");
  function curry(f4) {
    return curried(f4, f4.length, []);
  }
  __name(curry, "curry");
  function adjustHue(degree, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      hue: hslColor.hue + parseFloat(degree)
    }));
  }
  __name(adjustHue, "adjustHue");
  var curriedAdjustHue = curry(adjustHue);
  function guard(lowerBoundary, upperBoundary, value2) {
    return Math.max(lowerBoundary, Math.min(upperBoundary, value2));
  }
  __name(guard, "guard");
  function darken(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
    }));
  }
  __name(darken, "darken");
  var curriedDarken = curry(darken), curriedDarken$1 = curriedDarken;
  function desaturate(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
    }));
  }
  __name(desaturate, "desaturate");
  var curriedDesaturate = curry(desaturate);
  function lighten(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
    }));
  }
  __name(lighten, "lighten");
  var curriedLighten = curry(lighten), curriedLighten$1 = curriedLighten;
  function mix(weight, color2, otherColor) {
    if (color2 === "transparent") return otherColor;
    if (otherColor === "transparent") return color2;
    if (weight === 0) return otherColor;
    var parsedColor1 = parseToRgb(color2), color1 = _extends({}, parsedColor1, {
      alpha: typeof parsedColor1.alpha == "number" ? parsedColor1.alpha : 1
    }), parsedColor2 = parseToRgb(otherColor), color22 = _extends({}, parsedColor2, {
      alpha: typeof parsedColor2.alpha == "number" ? parsedColor2.alpha : 1
    }), alphaDelta = color1.alpha - color22.alpha, x3 = parseFloat(weight) * 2 - 1, y3 = x3 * alphaDelta === -1 ? x3 : x3 + alphaDelta, z3 = 1 + x3 * alphaDelta, weight1 = (y3 / z3 + 1) / 2, weight2 = 1 - weight1, mixedColor = {
      red: Math.floor(color1.red * weight1 + color22.red * weight2),
      green: Math.floor(color1.green * weight1 + color22.green * weight2),
      blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
      alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
    };
    return rgba(mixedColor);
  }
  __name(mix, "mix");
  var curriedMix = curry(mix), mix$1 = curriedMix;
  function opacify(amount, color2) {
    if (color2 === "transparent") return color2;
    var parsedColor = parseToRgb(color2), alpha = typeof parsedColor.alpha == "number" ? parsedColor.alpha : 1, colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
    });
    return rgba(colorWithAlpha);
  }
  __name(opacify, "opacify");
  var curriedOpacify = curry(opacify), curriedOpacify$1 = curriedOpacify;
  function saturate(amount, color2) {
    if (color2 === "transparent") return color2;
    var hslColor = parseToHsl(color2);
    return toColorString(_extends({}, hslColor, {
      saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
    }));
  }
  __name(saturate, "saturate");
  var curriedSaturate = curry(saturate);
  function setHue(hue, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      hue: parseFloat(hue)
    }));
  }
  __name(setHue, "setHue");
  var curriedSetHue = curry(setHue);
  function setLightness(lightness, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      lightness: parseFloat(lightness)
    }));
  }
  __name(setLightness, "setLightness");
  var curriedSetLightness = curry(setLightness);
  function setSaturation(saturation, color2) {
    return color2 === "transparent" ? color2 : toColorString(_extends({}, parseToHsl(color2), {
      saturation: parseFloat(saturation)
    }));
  }
  __name(setSaturation, "setSaturation");
  var curriedSetSaturation = curry(setSaturation);
  function shade(percentage, color2) {
    return color2 === "transparent" ? color2 : mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color2);
  }
  __name(shade, "shade");
  var curriedShade = curry(shade);
  function tint(percentage, color2) {
    return color2 === "transparent" ? color2 : mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color2);
  }
  __name(tint, "tint");
  var curriedTint = curry(tint);
  function transparentize(amount, color2) {
    if (color2 === "transparent") return color2;
    var parsedColor = parseToRgb(color2), alpha = typeof parsedColor.alpha == "number" ? parsedColor.alpha : 1, colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
    });
    return rgba(colorWithAlpha);
  }
  __name(transparentize, "transparentize");
  var curriedTransparentize = curry(transparentize), curriedTransparentize$1 = curriedTransparentize;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-SN4J4IQ3.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var EVENTS3 = {
    CALL: "storybook/instrumenter/call",
    SYNC: "storybook/instrumenter/sync",
    START: "storybook/instrumenter/start",
    BACK: "storybook/instrumenter/back",
    GOTO: "storybook/instrumenter/goto",
    NEXT: "storybook/instrumenter/next",
    END: "storybook/instrumenter/end"
  }, CallStates = ((CallStates2) => (CallStates2.DONE = "done", CallStates2.ERROR = "error", CallStates2.ACTIVE = "active", CallStates2.WAITING = "waiting", CallStates2))(CallStates || {});

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-F4Q6SGTB.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var require_entities = __commonJS({
    "../node_modules/entities/lib/maps/entities.json"(exports, module) {
      module.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
    }
  }), require_legacy = __commonJS({
    "../node_modules/entities/lib/maps/legacy.json"(exports, module) {
      module.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
    }
  }), require_xml = __commonJS({
    "../node_modules/entities/lib/maps/xml.json"(exports, module) {
      module.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
    }
  }), require_decode = __commonJS({
    "../node_modules/entities/lib/maps/decode.json"(exports, module) {
      module.exports = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
    }
  }), require_decode_codepoint = __commonJS({
    "../node_modules/entities/lib/decode_codepoint.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 });
      var decode_json_1 = __importDefault(require_decode()), fromCodePoint = (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        String.fromCodePoint || function(codePoint) {
          var output = "";
          return codePoint > 65535 && (codePoint -= 65536, output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), output += String.fromCharCode(codePoint), output;
        }
      );
      function decodeCodePoint(codePoint) {
        return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? "\uFFFD" : (codePoint in decode_json_1.default && (codePoint = decode_json_1.default[codePoint]), fromCodePoint(codePoint));
      }
      __name(decodeCodePoint, "decodeCodePoint"), exports.default = decodeCodePoint;
    }
  }), require_decode2 = __commonJS({
    "../node_modules/entities/lib/decode.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
      var entities_json_1 = __importDefault(require_entities()), legacy_json_1 = __importDefault(require_legacy()), xml_json_1 = __importDefault(require_xml()), decode_codepoint_1 = __importDefault(require_decode_codepoint()), strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
      exports.decodeXML = getStrictDecoder(xml_json_1.default), exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
      function getStrictDecoder(map2) {
        var replace = getReplacer(map2);
        return function(str2) {
          return String(str2).replace(strictEntityRe, replace);
        };
      }
      __name(getStrictDecoder, "getStrictDecoder");
      var sorter = __name(function(a3, b3) {
        return a3 < b3 ? 1 : -1;
      }, "sorter");
      exports.decodeHTML = (function() {
        for (var legacy = Object.keys(legacy_json_1.default).sort(sorter), keys = Object.keys(entities_json_1.default).sort(sorter), i3 = 0, j2 = 0; i3 < keys.length; i3++)
          legacy[j2] === keys[i3] ? (keys[i3] += ";?", j2++) : keys[i3] += ";";
        var re3 = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entities_json_1.default);
        function replacer(str2) {
          return str2.substr(-1) !== ";" && (str2 += ";"), replace(str2);
        }
        return __name(replacer, "replacer"), function(str2) {
          return String(str2).replace(re3, replacer);
        };
      })();
      function getReplacer(map2) {
        return __name(function(str2) {
          if (str2.charAt(1) === "#") {
            var secondChar = str2.charAt(2);
            return secondChar === "X" || secondChar === "x" ? decode_codepoint_1.default(parseInt(str2.substr(3), 16)) : decode_codepoint_1.default(parseInt(str2.substr(2), 10));
          }
          return map2[str2.slice(1, -1)] || str2;
        }, "replace");
      }
      __name(getReplacer, "getReplacer");
    }
  }), require_encode = __commonJS({
    "../node_modules/entities/lib/encode.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
      var xml_json_1 = __importDefault(require_xml()), inverseXML = getInverseObj(xml_json_1.default), xmlReplacer = getInverseReplacer(inverseXML);
      exports.encodeXML = getASCIIEncoder(inverseXML);
      var entities_json_1 = __importDefault(require_entities()), inverseHTML = getInverseObj(entities_json_1.default), htmlReplacer = getInverseReplacer(inverseHTML);
      exports.encodeHTML = getInverse(inverseHTML, htmlReplacer), exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
      function getInverseObj(obj) {
        return Object.keys(obj).sort().reduce(function(inverse, name) {
          return inverse[obj[name]] = "&" + name + ";", inverse;
        }, {});
      }
      __name(getInverseObj, "getInverseObj");
      function getInverseReplacer(inverse) {
        for (var single = [], multiple = [], _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
          var k3 = _a[_i];
          k3.length === 1 ? single.push("\\" + k3) : multiple.push(k3);
        }
        single.sort();
        for (var start = 0; start < single.length - 1; start++) {
          for (var end = start; end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1); )
            end += 1;
          var count2 = 1 + end - start;
          count2 < 3 || single.splice(start, count2, single[start] + "-" + single[end]);
        }
        return multiple.unshift("[" + single.join("") + "]"), new RegExp(multiple.join("|"), "g");
      }
      __name(getInverseReplacer, "getInverseReplacer");
      var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, getCodePoint = (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        String.prototype.codePointAt != null ? (
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          (function(str2) {
            return str2.codePointAt(0);
          })
        ) : (
          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          (function(c3) {
            return (c3.charCodeAt(0) - 55296) * 1024 + c3.charCodeAt(1) - 56320 + 65536;
          })
        )
      );
      function singleCharReplacer(c3) {
        return "&#x" + (c3.length > 1 ? getCodePoint(c3) : c3.charCodeAt(0)).toString(16).toUpperCase() + ";";
      }
      __name(singleCharReplacer, "singleCharReplacer");
      function getInverse(inverse, re3) {
        return function(data) {
          return data.replace(re3, function(name) {
            return inverse[name];
          }).replace(reNonASCII, singleCharReplacer);
        };
      }
      __name(getInverse, "getInverse");
      var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
      function escape2(data) {
        return data.replace(reEscapeChars, singleCharReplacer);
      }
      __name(escape2, "escape"), exports.escape = escape2;
      function escapeUTF8(data) {
        return data.replace(xmlReplacer, singleCharReplacer);
      }
      __name(escapeUTF8, "escapeUTF8"), exports.escapeUTF8 = escapeUTF8;
      function getASCIIEncoder(obj) {
        return function(data) {
          return data.replace(reEscapeChars, function(c3) {
            return obj[c3] || singleCharReplacer(c3);
          });
        };
      }
      __name(getASCIIEncoder, "getASCIIEncoder");
    }
  }), require_lib = __commonJS({
    "../node_modules/entities/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
      var decode_1 = require_decode2(), encode_1 = require_encode();
      function decode(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
      }
      __name(decode, "decode"), exports.decode = decode;
      function decodeStrict(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
      }
      __name(decodeStrict, "decodeStrict"), exports.decodeStrict = decodeStrict;
      function encode(data, level) {
        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
      }
      __name(encode, "encode"), exports.encode = encode;
      var encode_2 = require_encode();
      Object.defineProperty(exports, "encodeXML", { enumerable: !0, get: __name(function() {
        return encode_2.encodeXML;
      }, "get") }), Object.defineProperty(exports, "encodeHTML", { enumerable: !0, get: __name(function() {
        return encode_2.encodeHTML;
      }, "get") }), Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: !0, get: __name(function() {
        return encode_2.encodeNonAsciiHTML;
      }, "get") }), Object.defineProperty(exports, "escape", { enumerable: !0, get: __name(function() {
        return encode_2.escape;
      }, "get") }), Object.defineProperty(exports, "escapeUTF8", { enumerable: !0, get: __name(function() {
        return encode_2.escapeUTF8;
      }, "get") }), Object.defineProperty(exports, "encodeHTML4", { enumerable: !0, get: __name(function() {
        return encode_2.encodeHTML;
      }, "get") }), Object.defineProperty(exports, "encodeHTML5", { enumerable: !0, get: __name(function() {
        return encode_2.encodeHTML;
      }, "get") });
      var decode_2 = require_decode2();
      Object.defineProperty(exports, "decodeXML", { enumerable: !0, get: __name(function() {
        return decode_2.decodeXML;
      }, "get") }), Object.defineProperty(exports, "decodeHTML", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTML;
      }, "get") }), Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTMLStrict;
      }, "get") }), Object.defineProperty(exports, "decodeHTML4", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTML;
      }, "get") }), Object.defineProperty(exports, "decodeHTML5", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTML;
      }, "get") }), Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTMLStrict;
      }, "get") }), Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: !0, get: __name(function() {
        return decode_2.decodeHTMLStrict;
      }, "get") }), Object.defineProperty(exports, "decodeXMLStrict", { enumerable: !0, get: __name(function() {
        return decode_2.decodeXML;
      }, "get") });
    }
  }), require_ansi_to_html = __commonJS({
    "../node_modules/ansi-to-html/lib/ansi_to_html.js"(exports, module) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor))
          throw new TypeError("Cannot call a class as a function");
      }
      __name(_classCallCheck, "_classCallCheck");
      function _defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      __name(_defineProperties, "_defineProperties");
      function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
      }
      __name(_createClass, "_createClass");
      function _createForOfIteratorHelper(o2, allowArrayLike) {
        var it = typeof Symbol < "u" && o2[Symbol.iterator] || o2["@@iterator"];
        if (!it) {
          if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length == "number") {
            it && (o2 = it);
            var i3 = 0, F3 = __name(function() {
            }, "F");
            return { s: F3, n: __name(function() {
              return i3 >= o2.length ? { done: !0 } : { done: !1, value: o2[i3++] };
            }, "n"), e: __name(function(_e2) {
              throw _e2;
            }, "e"), f: F3 };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var normalCompletion = !0, didErr = !1, err;
        return { s: __name(function() {
          it = it.call(o2);
        }, "s"), n: __name(function() {
          var step2 = it.next();
          return normalCompletion = step2.done, step2;
        }, "n"), e: __name(function(_e2) {
          didErr = !0, err = _e2;
        }, "e"), f: __name(function() {
          try {
            !normalCompletion && it.return != null && it.return();
          } finally {
            if (didErr) throw err;
          }
        }, "f") };
      }
      __name(_createForOfIteratorHelper, "_createForOfIteratorHelper");
      function _unsupportedIterableToArray(o2, minLen) {
        if (o2) {
          if (typeof o2 == "string") return _arrayLikeToArray(o2, minLen);
          var n2 = Object.prototype.toString.call(o2).slice(8, -1);
          if (n2 === "Object" && o2.constructor && (n2 = o2.constructor.name), n2 === "Map" || n2 === "Set") return Array.from(o2);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
        }
      }
      __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
      function _arrayLikeToArray(arr, len) {
        (len == null || len > arr.length) && (len = arr.length);
        for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
          arr2[i3] = arr[i3];
        return arr2;
      }
      __name(_arrayLikeToArray, "_arrayLikeToArray");
      var entities = require_lib(), defaults = {
        fg: "#FFF",
        bg: "#000",
        newline: !1,
        escapeXML: !1,
        stream: !1,
        colors: getDefaultColors()
      };
      function getDefaultColors() {
        var colors3 = {
          0: "#000",
          1: "#A00",
          2: "#0A0",
          3: "#A50",
          4: "#00A",
          5: "#A0A",
          6: "#0AA",
          7: "#AAA",
          8: "#555",
          9: "#F55",
          10: "#5F5",
          11: "#FF5",
          12: "#55F",
          13: "#F5F",
          14: "#5FF",
          15: "#FFF"
        };
        return range(0, 5).forEach(function(red) {
          range(0, 5).forEach(function(green) {
            range(0, 5).forEach(function(blue) {
              return setStyleColor(red, green, blue, colors3);
            });
          });
        }), range(0, 23).forEach(function(gray) {
          var c3 = gray + 232, l2 = toHexString(gray * 10 + 8);
          colors3[c3] = "#" + l2 + l2 + l2;
        }), colors3;
      }
      __name(getDefaultColors, "getDefaultColors");
      function setStyleColor(red, green, blue, colors3) {
        var c3 = 16 + red * 36 + green * 6 + blue, r2 = red > 0 ? red * 40 + 55 : 0, g3 = green > 0 ? green * 40 + 55 : 0, b3 = blue > 0 ? blue * 40 + 55 : 0;
        colors3[c3] = toColorHexString([r2, g3, b3]);
      }
      __name(setStyleColor, "setStyleColor");
      function toHexString(num) {
        for (var str2 = num.toString(16); str2.length < 2; )
          str2 = "0" + str2;
        return str2;
      }
      __name(toHexString, "toHexString");
      function toColorHexString(ref) {
        var results = [], _iterator = _createForOfIteratorHelper(ref), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var r2 = _step.value;
            results.push(toHexString(r2));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return "#" + results.join("");
      }
      __name(toColorHexString, "toColorHexString");
      function generateOutput(stack, token, data, options) {
        var result;
        return token === "text" ? result = pushText(data, options) : token === "display" ? result = handleDisplay(stack, data, options) : token === "xterm256Foreground" ? result = pushForegroundColor(stack, options.colors[data]) : token === "xterm256Background" ? result = pushBackgroundColor(stack, options.colors[data]) : token === "rgb" && (result = handleRgb(stack, data)), result;
      }
      __name(generateOutput, "generateOutput");
      function handleRgb(stack, data) {
        data = data.substring(2).slice(0, -1);
        var operation = +data.substr(0, 2), color2 = data.substring(5).split(";"), rgb2 = color2.map(function(value2) {
          return ("0" + Number(value2).toString(16)).substr(-2);
        }).join("");
        return pushStyle(stack, (operation === 38 ? "color:#" : "background-color:#") + rgb2);
      }
      __name(handleRgb, "handleRgb");
      function handleDisplay(stack, code, options) {
        code = parseInt(code, 10);
        var codeMap = {
          "-1": __name(function() {
            return "<br/>";
          }, "_"),
          0: __name(function() {
            return stack.length && resetStyles(stack);
          }, "_"),
          1: __name(function() {
            return pushTag(stack, "b");
          }, "_"),
          3: __name(function() {
            return pushTag(stack, "i");
          }, "_"),
          4: __name(function() {
            return pushTag(stack, "u");
          }, "_"),
          8: __name(function() {
            return pushStyle(stack, "display:none");
          }, "_"),
          9: __name(function() {
            return pushTag(stack, "strike");
          }, "_"),
          22: __name(function() {
            return pushStyle(stack, "font-weight:normal;text-decoration:none;font-style:normal");
          }, "_"),
          23: __name(function() {
            return closeTag(stack, "i");
          }, "_"),
          24: __name(function() {
            return closeTag(stack, "u");
          }, "_"),
          39: __name(function() {
            return pushForegroundColor(stack, options.fg);
          }, "_"),
          49: __name(function() {
            return pushBackgroundColor(stack, options.bg);
          }, "_"),
          53: __name(function() {
            return pushStyle(stack, "text-decoration:overline");
          }, "_")
        }, result;
        return codeMap[code] ? result = codeMap[code]() : 4 < code && code < 7 ? result = pushTag(stack, "blink") : 29 < code && code < 38 ? result = pushForegroundColor(stack, options.colors[code - 30]) : 39 < code && code < 48 ? result = pushBackgroundColor(stack, options.colors[code - 40]) : 89 < code && code < 98 ? result = pushForegroundColor(stack, options.colors[8 + (code - 90)]) : 99 < code && code < 108 && (result = pushBackgroundColor(stack, options.colors[8 + (code - 100)])), result;
      }
      __name(handleDisplay, "handleDisplay");
      function resetStyles(stack) {
        var stackClone = stack.slice(0);
        return stack.length = 0, stackClone.reverse().map(function(tag) {
          return "</" + tag + ">";
        }).join("");
      }
      __name(resetStyles, "resetStyles");
      function range(low, high) {
        for (var results = [], j2 = low; j2 <= high; j2++)
          results.push(j2);
        return results;
      }
      __name(range, "range");
      function notCategory(category) {
        return function(e) {
          return (category === null || e.category !== category) && category !== "all";
        };
      }
      __name(notCategory, "notCategory");
      function categoryForCode(code) {
        code = parseInt(code, 10);
        var result = null;
        return code === 0 ? result = "all" : code === 1 ? result = "bold" : 2 < code && code < 5 ? result = "underline" : 4 < code && code < 7 ? result = "blink" : code === 8 ? result = "hide" : code === 9 ? result = "strike" : 29 < code && code < 38 || code === 39 || 89 < code && code < 98 ? result = "foreground-color" : (39 < code && code < 48 || code === 49 || 99 < code && code < 108) && (result = "background-color"), result;
      }
      __name(categoryForCode, "categoryForCode");
      function pushText(text, options) {
        return options.escapeXML ? entities.encodeXML(text) : text;
      }
      __name(pushText, "pushText");
      function pushTag(stack, tag, style) {
        return style || (style = ""), stack.push(tag), "<".concat(tag).concat(style ? ' style="'.concat(style, '"') : "", ">");
      }
      __name(pushTag, "pushTag");
      function pushStyle(stack, style) {
        return pushTag(stack, "span", style);
      }
      __name(pushStyle, "pushStyle");
      function pushForegroundColor(stack, color2) {
        return pushTag(stack, "span", "color:" + color2);
      }
      __name(pushForegroundColor, "pushForegroundColor");
      function pushBackgroundColor(stack, color2) {
        return pushTag(stack, "span", "background-color:" + color2);
      }
      __name(pushBackgroundColor, "pushBackgroundColor");
      function closeTag(stack, style) {
        var last;
        if (stack.slice(-1)[0] === style && (last = stack.pop()), last)
          return "</" + style + ">";
      }
      __name(closeTag, "closeTag");
      function tokenize(text, options, callback) {
        var ansiMatch = !1, ansiHandler = 3;
        function remove() {
          return "";
        }
        __name(remove, "remove");
        function removeXterm256Foreground(m3, g1) {
          return callback("xterm256Foreground", g1), "";
        }
        __name(removeXterm256Foreground, "removeXterm256Foreground");
        function removeXterm256Background(m3, g1) {
          return callback("xterm256Background", g1), "";
        }
        __name(removeXterm256Background, "removeXterm256Background");
        function newline(m3) {
          return options.newline ? callback("display", -1) : callback("text", m3), "";
        }
        __name(newline, "newline");
        function ansiMess(m3, g1) {
          ansiMatch = !0, g1.trim().length === 0 && (g1 = "0"), g1 = g1.trimRight(";").split(";");
          var _iterator2 = _createForOfIteratorHelper(g1), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var g3 = _step2.value;
              callback("display", g3);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return "";
        }
        __name(ansiMess, "ansiMess");
        function realText(m3) {
          return callback("text", m3), "";
        }
        __name(realText, "realText");
        function rgb2(m3) {
          return callback("rgb", m3), "";
        }
        __name(rgb2, "rgb");
        var tokens = [{
          pattern: /^\x08+/,
          sub: remove
        }, {
          pattern: /^\x1b\[[012]?K/,
          sub: remove
        }, {
          pattern: /^\x1b\[\(B/,
          sub: remove
        }, {
          pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
          sub: rgb2
        }, {
          pattern: /^\x1b\[38;5;(\d+)m/,
          sub: removeXterm256Foreground
        }, {
          pattern: /^\x1b\[48;5;(\d+)m/,
          sub: removeXterm256Background
        }, {
          pattern: /^\n/,
          sub: newline
        }, {
          pattern: /^\r+\n/,
          sub: newline
        }, {
          pattern: /^\r/,
          sub: newline
        }, {
          pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
          sub: ansiMess
        }, {
          // CSI n J
          // ED - Erase in Display Clears part of the screen.
          // If n is 0 (or missing), clear from cursor to end of screen.
          // If n is 1, clear from cursor to beginning of the screen.
          // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
          // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
          //   (this feature was added for xterm and is supported by other terminal applications).
          pattern: /^\x1b\[\d?J/,
          sub: remove
        }, {
          // CSI n ; m f
          // HVP - Horizontal Vertical Position Same as CUP
          pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
          sub: remove
        }, {
          // catch-all for CSI sequences?
          pattern: /^\x1b\[?[\d;]{0,3}/,
          sub: remove
        }, {
          /**
           * extracts real text - not containing:
           * - `\x1b' - ESC - escape (Ascii 27)
           * - '\x08' - BS - backspace (Ascii 8)
           * - `\n` - Newline - linefeed (LF) (ascii 10)
           * - `\r` - Windows Carriage Return (CR)
           */
          pattern: /^(([^\x1b\x08\r\n])+)/,
          sub: realText
        }];
        function process2(handler2, i22) {
          i22 > ansiHandler && ansiMatch || (ansiMatch = !1, text = text.replace(handler2.pattern, handler2.sub));
        }
        __name(process2, "process");
        var results1 = [], _text = text, length2 = _text.length;
        outer: for (; length2 > 0; ) {
          for (var i3 = 0, o2 = 0, len = tokens.length; o2 < len; i3 = ++o2) {
            var handler = tokens[i3];
            if (process2(handler, i3), text.length !== length2) {
              length2 = text.length;
              continue outer;
            }
          }
          if (text.length === length2)
            break;
          results1.push(0), length2 = text.length;
        }
        return results1;
      }
      __name(tokenize, "tokenize");
      function updateStickyStack(stickyStack, token, data) {
        return token !== "text" && (stickyStack = stickyStack.filter(notCategory(categoryForCode(data))), stickyStack.push({
          token,
          data,
          category: categoryForCode(data)
        })), stickyStack;
      }
      __name(updateStickyStack, "updateStickyStack");
      var Filter = (function() {
        function Filter2(options) {
          _classCallCheck(this, Filter2), options = options || {}, options.colors && (options.colors = Object.assign({}, defaults.colors, options.colors)), this.options = Object.assign({}, defaults, options), this.stack = [], this.stickyStack = [];
        }
        return __name(Filter2, "Filter"), _createClass(Filter2, [{
          key: "toHtml",
          value: __name(function(input) {
            var _this = this;
            input = typeof input == "string" ? [input] : input;
            var stack = this.stack, options = this.options, buf = [];
            return this.stickyStack.forEach(function(element) {
              var output = generateOutput(stack, element.token, element.data, options);
              output && buf.push(output);
            }), tokenize(input.join(""), options, function(token, data) {
              var output = generateOutput(stack, token, data, options);
              output && buf.push(output), options.stream && (_this.stickyStack = updateStickyStack(_this.stickyStack, token, data));
            }), stack.length && buf.push(resetStyles(stack)), buf.join("");
          }, "toHtml")
        }]), Filter2;
      })();
      module.exports = Filter;
    }
  });

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-UTNZYD2N.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-FSBVR7H5.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  function isPlainObject(value2) {
    if (!value2 || typeof value2 != "object")
      return !1;
    let proto = Object.getPrototypeOf(value2);
    return proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null ? Object.prototype.toString.call(value2) === "[object Object]" : !1;
  }
  __name(isPlainObject, "isPlainObject");
  function isPrimitive(value2) {
    return value2 == null || typeof value2 != "object" && typeof value2 != "function";
  }
  __name(isPrimitive, "isPrimitive");
  function isTypedArray(x3) {
    return ArrayBuffer.isView(x3) && !(x3 instanceof DataView);
  }
  __name(isTypedArray, "isTypedArray");
  function getSymbols(object2) {
    return Object.getOwnPropertySymbols(object2).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object2, symbol));
  }
  __name(getSymbols, "getSymbols");
  function getTag(value2) {
    return value2 == null ? value2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value2);
  }
  __name(getTag, "getTag");
  var regexpTag = "[object RegExp]", stringTag = "[object String]", numberTag = "[object Number]", booleanTag = "[object Boolean]", argumentsTag = "[object Arguments]", symbolTag = "[object Symbol]", dateTag = "[object Date]", mapTag = "[object Map]", setTag = "[object Set]", arrayTag = "[object Array]", functionTag = "[object Function]", arrayBufferTag = "[object ArrayBuffer]", objectTag = "[object Object]", errorTag = "[object Error]", dataViewTag = "[object DataView]", uint8ArrayTag = "[object Uint8Array]", uint8ClampedArrayTag = "[object Uint8ClampedArray]", uint16ArrayTag = "[object Uint16Array]", uint32ArrayTag = "[object Uint32Array]", bigUint64ArrayTag = "[object BigUint64Array]", int8ArrayTag = "[object Int8Array]", int16ArrayTag = "[object Int16Array]", int32ArrayTag = "[object Int32Array]", bigInt64ArrayTag = "[object BigInt64Array]", float32ArrayTag = "[object Float32Array]", float64ArrayTag = "[object Float64Array]";

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-UTNZYD2N.js
  init_chunk_MM7DTO55();
  function mapValues(object2, getNewValue) {
    let result = {}, keys = Object.keys(object2);
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], value2 = object2[key];
      result[key] = getNewValue(value2, key, object2);
    }
    return result;
  }
  __name(mapValues, "mapValues");
  function isUnsafeProperty(key) {
    return key === "__proto__";
  }
  __name(isUnsafeProperty, "isUnsafeProperty");
  function isObjectLike(value2) {
    return typeof value2 == "object" && value2 !== null;
  }
  __name(isObjectLike, "isObjectLike");
  function mergeWith(target, source, merge22) {
    let sourceKeys = Object.keys(source);
    for (let i3 = 0; i3 < sourceKeys.length; i3++) {
      let key = sourceKeys[i3];
      if (isUnsafeProperty(key))
        continue;
      let sourceValue = source[key], targetValue = target[key], merged = merge22(targetValue, sourceValue, key, target, source);
      merged !== void 0 ? target[key] = merged : Array.isArray(sourceValue) ? target[key] = mergeWith(targetValue ?? [], sourceValue, merge22) : isObjectLike(targetValue) && isObjectLike(sourceValue) ? target[key] = mergeWith(targetValue ?? {}, sourceValue, merge22) : (targetValue === void 0 || sourceValue !== void 0) && (target[key] = sourceValue);
    }
    return target;
  }
  __name(mergeWith, "mergeWith");
  function pick(obj, keys) {
    let result = {};
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3];
      Object.hasOwn(obj, key) && (result[key] = obj[key]);
    }
    return result;
  }
  __name(pick, "pick");
  function pickBy(obj, shouldPick) {
    let result = {}, keys = Object.keys(obj);
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], value2 = obj[key];
      shouldPick(value2, key) && (result[key] = value2);
    }
    return result;
  }
  __name(pickBy, "pickBy");
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
    let cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
    if (cloned !== void 0)
      return cloned;
    if (isPrimitive(valueToClone))
      return valueToClone;
    if (stack.has(valueToClone))
      return stack.get(valueToClone);
    if (Array.isArray(valueToClone)) {
      let result = new Array(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i3 = 0; i3 < valueToClone.length; i3++)
        result[i3] = cloneDeepWithImpl(valueToClone[i3], i3, objectToClone, stack, cloneValue);
      return Object.hasOwn(valueToClone, "index") && (result.index = valueToClone.index), Object.hasOwn(valueToClone, "input") && (result.input = valueToClone.input), result;
    }
    if (valueToClone instanceof Date)
      return new Date(valueToClone.getTime());
    if (valueToClone instanceof RegExp) {
      let result = new RegExp(valueToClone.source, valueToClone.flags);
      return result.lastIndex = valueToClone.lastIndex, result;
    }
    if (valueToClone instanceof Map) {
      let result = /* @__PURE__ */ new Map();
      stack.set(valueToClone, result);
      for (let [key, value2] of valueToClone)
        result.set(key, cloneDeepWithImpl(value2, key, objectToClone, stack, cloneValue));
      return result;
    }
    if (valueToClone instanceof Set) {
      let result = /* @__PURE__ */ new Set();
      stack.set(valueToClone, result);
      for (let value2 of valueToClone)
        result.add(cloneDeepWithImpl(value2, void 0, objectToClone, stack, cloneValue));
      return result;
    }
    if (typeof Buffer < "u" && Buffer.isBuffer(valueToClone))
      return valueToClone.subarray();
    if (isTypedArray(valueToClone)) {
      let result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i3 = 0; i3 < valueToClone.length; i3++)
        result[i3] = cloneDeepWithImpl(valueToClone[i3], i3, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && valueToClone instanceof SharedArrayBuffer)
      return valueToClone.slice(0);
    if (valueToClone instanceof DataView) {
      let result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (typeof File < "u" && valueToClone instanceof File) {
      let result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (valueToClone instanceof Blob) {
      let result = new Blob([valueToClone], { type: valueToClone.type });
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (valueToClone instanceof Error) {
      let result = new valueToClone.constructor();
      return stack.set(valueToClone, result), result.message = valueToClone.message, result.name = valueToClone.name, result.stack = valueToClone.stack, result.cause = valueToClone.cause, copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    if (typeof valueToClone == "object" && isCloneableObject(valueToClone)) {
      let result = Object.create(Object.getPrototypeOf(valueToClone));
      return stack.set(valueToClone, result), copyProperties(result, valueToClone, objectToClone, stack, cloneValue), result;
    }
    return valueToClone;
  }
  __name(cloneDeepWithImpl, "cloneDeepWithImpl");
  function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
    let keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i3 = 0; i3 < keys.length; i3++) {
      let key = keys[i3], descriptor = Object.getOwnPropertyDescriptor(target, key);
      (descriptor == null || descriptor.writable) && (target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue));
    }
  }
  __name(copyProperties, "copyProperties");
  function isCloneableObject(object2) {
    switch (getTag(object2)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
        return !0;
      default:
        return !1;
    }
  }
  __name(isCloneableObject, "isCloneableObject");
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
  }
  __name(cloneDeep, "cloneDeep");
  function merge(target, source) {
    let sourceKeys = Object.keys(source);
    for (let i3 = 0; i3 < sourceKeys.length; i3++) {
      let key = sourceKeys[i3];
      if (isUnsafeProperty(key))
        continue;
      let sourceValue = source[key], targetValue = target[key];
      Array.isArray(sourceValue) ? Array.isArray(targetValue) ? target[key] = merge(targetValue, sourceValue) : target[key] = merge([], sourceValue) : isPlainObject(sourceValue) ? isPlainObject(targetValue) ? target[key] = merge(targetValue, sourceValue) : target[key] = merge({}, sourceValue) : (targetValue === void 0 || sourceValue !== void 0) && (target[key] = sourceValue);
    }
    return target;
  }
  __name(merge, "merge");
  var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
  function toMerged(target, source) {
    return merge(cloneDeep(target), source);
  }
  __name(toMerged, "toMerged");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-NVV6MIOE.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var require_memoizerific = __commonJS({
    "../node_modules/memoizerific/memoizerific.js"(exports, module) {
      (function(f4) {
        if (typeof exports == "object" && typeof module < "u")
          module.exports = f4();
        else if (typeof define == "function" && define.amd)
          define([], f4);
        else {
          var g3;
          typeof window < "u" || typeof window < "u" ? g3 = window : typeof self < "u" ? g3 = self : g3 = this, g3.memoizerific = f4();
        }
      })(function() {
        var define2, module2, exports2;
        return __name(function e(t, n2, r2) {
          function s4(o22, u3) {
            if (!n2[o22]) {
              if (!t[o22]) {
                var a3 = typeof __require2 == "function" && __require2;
                if (!u3 && a3) return a3(o22, !0);
                if (i3) return i3(o22, !0);
                var f4 = new Error("Cannot find module '" + o22 + "'");
                throw f4.code = "MODULE_NOT_FOUND", f4;
              }
              var l2 = n2[o22] = { exports: {} };
              t[o22][0].call(l2.exports, function(e2) {
                var n22 = t[o22][1][e2];
                return s4(n22 || e2);
              }, l2, l2.exports, e, t, n2, r2);
            }
            return n2[o22].exports;
          }
          __name(s4, "s");
          for (var i3 = typeof __require2 == "function" && __require2, o2 = 0; o2 < r2.length; o2++) s4(r2[o2]);
          return s4;
        }, "e")({ 1: [function(_dereq_, module3, exports3) {
          module3.exports = function(forceSimilar) {
            if (typeof Map != "function" || forceSimilar) {
              var Similar = _dereq_("./similar");
              return new Similar();
            } else
              return /* @__PURE__ */ new Map();
          };
        }, { "./similar": 2 }], 2: [function(_dereq_, module3, exports3) {
          function Similar() {
            return this.list = [], this.lastItem = void 0, this.size = 0, this;
          }
          __name(Similar, "Similar"), Similar.prototype.get = function(key) {
            var index2;
            if (this.lastItem && this.isEqual(this.lastItem.key, key))
              return this.lastItem.val;
            if (index2 = this.indexOf(key), index2 >= 0)
              return this.lastItem = this.list[index2], this.list[index2].val;
          }, Similar.prototype.set = function(key, val) {
            var index2;
            return this.lastItem && this.isEqual(this.lastItem.key, key) ? (this.lastItem.val = val, this) : (index2 = this.indexOf(key), index2 >= 0 ? (this.lastItem = this.list[index2], this.list[index2].val = val, this) : (this.lastItem = { key, val }, this.list.push(this.lastItem), this.size++, this));
          }, Similar.prototype.delete = function(key) {
            var index2;
            if (this.lastItem && this.isEqual(this.lastItem.key, key) && (this.lastItem = void 0), index2 = this.indexOf(key), index2 >= 0)
              return this.size--, this.list.splice(index2, 1)[0];
          }, Similar.prototype.has = function(key) {
            var index2;
            return this.lastItem && this.isEqual(this.lastItem.key, key) ? !0 : (index2 = this.indexOf(key), index2 >= 0 ? (this.lastItem = this.list[index2], !0) : !1);
          }, Similar.prototype.forEach = function(callback, thisArg) {
            var i3;
            for (i3 = 0; i3 < this.size; i3++)
              callback.call(thisArg || this, this.list[i3].val, this.list[i3].key, this);
          }, Similar.prototype.indexOf = function(key) {
            var i3;
            for (i3 = 0; i3 < this.size; i3++)
              if (this.isEqual(this.list[i3].key, key))
                return i3;
            return -1;
          }, Similar.prototype.isEqual = function(val1, val2) {
            return val1 === val2 || val1 !== val1 && val2 !== val2;
          }, module3.exports = Similar;
        }, {}], 3: [function(_dereq_, module3, exports3) {
          var MapOrSimilar = _dereq_("map-or-similar");
          module3.exports = function(limit) {
            var cache = new MapOrSimilar(!1), lru = [];
            return function(fn2) {
              var memoizerific = __name(function() {
                var currentCache = cache, newMap, fnResult, argsLengthMinusOne = arguments.length - 1, lruPath = Array(argsLengthMinusOne + 1), isMemoized = !0, i3;
                if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1)
                  throw new Error("Memoizerific functions should always be called with the same number of arguments");
                for (i3 = 0; i3 < argsLengthMinusOne; i3++) {
                  if (lruPath[i3] = {
                    cacheItem: currentCache,
                    arg: arguments[i3]
                  }, currentCache.has(arguments[i3])) {
                    currentCache = currentCache.get(arguments[i3]);
                    continue;
                  }
                  isMemoized = !1, newMap = new MapOrSimilar(!1), currentCache.set(arguments[i3], newMap), currentCache = newMap;
                }
                return isMemoized && (currentCache.has(arguments[argsLengthMinusOne]) ? fnResult = currentCache.get(arguments[argsLengthMinusOne]) : isMemoized = !1), isMemoized || (fnResult = fn2.apply(null, arguments), currentCache.set(arguments[argsLengthMinusOne], fnResult)), limit > 0 && (lruPath[argsLengthMinusOne] = {
                  cacheItem: currentCache,
                  arg: arguments[argsLengthMinusOne]
                }, isMemoized ? moveToMostRecentLru(lru, lruPath) : lru.push(lruPath), lru.length > limit && removeCachedResult(lru.shift())), memoizerific.wasMemoized = isMemoized, memoizerific.numArgs = argsLengthMinusOne + 1, fnResult;
              }, "memoizerific");
              return memoizerific.limit = limit, memoizerific.wasMemoized = !1, memoizerific.cache = cache, memoizerific.lru = lru, memoizerific;
            };
          };
          function moveToMostRecentLru(lru, lruPath) {
            var lruLen = lru.length, lruPathLen = lruPath.length, isMatch, i3, ii;
            for (i3 = 0; i3 < lruLen; i3++) {
              for (isMatch = !0, ii = 0; ii < lruPathLen; ii++)
                if (!isEqual2(lru[i3][ii].arg, lruPath[ii].arg)) {
                  isMatch = !1;
                  break;
                }
              if (isMatch)
                break;
            }
            lru.push(lru.splice(i3, 1)[0]);
          }
          __name(moveToMostRecentLru, "moveToMostRecentLru");
          function removeCachedResult(removedLru) {
            var removedLruLen = removedLru.length, currentLru = removedLru[removedLruLen - 1], tmp, i3;
            for (currentLru.cacheItem.delete(currentLru.arg), i3 = removedLruLen - 2; i3 >= 0 && (currentLru = removedLru[i3], tmp = currentLru.cacheItem.get(currentLru.arg), !tmp || !tmp.size); i3--)
              currentLru.cacheItem.delete(currentLru.arg);
          }
          __name(removeCachedResult, "removeCachedResult");
          function isEqual2(val1, val2) {
            return val1 === val2 || val1 !== val1 && val2 !== val2;
          }
          __name(isEqual2, "isEqual");
        }, { "map-or-similar": 1 }] }, {}, [3])(3);
      });
    }
  });

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-XW6KSYKF.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var PARAM_KEY4 = "actions", ADDON_ID4 = "storybook/actions", PANEL_ID = `${ADDON_ID4}/panel`, EVENT_ID = `${ADDON_ID4}/action-event`, CLEAR_ID = `${ADDON_ID4}/action-clear`;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-TMDZCWME.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var MINIMAL_VIEWPORTS = {
    mobile1: {
      name: "Small mobile",
      styles: {
        height: "568px",
        width: "320px"
      },
      type: "mobile"
    },
    mobile2: {
      name: "Large mobile",
      styles: {
        height: "896px",
        width: "414px"
      },
      type: "mobile"
    },
    tablet: {
      name: "Tablet",
      styles: {
        height: "1112px",
        width: "834px"
      },
      type: "tablet"
    },
    desktop: {
      name: "Desktop",
      styles: {
        height: "1024px",
        width: "1280px"
      },
      type: "desktop"
    }
  }, responsiveViewport = {
    name: "Reset viewport",
    styles: {
      height: "100%",
      width: "100%"
    },
    type: "desktop"
  };

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-HHW4FUMO.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID5 = "storybook/viewport", PARAM_KEY5 = "viewport", PANEL_ID2 = `${ADDON_ID5}/panel`, TOOL_ID2 = `${ADDON_ID5}/tool`;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/core-server/presets/common-manager.js
  init_chunk_MM7DTO55();

  // node_modules/.pnpm/@storybook+global@5.0.0/node_modules/@storybook/global/dist/index.mjs
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var scope = (() => {
    let win;
    return typeof window < "u" ? win = window : typeof globalThis < "u" ? win = globalThis : typeof window < "u" ? win = window : typeof self < "u" ? win = self : win = {}, win;
  })();

  // global-externals:storybook/manager-api
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var manager_api_default = __STORYBOOK_API__, { ActiveTabs, Consumer, ManagerContext, Provider, RequestResponseError, addons, combineParameters, controlOrMetaKey, controlOrMetaSymbol, eventMatchesShortcut, eventToShortcut, experimental_MockUniversalStore, experimental_UniversalStore, experimental_getStatusStore, experimental_getTestProviderStore, experimental_requestResponse, experimental_useStatusStore, experimental_useTestProviderStore, experimental_useUniversalStore, internal_fullStatusStore, internal_fullTestProviderStore, internal_universalStatusStore, internal_universalTestProviderStore, isMacLike, isShortcutTaken, keyToSymbol, merge: merge2, mockChannel, optionOrAltSymbol, shortcutMatchesShortcut, shortcutToHumanString, types, useAddonState, useArgTypes, useArgs, useChannel, useGlobalTypes, useGlobals, useParameter, useSharedState, useStoryPrepared, useStorybookApi, useStorybookState } = __STORYBOOK_API__;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/core-server/presets/common-manager.js
  init_react();
  init_components();

  // global-externals:storybook/internal/core-events
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var core_events_default = __STORYBOOK_CORE_EVENTS__, { ARGTYPES_INFO_REQUEST, ARGTYPES_INFO_RESPONSE, CHANNEL_CREATED, CHANNEL_WS_DISCONNECT, CONFIG_ERROR, CREATE_NEW_STORYFILE_REQUEST, CREATE_NEW_STORYFILE_RESPONSE, CURRENT_STORY_WAS_SET, DOCS_PREPARED, DOCS_RENDERED, FILE_COMPONENT_SEARCH_REQUEST, FILE_COMPONENT_SEARCH_RESPONSE, FORCE_REMOUNT, FORCE_RE_RENDER, GLOBALS_UPDATED, NAVIGATE_URL, OPEN_IN_EDITOR_REQUEST, OPEN_IN_EDITOR_RESPONSE, PLAY_FUNCTION_THREW_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_BUILDER_PROGRESS, PREVIEW_INITIALIZED, PREVIEW_KEYDOWN, REGISTER_SUBSCRIPTION, REQUEST_WHATS_NEW_DATA, RESET_STORY_ARGS, RESULT_WHATS_NEW_DATA, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, SELECT_STORY, SET_CONFIG, SET_CURRENT_STORY, SET_FILTER, SET_GLOBALS, SET_INDEX, SET_STORIES, SET_WHATS_NEW_CACHE, SHARED_STATE_CHANGED, SHARED_STATE_SET, STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_FINISHED, STORY_HOT_UPDATED, STORY_INDEX_INVALIDATED, STORY_MISSING, STORY_PREPARED, STORY_RENDERED, STORY_RENDER_PHASE_CHANGED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, TELEMETRY_ERROR, TOGGLE_WHATS_NEW_NOTIFICATIONS, UNHANDLED_ERRORS_WHILE_PLAYING, UPDATE_GLOBALS, UPDATE_QUERY_PARAMS, UPDATE_STORY_ARGS } = __STORYBOOK_CORE_EVENTS__;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/core-server/presets/common-manager.js
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();

  // global-externals:storybook/internal/client-logger
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var client_logger_default = __STORYBOOK_CLIENT_LOGGER__, { deprecate, logger, once, pretty } = __STORYBOOK_CLIENT_LOGGER__;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/core-server/presets/common-manager.js
  init_components();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/csf/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-RW5PKMWM.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-LYCSRYYR.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var ANIMATION_TIMEOUT = 5e3;
  function isTestEnvironment() {
    try {
      return (
        // @ts-expect-error This property exists in Vitest browser mode
        !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
      );
    } catch {
      return !1;
    }
  }
  __name(isTestEnvironment, "isTestEnvironment");
  function pauseAnimations(atEnd = !0) {
    if (!("document" in globalThis && "createElement" in globalThis.document))
      return () => {
      };
    let disableStyle = document.createElement("style");
    disableStyle.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(disableStyle);
    let pauseStyle = document.createElement("style");
    return pauseStyle.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${atEnd ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(pauseStyle), document.body.clientHeight, document.head.removeChild(disableStyle), () => {
      pauseStyle.parentNode?.removeChild(pauseStyle);
    };
  }
  __name(pauseAnimations, "pauseAnimations");
  async function waitForAnimations(signal) {
    if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
      return;
    let timedOut = !1;
    await Promise.race([
      // After 50ms, retrieve any running animations and wait for them to finish
      // If new animations are created while waiting, we'll wait for them too
      new Promise((resolve) => {
        setTimeout(() => {
          let animationRoots = [globalThis.document, ...getShadowRoots(globalThis.document)], checkAnimationsFinished = __name(async () => {
            if (timedOut || signal?.aborted)
              return;
            let runningAnimations = animationRoots.flatMap((el) => el?.getAnimations?.() || []).filter((a3) => a3.playState === "running" && !isInfiniteAnimation(a3));
            runningAnimations.length > 0 && (await Promise.all(runningAnimations.map((a3) => a3.finished)), await checkAnimationsFinished());
          }, "checkAnimationsFinished");
          checkAnimationsFinished().then(resolve);
        }, 100);
      }),
      // If animations don't finish within the timeout, continue without waiting
      new Promise(
        (resolve) => setTimeout(() => {
          timedOut = !0, resolve(void 0);
        }, ANIMATION_TIMEOUT)
      )
    ]);
  }
  __name(waitForAnimations, "waitForAnimations");
  function getShadowRoots(doc) {
    return [doc, ...doc.querySelectorAll("*")].reduce((acc, el) => ("shadowRoot" in el && el.shadowRoot && acc.push(el.shadowRoot, ...getShadowRoots(el.shadowRoot)), acc), []);
  }
  __name(getShadowRoots, "getShadowRoots");
  function isInfiniteAnimation(anim) {
    if (anim instanceof CSSAnimation && anim.effect instanceof KeyframeEffect && anim.effect.target) {
      let style = getComputedStyle(anim.effect.target, anim.effect.pseudoElement), index2 = style.animationName?.split(", ").indexOf(anim.animationName);
      return style.animationIterationCount.split(", ")[index2] === "infinite";
    }
    return !1;
  }
  __name(isInfiniteAnimation, "isInfiniteAnimation");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-Y3M7TW6K.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var require_string_util = __commonJS({
    "../node_modules/picoquery/lib/string-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.encodeString = encodeString;
      var hexTable = Array.from({ length: 256 }, (_3, i3) => "%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase()), noEscape = new Int8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        0
      ]);
      function encodeString(str2) {
        let len = str2.length;
        if (len === 0)
          return "";
        let out = "", lastPos = 0, i3 = 0;
        outer: for (; i3 < len; i3++) {
          let c3 = str2.charCodeAt(i3);
          for (; c3 < 128; ) {
            if (noEscape[c3] !== 1 && (lastPos < i3 && (out += str2.slice(lastPos, i3)), lastPos = i3 + 1, out += hexTable[c3]), ++i3 === len)
              break outer;
            c3 = str2.charCodeAt(i3);
          }
          if (lastPos < i3 && (out += str2.slice(lastPos, i3)), c3 < 2048) {
            lastPos = i3 + 1, out += hexTable[192 | c3 >> 6] + hexTable[128 | c3 & 63];
            continue;
          }
          if (c3 < 55296 || c3 >= 57344) {
            lastPos = i3 + 1, out += hexTable[224 | c3 >> 12] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63];
            continue;
          }
          if (++i3, i3 >= len)
            throw new Error("URI malformed");
          let c22 = str2.charCodeAt(i3) & 1023;
          lastPos = i3 + 1, c3 = 65536 + ((c3 & 1023) << 10 | c22), out += hexTable[240 | c3 >> 18] + hexTable[128 | c3 >> 12 & 63] + hexTable[128 | c3 >> 6 & 63] + hexTable[128 | c3 & 63];
        }
        return lastPos === 0 ? str2 : lastPos < len ? out + str2.slice(lastPos) : out;
      }
      __name(encodeString, "encodeString");
    }
  }), require_shared = __commonJS({
    "../node_modules/picoquery/lib/shared.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.defaultOptions = exports.defaultShouldSerializeObject = exports.defaultValueSerializer = void 0;
      var string_util_js_1 = require_string_util(), defaultValueSerializer = __name((value2) => {
        switch (typeof value2) {
          case "string":
            return (0, string_util_js_1.encodeString)(value2);
          case "bigint":
          case "boolean":
            return "" + value2;
          case "number":
            if (Number.isFinite(value2))
              return value2 < 1e21 ? "" + value2 : (0, string_util_js_1.encodeString)("" + value2);
            break;
        }
        return value2 instanceof Date ? (0, string_util_js_1.encodeString)(value2.toISOString()) : "";
      }, "defaultValueSerializer");
      exports.defaultValueSerializer = defaultValueSerializer;
      var defaultShouldSerializeObject = __name((val) => val instanceof Date, "defaultShouldSerializeObject");
      exports.defaultShouldSerializeObject = defaultShouldSerializeObject;
      var identityFunc = __name((v3) => v3, "identityFunc");
      exports.defaultOptions = {
        nesting: !0,
        nestingSyntax: "dot",
        arrayRepeat: !1,
        arrayRepeatSyntax: "repeat",
        delimiter: 38,
        valueDeserializer: identityFunc,
        valueSerializer: exports.defaultValueSerializer,
        keyDeserializer: identityFunc,
        shouldSerializeObject: exports.defaultShouldSerializeObject
      };
    }
  }), require_object_util = __commonJS({
    "../node_modules/picoquery/lib/object-util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.getDeepObject = getDeepObject, exports.stringifyObject = stringifyObject;
      var shared_js_1 = require_shared(), string_util_js_1 = require_string_util();
      function isPrototypeKey(value2) {
        return value2 === "__proto__" || value2 === "constructor" || value2 === "prototype";
      }
      __name(isPrototypeKey, "isPrototypeKey");
      function getDeepObject(obj, key, nextKey, forceObject, forceArray) {
        if (isPrototypeKey(key))
          return obj;
        let currObj = obj[key];
        return typeof currObj == "object" && currObj !== null ? currObj : !forceObject && (forceArray || typeof nextKey == "number" || typeof nextKey == "string" && nextKey * 0 === 0 && nextKey.indexOf(".") === -1) ? obj[key] = [] : obj[key] = {};
      }
      __name(getDeepObject, "getDeepObject");
      var MAX_DEPTH = 20, strBracketPair = "[]", strBracketLeft = "[", strBracketRight = "]", strDot = ".";
      function stringifyObject(obj, options, depth = 0, parentKey, isProbableArray) {
        let { nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, delimiter = shared_js_1.defaultOptions.delimiter, valueSerializer = shared_js_1.defaultOptions.valueSerializer, shouldSerializeObject = shared_js_1.defaultOptions.shouldSerializeObject } = options, strDelimiter = typeof delimiter == "number" ? String.fromCharCode(delimiter) : delimiter, useArrayRepeatKey = isProbableArray === !0 && arrayRepeat, shouldUseDot = nestingSyntax === "dot" || nestingSyntax === "js" && !isProbableArray;
        if (depth > MAX_DEPTH)
          return "";
        let result = "", firstKey = !0, valueIsProbableArray = !1;
        for (let key in obj) {
          let value2 = obj[key];
          if (value2 === void 0)
            continue;
          let path;
          parentKey ? (path = parentKey, useArrayRepeatKey ? arrayRepeatSyntax === "bracket" && (path += strBracketPair) : shouldUseDot ? (path += strDot, path += key) : (path += strBracketLeft, path += key, path += strBracketRight)) : path = key, firstKey || (result += strDelimiter), typeof value2 == "object" && value2 !== null && !shouldSerializeObject(value2) ? (valueIsProbableArray = value2.pop !== void 0, (nesting || arrayRepeat && valueIsProbableArray) && (result += stringifyObject(value2, options, depth + 1, path, valueIsProbableArray))) : (result += (0, string_util_js_1.encodeString)(path), result += "=", result += valueSerializer(value2, key)), firstKey && (firstKey = !1);
        }
        return result;
      }
      __name(stringifyObject, "stringifyObject");
    }
  }), require_decode_uri_component = __commonJS({
    "../node_modules/picoquery/lib/decode-uri-component.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.decodeURIComponent = decodeURIComponent2;
      var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [
        // The first part of the table maps bytes to character to a transition.
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        // The second part of the table maps a state to a new state when adding a
        // transition.
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // The third part maps the current transition to a mask that needs to apply
        // to the byte.
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ];
      function decodeURIComponent2(uri) {
        let percentPosition = uri.indexOf("%");
        if (percentPosition === -1)
          return uri;
        let length2 = uri.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state3 = UTF8_ACCEPT;
        for (; percentPosition > -1 && percentPosition < length2; ) {
          let high = hexCodeToInt(uri[percentPosition + 1], 4), low = hexCodeToInt(uri[percentPosition + 2], 0), byte = high | low, type = UTF8_DATA[byte];
          if (state3 = UTF8_DATA[256 + state3 + type], codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type], state3 === UTF8_ACCEPT)
            decoded += uri.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri.indexOf("%", last);
          else {
            if (state3 === UTF8_REJECT)
              return null;
            if (percentPosition += 3, percentPosition < length2 && uri.charCodeAt(percentPosition) === 37)
              continue;
            return null;
          }
        }
        return decoded + uri.slice(last);
      }
      __name(decodeURIComponent2, "decodeURIComponent");
      var HEX = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      };
      function hexCodeToInt(c3, shift) {
        let i3 = HEX[c3];
        return i3 === void 0 ? 255 : i3 << shift;
      }
      __name(hexCodeToInt, "hexCodeToInt");
    }
  }), require_parse = __commonJS({
    "../node_modules/picoquery/lib/parse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.numberValueDeserializer = exports.numberKeyDeserializer = void 0, exports.parse = parse5;
      var object_util_js_1 = require_object_util(), shared_js_1 = require_shared(), decode_uri_component_js_1 = require_decode_uri_component(), numberKeyDeserializer = __name((key) => {
        let asNumber = Number(key);
        return Number.isNaN(asNumber) ? key : asNumber;
      }, "numberKeyDeserializer");
      exports.numberKeyDeserializer = numberKeyDeserializer;
      var numberValueDeserializer = __name((value2) => {
        let asNumber = Number(value2);
        return Number.isNaN(asNumber) ? value2 : asNumber;
      }, "numberValueDeserializer");
      exports.numberValueDeserializer = numberValueDeserializer;
      var regexPlus = /\+/g, Empty3 = __name(function() {
      }, "Empty");
      Empty3.prototype = /* @__PURE__ */ Object.create(null);
      function computeKeySlice(input, startIndex, endIndex, keyHasPlus, shouldDecodeKey) {
        let chunk = input.substring(startIndex, endIndex);
        return keyHasPlus && (chunk = chunk.replace(regexPlus, " ")), shouldDecodeKey && (chunk = (0, decode_uri_component_js_1.decodeURIComponent)(chunk) || chunk), chunk;
      }
      __name(computeKeySlice, "computeKeySlice");
      function parse5(input, options) {
        let { valueDeserializer = shared_js_1.defaultOptions.valueDeserializer, keyDeserializer = shared_js_1.defaultOptions.keyDeserializer, arrayRepeatSyntax = shared_js_1.defaultOptions.arrayRepeatSyntax, nesting = shared_js_1.defaultOptions.nesting, arrayRepeat = shared_js_1.defaultOptions.arrayRepeat, nestingSyntax = shared_js_1.defaultOptions.nestingSyntax, delimiter = shared_js_1.defaultOptions.delimiter } = options ?? {}, charDelimiter = typeof delimiter == "string" ? delimiter.charCodeAt(0) : delimiter, isJsNestingSyntax = nestingSyntax === "js", result = new Empty3();
        if (typeof input != "string")
          return result;
        let inputLength = input.length, value2 = "", startingIndex = -1, equalityIndex = -1, keySeparatorIndex = -1, currentObj = result, lastKey, currentKey = "", keyChunk = "", shouldDecodeKey = !1, shouldDecodeValue = !1, keyHasPlus = !1, valueHasPlus = !1, keyIsDot = !1, hasBothKeyValuePair = !1, c3 = 0, arrayRepeatBracketIndex = -1, prevIndex = -1, prevChar = -1;
        for (let i3 = 0; i3 < inputLength + 1; i3++) {
          if (c3 = i3 !== inputLength ? input.charCodeAt(i3) : charDelimiter, c3 === charDelimiter) {
            if (hasBothKeyValuePair = equalityIndex > startingIndex, hasBothKeyValuePair || (equalityIndex = i3), keySeparatorIndex !== equalityIndex - 1 && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, arrayRepeatBracketIndex > -1 ? arrayRepeatBracketIndex : equalityIndex, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax && keyIsDot, void 0))), hasBothKeyValuePair || currentKey !== "") {
              hasBothKeyValuePair && (value2 = input.slice(equalityIndex + 1, i3), valueHasPlus && (value2 = value2.replace(regexPlus, " ")), shouldDecodeValue && (value2 = (0, decode_uri_component_js_1.decodeURIComponent)(value2) || value2));
              let newValue = valueDeserializer(value2, currentKey);
              if (arrayRepeat) {
                let currentValue = currentObj[currentKey];
                currentValue === void 0 ? arrayRepeatBracketIndex > -1 ? currentObj[currentKey] = [newValue] : currentObj[currentKey] = newValue : currentValue.pop ? currentValue.push(newValue) : currentObj[currentKey] = [currentValue, newValue];
              } else
                currentObj[currentKey] = newValue;
            }
            value2 = "", startingIndex = i3, equalityIndex = i3, shouldDecodeKey = !1, shouldDecodeValue = !1, keyHasPlus = !1, valueHasPlus = !1, keyIsDot = !1, arrayRepeatBracketIndex = -1, keySeparatorIndex = i3, currentObj = result, lastKey = void 0, currentKey = "";
          } else c3 === 93 ? (arrayRepeat && arrayRepeatSyntax === "bracket" && prevChar === 91 && (arrayRepeatBracketIndex = prevIndex), nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, void 0, void 0)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1), keySeparatorIndex = i3, keyIsDot = !1)) : c3 === 46 ? nesting && (nestingSyntax === "dot" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1), keyIsDot = !0, keySeparatorIndex = i3) : c3 === 91 ? nesting && (nestingSyntax === "index" || isJsNestingSyntax) && equalityIndex <= startingIndex && (keySeparatorIndex !== prevIndex && (keyChunk = computeKeySlice(input, keySeparatorIndex + 1, i3, keyHasPlus, shouldDecodeKey), currentKey = keyDeserializer(keyChunk), isJsNestingSyntax && lastKey !== void 0 && (currentObj = (0, object_util_js_1.getDeepObject)(currentObj, lastKey, currentKey, isJsNestingSyntax)), lastKey = currentKey, keyHasPlus = !1, shouldDecodeKey = !1, keyIsDot = !1), keySeparatorIndex = i3) : c3 === 61 ? equalityIndex <= startingIndex ? equalityIndex = i3 : shouldDecodeValue = !0 : c3 === 43 ? equalityIndex > startingIndex ? valueHasPlus = !0 : keyHasPlus = !0 : c3 === 37 && (equalityIndex > startingIndex ? shouldDecodeValue = !0 : shouldDecodeKey = !0);
          prevIndex = i3, prevChar = c3;
        }
        return result;
      }
      __name(parse5, "parse");
    }
  }), require_stringify = __commonJS({
    "../node_modules/picoquery/lib/stringify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.stringify = stringify4;
      var object_util_js_1 = require_object_util();
      function stringify4(input, options) {
        if (input === null || typeof input != "object")
          return "";
        let optionsObj = options ?? {};
        return (0, object_util_js_1.stringifyObject)(input, optionsObj);
      }
      __name(stringify4, "stringify");
    }
  }), require_main = __commonJS({
    "../node_modules/picoquery/lib/main.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k3, k22) {
        k22 === void 0 && (k22 = k3);
        var desc = Object.getOwnPropertyDescriptor(m3, k3);
        (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: __name(function() {
          return m3[k3];
        }, "get") }), Object.defineProperty(o2, k22, desc);
      } : function(o2, m3, k3, k22) {
        k22 === void 0 && (k22 = k3), o2[k22] = m3[k3];
      }), __exportStar = exports && exports.__exportStar || function(m3, exports2) {
        for (var p4 in m3) p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4) && __createBinding(exports2, m3, p4);
      };
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.stringify = exports.parse = void 0;
      var parse_js_1 = require_parse();
      Object.defineProperty(exports, "parse", { enumerable: !0, get: __name(function() {
        return parse_js_1.parse;
      }, "get") });
      var stringify_js_1 = require_stringify();
      Object.defineProperty(exports, "stringify", { enumerable: !0, get: __name(function() {
        return stringify_js_1.stringify;
      }, "get") }), __exportStar(require_shared(), exports);
    }
  });

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-B4A3ADP3.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/preview-errors.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-FDWKXLBI.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-LASUB7TL.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  function parseErrorCode({
    code,
    category
  }) {
    let paddedCode = String(code).padStart(4, "0");
    return `SB_${category}_${paddedCode}`;
  }
  __name(parseErrorCode, "parseErrorCode");
  function appendErrorRef(url) {
    if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(url))
      return url;
    try {
      let urlObj = new URL(url);
      return urlObj.searchParams.set("ref", "error"), urlObj.toString();
    } catch {
      return url;
    }
  }
  __name(appendErrorRef, "appendErrorRef");
  var _StorybookError = class _StorybookError2 extends Error {
    constructor(props) {
      super(_StorybookError2.getFullMessage(props)), this.data = {}, this.fromStorybook = !0, this.category = props.category, this.documentation = props.documentation ?? !1, this.code = props.code;
    }
    get fullErrorCode() {
      return parseErrorCode({ code: this.code, category: this.category });
    }
    /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
    get name() {
      let errorName = this.constructor.name;
      return `${this.fullErrorCode} (${errorName})`;
    }
    /** Generates the error message along with additional documentation link (if applicable). */
    static getFullMessage({
      documentation,
      code,
      category,
      message
    }) {
      let page;
      return documentation === !0 ? page = `https://storybook.js.org/error/${parseErrorCode({ code, category })}?ref=error` : typeof documentation == "string" ? page = appendErrorRef(documentation) : Array.isArray(documentation) && (page = `
${documentation.map((doc) => `	- ${appendErrorRef(doc)}`).join(`
`)}`), `${message}${page != null ? `

More info: ${page}
` : ""}`;
    }
  };
  __name(_StorybookError, "StorybookError");
  var StorybookError = _StorybookError;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-OPCDBBL3.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  function dedent(templ) {
    for (var values = [], _i = 1; _i < arguments.length; _i++)
      values[_i - 1] = arguments[_i];
    var strings = Array.from(typeof templ == "string" ? [templ] : templ);
    strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var indentLengths = strings.reduce(function(arr, str2) {
      var matches3 = str2.match(/\n([\t ]+|(?!\s).)/g);
      return matches3 ? arr.concat(matches3.map(function(match) {
        var _a, _b;
        return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      })) : arr;
    }, []);
    if (indentLengths.length) {
      var pattern_1 = new RegExp(`
[	 ]{` + Math.min.apply(Math, indentLengths) + "}", "g");
      strings = strings.map(function(str2) {
        return str2.replace(pattern_1, `
`);
      });
    }
    strings[0] = strings[0].replace(/^\r?\n/, "");
    var string = strings[0];
    return values.forEach(function(value2, i3) {
      var endentations = string.match(/(?:^|\n)( *)$/), endentation = endentations ? endentations[1] : "", indentedValue = value2;
      typeof value2 == "string" && value2.includes(`
`) && (indentedValue = String(value2).split(`
`).map(function(str2, i22) {
        return i22 === 0 ? str2 : "" + endentation + str2;
      }).join(`
`)), string += indentedValue + strings[i3 + 1];
    }), string;
  }
  __name(dedent, "dedent");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-FDWKXLBI.js
  init_chunk_MM7DTO55();
  var Category = ((Category2) => (Category2.BLOCKS = "BLOCKS", Category2.DOCS_TOOLS = "DOCS-TOOLS", Category2.PREVIEW_CLIENT_LOGGER = "PREVIEW_CLIENT-LOGGER", Category2.PREVIEW_CHANNELS = "PREVIEW_CHANNELS", Category2.PREVIEW_CORE_EVENTS = "PREVIEW_CORE-EVENTS", Category2.PREVIEW_INSTRUMENTER = "PREVIEW_INSTRUMENTER", Category2.PREVIEW_API = "PREVIEW_API", Category2.PREVIEW_REACT_DOM_SHIM = "PREVIEW_REACT-DOM-SHIM", Category2.PREVIEW_ROUTER = "PREVIEW_ROUTER", Category2.PREVIEW_THEMING = "PREVIEW_THEMING", Category2.RENDERER_HTML = "RENDERER_HTML", Category2.RENDERER_PREACT = "RENDERER_PREACT", Category2.RENDERER_REACT = "RENDERER_REACT", Category2.RENDERER_SERVER = "RENDERER_SERVER", Category2.RENDERER_SVELTE = "RENDERER_SVELTE", Category2.RENDERER_VUE = "RENDERER_VUE", Category2.RENDERER_VUE3 = "RENDERER_VUE3", Category2.RENDERER_WEB_COMPONENTS = "RENDERER_WEB-COMPONENTS", Category2.FRAMEWORK_NEXTJS = "FRAMEWORK_NEXTJS", Category2.ADDON_VITEST = "ADDON_VITEST", Category2.ADDON_A11Y = "ADDON_A11Y", Category2))(Category || {}), _MissingStoryAfterHmrError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 1,
        message: dedent`
        Couldn't find story matching id '${data.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${data.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
      }), this.data = data;
    }
  };
  __name(_MissingStoryAfterHmrError, "MissingStoryAfterHmrError");
  var MissingStoryAfterHmrError = _MissingStoryAfterHmrError, _ImplicitActionsDuringRendering = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 2,
        documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
        message: dedent`
        We detected that you use an implicit action arg while ${data.phase} of your story.  
        ${data.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${data.name}: fn()
          }`
      }), this.data = data;
    }
  };
  __name(_ImplicitActionsDuringRendering, "ImplicitActionsDuringRendering");
  var ImplicitActionsDuringRendering = _ImplicitActionsDuringRendering, _CalledExtractOnStoreError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 3,
        message: dedent`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
      });
    }
  };
  __name(_CalledExtractOnStoreError, "CalledExtractOnStoreError");
  var CalledExtractOnStoreError = _CalledExtractOnStoreError, _MissingRenderToCanvasError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 4,
        message: dedent`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
        documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
      });
    }
  };
  __name(_MissingRenderToCanvasError, "MissingRenderToCanvasError");
  var MissingRenderToCanvasError = _MissingRenderToCanvasError, _CalledPreviewMethodBeforeInitializationError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 5,
        message: dedent`
        Called \`Preview.${data.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${data.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
      }), this.data = data;
    }
  };
  __name(_CalledPreviewMethodBeforeInitializationError, "CalledPreviewMethodBeforeInitializationError");
  var CalledPreviewMethodBeforeInitializationError = _CalledPreviewMethodBeforeInitializationError, _StoryIndexFetchError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 6,
        message: dedent`
        Error fetching \`/index.json\`:
        
        ${data.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
      }), this.data = data;
    }
  };
  __name(_StoryIndexFetchError, "StoryIndexFetchError");
  var StoryIndexFetchError = _StoryIndexFetchError, _MdxFileWithNoCsfReferencesError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 7,
        message: dedent`
        Tried to render docs entry ${data.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
      }), this.data = data;
    }
  };
  __name(_MdxFileWithNoCsfReferencesError, "MdxFileWithNoCsfReferencesError");
  var MdxFileWithNoCsfReferencesError = _MdxFileWithNoCsfReferencesError, _EmptyIndexError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 8,
        message: dedent`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
      });
    }
  };
  __name(_EmptyIndexError, "EmptyIndexError");
  var EmptyIndexError = _EmptyIndexError, _NoStoryMatchError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 9,
        message: dedent`
        Couldn't find story matching '${data.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
      }), this.data = data;
    }
  };
  __name(_NoStoryMatchError, "NoStoryMatchError");
  var NoStoryMatchError = _NoStoryMatchError, _MissingStoryFromCsfFileError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 10,
        message: dedent`
        Couldn't find story matching id '${data.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
      }), this.data = data;
    }
  };
  __name(_MissingStoryFromCsfFileError, "MissingStoryFromCsfFileError");
  var MissingStoryFromCsfFileError = _MissingStoryFromCsfFileError, _StoryStoreAccessedBeforeInitializationError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 11,
        message: dedent`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
      });
    }
  };
  __name(_StoryStoreAccessedBeforeInitializationError, "StoryStoreAccessedBeforeInitializationError");
  var StoryStoreAccessedBeforeInitializationError = _StoryStoreAccessedBeforeInitializationError, _MountMustBeDestructuredError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 12,
        message: dedent`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${data.playFunction}`
      }), this.data = data;
    }
  };
  __name(_MountMustBeDestructuredError, "MountMustBeDestructuredError");
  var MountMustBeDestructuredError = _MountMustBeDestructuredError, _NoRenderFunctionError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 14,
        message: dedent`
        No render function available for storyId '${data.id}'
      `
      }), this.data = data;
    }
  };
  __name(_NoRenderFunctionError, "NoRenderFunctionError");
  var NoRenderFunctionError = _NoRenderFunctionError, _NoStoryMountedError = class extends StorybookError {
    constructor() {
      super({
        category: "PREVIEW_API",
        code: 15,
        message: dedent`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
      });
    }
  };
  __name(_NoStoryMountedError, "NoStoryMountedError");
  var NoStoryMountedError = _NoStoryMountedError, _StatusTypeIdMismatchError = class extends StorybookError {
    constructor(data) {
      super({
        category: "PREVIEW_API",
        code: 16,
        message: `Status has typeId "${data.status.typeId}" but was added to store with typeId "${data.typeId}". Full status: ${JSON.stringify(
          data.status,
          null,
          2
        )}`
      }), this.data = data;
    }
  };
  __name(_StatusTypeIdMismatchError, "StatusTypeIdMismatchError");
  var _NextJsSharpError = class extends StorybookError {
    constructor() {
      super({
        category: "FRAMEWORK_NEXTJS",
        code: 1,
        documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
        message: dedent`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
      });
    }
  };
  __name(_NextJsSharpError, "NextJsSharpError");
  var _NextjsRouterMocksNotAvailable = class extends StorybookError {
    constructor(data) {
      super({
        category: "FRAMEWORK_NEXTJS",
        code: 2,
        message: dedent`
        Tried to access router mocks from "${data.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
      }), this.data = data;
    }
  };
  __name(_NextjsRouterMocksNotAvailable, "NextjsRouterMocksNotAvailable");
  var _UnknownArgTypesError = class extends StorybookError {
    constructor(data) {
      super({
        category: "DOCS-TOOLS",
        code: 1,
        documentation: "https://github.com/storybookjs/storybook/issues/26606",
        message: dedent`
        There was a failure when generating detailed ArgTypes in ${data.language} for:
        ${JSON.stringify(data.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
      }), this.data = data;
    }
  };
  __name(_UnknownArgTypesError, "UnknownArgTypesError");
  var UnknownArgTypesError = _UnknownArgTypesError, _UnsupportedViewportDimensionError = class extends StorybookError {
    constructor(data) {
      super({
        category: "ADDON_VITEST",
        code: 1,
        // TODO: Add documentation about viewports support
        // documentation: '',
        message: dedent`
        Encountered an unsupported value "${data.value}" when setting the viewport ${data.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
      }), this.data = data;
    }
  };
  __name(_UnsupportedViewportDimensionError, "UnsupportedViewportDimensionError");
  var _ElementA11yParameterError = class extends StorybookError {
    constructor() {
      super({
        category: "ADDON_A11Y",
        code: 1,
        documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
        message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
      });
    }
  };
  __name(_ElementA11yParameterError, "ElementA11yParameterError");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/preview-errors.js
  init_chunk_MM7DTO55();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-B4A3ADP3.js
  var require_dist = __commonJS({
    "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(exports, module) {
      (function(global2, factory) {
        typeof exports == "object" && typeof module < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.jtpp = {}));
      })(exports, function(exports2) {
        "use strict";
        function tokenToString(token) {
          return token.text !== void 0 && token.text !== "" ? `'${token.type}' with value '${token.text}'` : `'${token.type}'`;
        }
        __name(tokenToString, "tokenToString");
        let _NoParsletFoundError = class _NoParsletFoundError2 extends Error {
          constructor(token) {
            super(`No parslet found for token: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, _NoParsletFoundError2.prototype);
          }
          getToken() {
            return this.token;
          }
        };
        __name(_NoParsletFoundError, "NoParsletFoundError");
        let NoParsletFoundError = _NoParsletFoundError, _EarlyEndOfParseError = class _EarlyEndOfParseError2 extends Error {
          constructor(token) {
            super(`The parsing ended early. The next token was: ${tokenToString(token)}`), this.token = token, Object.setPrototypeOf(this, _EarlyEndOfParseError2.prototype);
          }
          getToken() {
            return this.token;
          }
        };
        __name(_EarlyEndOfParseError, "EarlyEndOfParseError");
        let EarlyEndOfParseError = _EarlyEndOfParseError, _UnexpectedTypeError = class _UnexpectedTypeError2 extends Error {
          constructor(result, message) {
            let error = `Unexpected type: '${result.type}'.`;
            message !== void 0 && (error += ` Message: ${message}`), super(error), Object.setPrototypeOf(this, _UnexpectedTypeError2.prototype);
          }
        };
        __name(_UnexpectedTypeError, "UnexpectedTypeError");
        let UnexpectedTypeError = _UnexpectedTypeError;
        function makePunctuationRule(type) {
          return (text) => text.startsWith(type) ? { type, text: type } : null;
        }
        __name(makePunctuationRule, "makePunctuationRule");
        function getQuoted(text) {
          let position = 0, char, mark = text[0], escaped = !1;
          if (mark !== "'" && mark !== '"')
            return null;
          for (; position < text.length; ) {
            if (position++, char = text[position], !escaped && char === mark) {
              position++;
              break;
            }
            escaped = !escaped && char === "\\";
          }
          if (char !== mark)
            throw new Error("Unterminated String");
          return text.slice(0, position);
        }
        __name(getQuoted, "getQuoted");
        let identifierStartRegex = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), identifierContinueRegex = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
        function getIdentifier(text) {
          let char = text[0];
          if (!identifierStartRegex.test(char))
            return null;
          let position = 1;
          do {
            if (char = text[position], !identifierContinueRegex.test(char))
              break;
            position++;
          } while (position < text.length);
          return text.slice(0, position);
        }
        __name(getIdentifier, "getIdentifier");
        let numberRegex = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
        function getNumber(text) {
          var _a, _b;
          return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
        }
        __name(getNumber, "getNumber");
        let identifierRule = __name((text) => {
          let value2 = getIdentifier(text);
          return value2 == null ? null : {
            type: "Identifier",
            text: value2
          };
        }, "identifierRule");
        function makeKeyWordRule(type) {
          return (text) => {
            if (!text.startsWith(type))
              return null;
            let prepends = text[type.length];
            return prepends !== void 0 && identifierContinueRegex.test(prepends) ? null : {
              type,
              text: type
            };
          };
        }
        __name(makeKeyWordRule, "makeKeyWordRule");
        let stringValueRule = __name((text) => {
          let value2 = getQuoted(text);
          return value2 == null ? null : {
            type: "StringValue",
            text: value2
          };
        }, "stringValueRule"), eofRule = __name((text) => text.length > 0 ? null : {
          type: "EOF",
          text: ""
        }, "eofRule"), numberRule = __name((text) => {
          let value2 = getNumber(text);
          return value2 === null ? null : {
            type: "Number",
            text: value2
          };
        }, "numberRule"), rules = [
          eofRule,
          makePunctuationRule("=>"),
          makePunctuationRule("("),
          makePunctuationRule(")"),
          makePunctuationRule("{"),
          makePunctuationRule("}"),
          makePunctuationRule("["),
          makePunctuationRule("]"),
          makePunctuationRule("|"),
          makePunctuationRule("&"),
          makePunctuationRule("<"),
          makePunctuationRule(">"),
          makePunctuationRule(","),
          makePunctuationRule(";"),
          makePunctuationRule("*"),
          makePunctuationRule("?"),
          makePunctuationRule("!"),
          makePunctuationRule("="),
          makePunctuationRule(":"),
          makePunctuationRule("..."),
          makePunctuationRule("."),
          makePunctuationRule("#"),
          makePunctuationRule("~"),
          makePunctuationRule("/"),
          makePunctuationRule("@"),
          makeKeyWordRule("undefined"),
          makeKeyWordRule("null"),
          makeKeyWordRule("function"),
          makeKeyWordRule("this"),
          makeKeyWordRule("new"),
          makeKeyWordRule("module"),
          makeKeyWordRule("event"),
          makeKeyWordRule("extends"),
          makeKeyWordRule("external"),
          makeKeyWordRule("infer"),
          makeKeyWordRule("typeof"),
          makeKeyWordRule("keyof"),
          makeKeyWordRule("readonly"),
          makeKeyWordRule("import"),
          makeKeyWordRule("is"),
          makeKeyWordRule("in"),
          makeKeyWordRule("asserts"),
          numberRule,
          identifierRule,
          stringValueRule
        ], breakingWhitespaceRegex = /^\s*\n\s*/, _Lexer = class _Lexer2 {
          static create(text) {
            let current = this.read(text);
            text = current.text;
            let next = this.read(text);
            return text = next.text, new _Lexer2(text, void 0, current.token, next.token);
          }
          constructor(text, previous, current, next) {
            this.text = "", this.text = text, this.previous = previous, this.current = current, this.next = next;
          }
          static read(text, startOfLine = !1) {
            startOfLine = startOfLine || breakingWhitespaceRegex.test(text), text = text.trim();
            for (let rule of rules) {
              let partial2 = rule(text);
              if (partial2 !== null) {
                let token = Object.assign(Object.assign({}, partial2), { startOfLine });
                return text = text.slice(token.text.length), { text, token };
              }
            }
            throw new Error("Unexpected Token " + text);
          }
          advance() {
            let next = _Lexer2.read(this.text);
            return new _Lexer2(next.text, this.current, this.next, next.token);
          }
        };
        __name(_Lexer, "Lexer");
        let Lexer = _Lexer;
        function assertRootResult(result) {
          if (result === void 0)
            throw new Error("Unexpected undefined");
          if (result.type === "JsdocTypeKeyValue" || result.type === "JsdocTypeParameterList" || result.type === "JsdocTypeProperty" || result.type === "JsdocTypeReadonlyProperty" || result.type === "JsdocTypeObjectField" || result.type === "JsdocTypeJsdocObjectField" || result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType" || result.type === "JsdocTypeTypeParameter")
            throw new UnexpectedTypeError(result);
          return result;
        }
        __name(assertRootResult, "assertRootResult");
        function assertPlainKeyValueOrRootResult(result) {
          return result.type === "JsdocTypeKeyValue" ? assertPlainKeyValueResult(result) : assertRootResult(result);
        }
        __name(assertPlainKeyValueOrRootResult, "assertPlainKeyValueOrRootResult");
        function assertPlainKeyValueOrNameResult(result) {
          return result.type === "JsdocTypeName" ? result : assertPlainKeyValueResult(result);
        }
        __name(assertPlainKeyValueOrNameResult, "assertPlainKeyValueOrNameResult");
        function assertPlainKeyValueResult(result) {
          if (result.type !== "JsdocTypeKeyValue")
            throw new UnexpectedTypeError(result);
          return result;
        }
        __name(assertPlainKeyValueResult, "assertPlainKeyValueResult");
        function assertNumberOrVariadicNameResult(result) {
          var _a;
          if (result.type === "JsdocTypeVariadic") {
            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === "JsdocTypeName")
              return result;
            throw new UnexpectedTypeError(result);
          }
          if (result.type !== "JsdocTypeNumber" && result.type !== "JsdocTypeName")
            throw new UnexpectedTypeError(result);
          return result;
        }
        __name(assertNumberOrVariadicNameResult, "assertNumberOrVariadicNameResult");
        function assertArrayOrTupleResult(result) {
          if (result.type === "JsdocTypeTuple" || result.type === "JsdocTypeGeneric" && result.meta.brackets === "square")
            return result;
          throw new UnexpectedTypeError(result);
        }
        __name(assertArrayOrTupleResult, "assertArrayOrTupleResult");
        function isSquaredProperty(result) {
          return result.type === "JsdocTypeIndexSignature" || result.type === "JsdocTypeMappedType";
        }
        __name(isSquaredProperty, "isSquaredProperty");
        var Precedence;
        (function(Precedence2) {
          Precedence2[Precedence2.ALL = 0] = "ALL", Precedence2[Precedence2.PARAMETER_LIST = 1] = "PARAMETER_LIST", Precedence2[Precedence2.OBJECT = 2] = "OBJECT", Precedence2[Precedence2.KEY_VALUE = 3] = "KEY_VALUE", Precedence2[Precedence2.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", Precedence2[Precedence2.UNION = 5] = "UNION", Precedence2[Precedence2.INTERSECTION = 6] = "INTERSECTION", Precedence2[Precedence2.PREFIX = 7] = "PREFIX", Precedence2[Precedence2.INFIX = 8] = "INFIX", Precedence2[Precedence2.TUPLE = 9] = "TUPLE", Precedence2[Precedence2.SYMBOL = 10] = "SYMBOL", Precedence2[Precedence2.OPTIONAL = 11] = "OPTIONAL", Precedence2[Precedence2.NULLABLE = 12] = "NULLABLE", Precedence2[Precedence2.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", Precedence2[Precedence2.FUNCTION = 14] = "FUNCTION", Precedence2[Precedence2.ARROW = 15] = "ARROW", Precedence2[Precedence2.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", Precedence2[Precedence2.GENERIC = 17] = "GENERIC", Precedence2[Precedence2.NAME_PATH = 18] = "NAME_PATH", Precedence2[Precedence2.PARENTHESIS = 19] = "PARENTHESIS", Precedence2[Precedence2.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
        })(Precedence || (Precedence = {}));
        let _Parser = class {
          constructor(grammar, textOrLexer, baseParser) {
            this.grammar = grammar, typeof textOrLexer == "string" ? this._lexer = Lexer.create(textOrLexer) : this._lexer = textOrLexer, this.baseParser = baseParser;
          }
          get lexer() {
            return this._lexer;
          }
          /**
           * Parses a given string and throws an error if the parse ended before the end of the string.
           */
          parse() {
            let result = this.parseType(Precedence.ALL);
            if (this.lexer.current.type !== "EOF")
              throw new EarlyEndOfParseError(this.lexer.current);
            return result;
          }
          /**
           * Parses with the current lexer and asserts that the result is a {@link RootResult}.
           */
          parseType(precedence) {
            return assertRootResult(this.parseIntermediateType(precedence));
          }
          /**
           * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
           * to parse the state in the infix step.
           */
          parseIntermediateType(precedence) {
            let result = this.tryParslets(null, precedence);
            if (result === null)
              throw new NoParsletFoundError(this.lexer.current);
            return this.parseInfixIntermediateType(result, precedence);
          }
          /**
           * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
           * a result.
           */
          parseInfixIntermediateType(left, precedence) {
            let result = this.tryParslets(left, precedence);
            for (; result !== null; )
              left = result, result = this.tryParslets(left, precedence);
            return left;
          }
          /**
           * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
           */
          tryParslets(left, precedence) {
            for (let parslet of this.grammar) {
              let result = parslet(this, precedence, left);
              if (result !== null)
                return result;
            }
            return null;
          }
          /**
           * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
           * advanced.
           */
          consume(types2) {
            return Array.isArray(types2) || (types2 = [types2]), types2.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;
          }
          acceptLexerState(parser) {
            this._lexer = parser.lexer;
          }
        };
        __name(_Parser, "Parser");
        let Parser = _Parser;
        function isQuestionMarkUnknownType(next) {
          return next === "}" || next === "EOF" || next === "|" || next === "," || next === ")" || next === ">";
        }
        __name(isQuestionMarkUnknownType, "isQuestionMarkUnknownType");
        let nullableParslet = __name((parser, precedence, left) => {
          let type = parser.lexer.current.type, next = parser.lexer.next.type;
          return left == null && type === "?" && !isQuestionMarkUnknownType(next) || left != null && type === "?" ? (parser.consume("?"), left == null ? {
            type: "JsdocTypeNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          } : {
            type: "JsdocTypeNullable",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          }) : null;
        }, "nullableParslet");
        function composeParslet(options) {
          let parslet = __name((parser, curPrecedence, left) => {
            let type = parser.lexer.current.type, next = parser.lexer.next.type;
            if (left === null) {
              if ("parsePrefix" in options && options.accept(type, next))
                return options.parsePrefix(parser);
            } else if ("parseInfix" in options && options.precedence > curPrecedence && options.accept(type, next))
              return options.parseInfix(parser, left);
            return null;
          }, "parslet");
          return Object.defineProperty(parslet, "name", {
            value: options.name
          }), parslet;
        }
        __name(composeParslet, "composeParslet");
        let optionalParslet = composeParslet({
          name: "optionalParslet",
          accept: __name((type) => type === "=", "accept"),
          precedence: Precedence.OPTIONAL,
          parsePrefix: __name((parser) => (parser.consume("="), {
            type: "JsdocTypeOptional",
            element: parser.parseType(Precedence.OPTIONAL),
            meta: {
              position: "prefix"
            }
          }), "parsePrefix"),
          parseInfix: __name((parser, left) => (parser.consume("="), {
            type: "JsdocTypeOptional",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          }), "parseInfix")
        }), numberParslet = composeParslet({
          name: "numberParslet",
          accept: __name((type) => type === "Number", "accept"),
          parsePrefix: __name((parser) => {
            let value2 = parseFloat(parser.lexer.current.text);
            return parser.consume("Number"), {
              type: "JsdocTypeNumber",
              value: value2
            };
          }, "parsePrefix")
        }), parenthesisParslet = composeParslet({
          name: "parenthesisParslet",
          accept: __name((type) => type === "(", "accept"),
          parsePrefix: __name((parser) => {
            if (parser.consume("("), parser.consume(")"))
              return {
                type: "JsdocTypeParameterList",
                elements: []
              };
            let result = parser.parseIntermediateType(Precedence.ALL);
            if (!parser.consume(")"))
              throw new Error("Unterminated parenthesis");
            return result.type === "JsdocTypeParameterList" ? result : result.type === "JsdocTypeKeyValue" ? {
              type: "JsdocTypeParameterList",
              elements: [result]
            } : {
              type: "JsdocTypeParenthesis",
              element: assertRootResult(result)
            };
          }, "parsePrefix")
        }), specialTypesParslet = composeParslet({
          name: "specialTypesParslet",
          accept: __name((type, next) => type === "?" && isQuestionMarkUnknownType(next) || type === "null" || type === "undefined" || type === "*", "accept"),
          parsePrefix: __name((parser) => {
            if (parser.consume("null"))
              return {
                type: "JsdocTypeNull"
              };
            if (parser.consume("undefined"))
              return {
                type: "JsdocTypeUndefined"
              };
            if (parser.consume("*"))
              return {
                type: "JsdocTypeAny"
              };
            if (parser.consume("?"))
              return {
                type: "JsdocTypeUnknown"
              };
            throw new Error("Unacceptable token: " + parser.lexer.current.text);
          }, "parsePrefix")
        }), notNullableParslet = composeParslet({
          name: "notNullableParslet",
          accept: __name((type) => type === "!", "accept"),
          precedence: Precedence.NULLABLE,
          parsePrefix: __name((parser) => (parser.consume("!"), {
            type: "JsdocTypeNotNullable",
            element: parser.parseType(Precedence.NULLABLE),
            meta: {
              position: "prefix"
            }
          }), "parsePrefix"),
          parseInfix: __name((parser, left) => (parser.consume("!"), {
            type: "JsdocTypeNotNullable",
            element: assertRootResult(left),
            meta: {
              position: "suffix"
            }
          }), "parseInfix")
        });
        function createParameterListParslet({ allowTrailingComma }) {
          return composeParslet({
            name: "parameterListParslet",
            accept: __name((type) => type === ",", "accept"),
            precedence: Precedence.PARAMETER_LIST,
            parseInfix: __name((parser, left) => {
              let elements = [
                assertPlainKeyValueOrRootResult(left)
              ];
              parser.consume(",");
              do
                try {
                  let next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);
                  elements.push(assertPlainKeyValueOrRootResult(next));
                } catch (e) {
                  if (e instanceof NoParsletFoundError)
                    break;
                  throw e;
                }
              while (parser.consume(","));
              if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === "JsdocTypeVariadic"))
                throw new Error("Only the last parameter may be a rest parameter");
              return {
                type: "JsdocTypeParameterList",
                elements
              };
            }, "parseInfix")
          });
        }
        __name(createParameterListParslet, "createParameterListParslet");
        let genericParslet = composeParslet({
          name: "genericParslet",
          accept: __name((type, next) => type === "<" || type === "." && next === "<", "accept"),
          precedence: Precedence.GENERIC,
          parseInfix: __name((parser, left) => {
            let dot = parser.consume(".");
            parser.consume("<");
            let objects = [], infer = !1;
            if (parser.consume("infer")) {
              infer = !0;
              let left2 = parser.parseIntermediateType(Precedence.SYMBOL);
              if (left2.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(left2, "A typescript asserts always has to have a name on the left side.");
              objects.push(left2);
            } else
              do
                objects.push(parser.parseType(Precedence.PARAMETER_LIST));
              while (parser.consume(","));
            if (!parser.consume(">"))
              throw new Error("Unterminated generic parameter list");
            return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: assertRootResult(left), elements: objects }, infer ? { infer: !0 } : {}), { meta: {
              brackets: "angle",
              dot
            } });
          }, "parseInfix")
        }), unionParslet = composeParslet({
          name: "unionParslet",
          accept: __name((type) => type === "|", "accept"),
          precedence: Precedence.UNION,
          parseInfix: __name((parser, left) => {
            parser.consume("|");
            let elements = [];
            do
              elements.push(parser.parseType(Precedence.UNION));
            while (parser.consume("|"));
            return {
              type: "JsdocTypeUnion",
              elements: [assertRootResult(left), ...elements]
            };
          }, "parseInfix")
        }), baseGrammar = [
          nullableParslet,
          optionalParslet,
          numberParslet,
          parenthesisParslet,
          specialTypesParslet,
          notNullableParslet,
          createParameterListParslet({
            allowTrailingComma: !0
          }),
          genericParslet,
          unionParslet,
          optionalParslet
        ];
        function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {
          return __name(function(parser, precedence, left) {
            if (left == null || precedence >= Precedence.NAME_PATH)
              return null;
            let type = parser.lexer.current.type, next = parser.lexer.next.type;
            if (!(type === "." && next !== "<" || type === "[" && (allowSquareBracketsOnAnyType || left.type === "JsdocTypeName") || allowJsdocNamePaths && (type === "~" || type === "#")))
              return null;
            let pathType, brackets = !1;
            parser.consume(".") ? pathType = "property" : parser.consume("[") ? (pathType = "property-brackets", brackets = !0) : parser.consume("~") ? pathType = "inner" : (parser.consume("#"), pathType = "instance");
            let pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser, parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);
            parser.acceptLexerState(pathParser);
            let right;
            switch (parsed.type) {
              case "JsdocTypeName":
                right = {
                  type: "JsdocTypeProperty",
                  value: parsed.value,
                  meta: {
                    quote: void 0
                  }
                };
                break;
              case "JsdocTypeNumber":
                right = {
                  type: "JsdocTypeProperty",
                  value: parsed.value.toString(10),
                  meta: {
                    quote: void 0
                  }
                };
                break;
              case "JsdocTypeStringValue":
                right = {
                  type: "JsdocTypeProperty",
                  value: parsed.value,
                  meta: {
                    quote: parsed.meta.quote
                  }
                };
                break;
              case "JsdocTypeSpecialNamePath":
                if (parsed.specialType === "event")
                  right = parsed;
                else
                  throw new UnexpectedTypeError(parsed, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
                break;
              default:
                throw new UnexpectedTypeError(parsed, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
            }
            if (brackets && !parser.consume("]")) {
              let token = parser.lexer.current;
              throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);
            }
            return {
              type: "JsdocTypeNamePath",
              left: assertRootResult(left),
              right,
              pathType
            };
          }, "namePathParslet");
        }
        __name(createNamePathParslet, "createNamePathParslet");
        function createNameParslet({ allowedAdditionalTokens }) {
          return composeParslet({
            name: "nameParslet",
            accept: __name((type) => type === "Identifier" || type === "this" || type === "new" || allowedAdditionalTokens.includes(type), "accept"),
            parsePrefix: __name((parser) => {
              let { type, text } = parser.lexer.current;
              return parser.consume(type), {
                type: "JsdocTypeName",
                value: text
              };
            }, "parsePrefix")
          });
        }
        __name(createNameParslet, "createNameParslet");
        let stringValueParslet = composeParslet({
          name: "stringValueParslet",
          accept: __name((type) => type === "StringValue", "accept"),
          parsePrefix: __name((parser) => {
            let text = parser.lexer.current.text;
            return parser.consume("StringValue"), {
              type: "JsdocTypeStringValue",
              value: text.slice(1, -1),
              meta: {
                quote: text[0] === "'" ? "single" : "double"
              }
            };
          }, "parsePrefix")
        });
        function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {
          return composeParslet({
            name: "specialNamePathParslet",
            accept: __name((type) => allowedTypes.includes(type), "accept"),
            parsePrefix: __name((parser) => {
              let type = parser.lexer.current.type;
              if (parser.consume(type), !parser.consume(":"))
                return {
                  type: "JsdocTypeName",
                  value: type
                };
              let result, token = parser.lexer.current;
              if (parser.consume("StringValue"))
                result = {
                  type: "JsdocTypeSpecialNamePath",
                  value: token.text.slice(1, -1),
                  specialType: type,
                  meta: {
                    quote: token.text[0] === "'" ? "single" : "double"
                  }
                };
              else {
                let value2 = "", allowed = ["Identifier", "@", "/"];
                for (; allowed.some((type2) => parser.consume(type2)); )
                  value2 += token.text, token = parser.lexer.current;
                result = {
                  type: "JsdocTypeSpecialNamePath",
                  value: value2,
                  specialType: type,
                  meta: {
                    quote: void 0
                  }
                };
              }
              let moduleParser = new Parser(pathGrammar2, parser.lexer, parser), moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);
              return parser.acceptLexerState(moduleParser), assertRootResult(moduleResult);
            }, "parsePrefix")
          });
        }
        __name(createSpecialNamePathParslet, "createSpecialNamePathParslet");
        let basePathGrammar = [
          createNameParslet({
            allowedAdditionalTokens: ["external", "module"]
          }),
          stringValueParslet,
          numberParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar: null
          })
        ], pathGrammar = [
          ...basePathGrammar,
          createSpecialNamePathParslet({
            allowedTypes: ["event"],
            pathGrammar: basePathGrammar
          })
        ];
        function getParameters(value2) {
          let parameters2;
          if (value2.type === "JsdocTypeParameterList")
            parameters2 = value2.elements;
          else if (value2.type === "JsdocTypeParenthesis")
            parameters2 = [value2.element];
          else
            throw new UnexpectedTypeError(value2);
          return parameters2.map((p4) => assertPlainKeyValueOrRootResult(p4));
        }
        __name(getParameters, "getParameters");
        function getUnnamedParameters(value2) {
          let parameters2 = getParameters(value2);
          if (parameters2.some((p4) => p4.type === "JsdocTypeKeyValue"))
            throw new Error("No parameter should be named");
          return parameters2;
        }
        __name(getUnnamedParameters, "getUnnamedParameters");
        function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {
          return composeParslet({
            name: "functionParslet",
            accept: __name((type, next) => type === "function" || allowNewAsFunctionKeyword && type === "new" && next === "(", "accept"),
            parsePrefix: __name((parser) => {
              let newKeyword = parser.consume("new");
              parser.consume("function");
              let hasParenthesis = parser.lexer.current.type === "(";
              if (!hasParenthesis) {
                if (!allowWithoutParenthesis)
                  throw new Error("function is missing parameter list");
                return {
                  type: "JsdocTypeName",
                  value: "function"
                };
              }
              let result = {
                type: "JsdocTypeFunction",
                parameters: [],
                arrow: !1,
                constructor: newKeyword,
                parenthesis: hasParenthesis
              }, value2 = parser.parseIntermediateType(Precedence.FUNCTION);
              if (allowNamedParameters === void 0)
                result.parameters = getUnnamedParameters(value2);
              else {
                if (newKeyword && value2.type === "JsdocTypeFunction" && value2.arrow)
                  return result = value2, result.constructor = !0, result;
                result.parameters = getParameters(value2);
                for (let p4 of result.parameters)
                  if (p4.type === "JsdocTypeKeyValue" && !allowNamedParameters.includes(p4.key))
                    throw new Error(`only allowed named parameters are ${allowNamedParameters.join(", ")} but got ${p4.type}`);
              }
              if (parser.consume(":"))
                result.returnType = parser.parseType(Precedence.PREFIX);
              else if (!allowNoReturnType)
                throw new Error("function is missing return type");
              return result;
            }, "parsePrefix")
          });
        }
        __name(createFunctionParslet, "createFunctionParslet");
        function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {
          return composeParslet({
            name: "variadicParslet",
            accept: __name((type) => type === "...", "accept"),
            precedence: Precedence.PREFIX,
            parsePrefix: __name((parser) => {
              parser.consume("...");
              let brackets = allowEnclosingBrackets && parser.consume("[");
              try {
                let element = parser.parseType(Precedence.PREFIX);
                if (brackets && !parser.consume("]"))
                  throw new Error("Unterminated variadic type. Missing ']'");
                return {
                  type: "JsdocTypeVariadic",
                  element: assertRootResult(element),
                  meta: {
                    position: "prefix",
                    squareBrackets: brackets
                  }
                };
              } catch (e) {
                if (e instanceof NoParsletFoundError) {
                  if (brackets)
                    throw new Error("Empty square brackets for variadic are not allowed.");
                  return {
                    type: "JsdocTypeVariadic",
                    meta: {
                      position: void 0,
                      squareBrackets: !1
                    }
                  };
                } else
                  throw e;
              }
            }, "parsePrefix"),
            parseInfix: allowPostfix ? (parser, left) => (parser.consume("..."), {
              type: "JsdocTypeVariadic",
              element: assertRootResult(left),
              meta: {
                position: "suffix",
                squareBrackets: !1
              }
            }) : void 0
          });
        }
        __name(createVariadicParslet, "createVariadicParslet");
        let symbolParslet = composeParslet({
          name: "symbolParslet",
          accept: __name((type) => type === "(", "accept"),
          precedence: Precedence.SYMBOL,
          parseInfix: __name((parser, left) => {
            if (left.type !== "JsdocTypeName")
              throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
            parser.consume("(");
            let result = {
              type: "JsdocTypeSymbol",
              value: left.value
            };
            if (!parser.consume(")")) {
              let next = parser.parseIntermediateType(Precedence.SYMBOL);
              if (result.element = assertNumberOrVariadicNameResult(next), !parser.consume(")"))
                throw new Error("Symbol does not end after value");
            }
            return result;
          }, "parseInfix")
        }), arrayBracketsParslet = composeParslet({
          name: "arrayBracketsParslet",
          precedence: Precedence.ARRAY_BRACKETS,
          accept: __name((type, next) => type === "[" && next === "]", "accept"),
          parseInfix: __name((parser, left) => (parser.consume("["), parser.consume("]"), {
            type: "JsdocTypeGeneric",
            left: {
              type: "JsdocTypeName",
              value: "Array"
            },
            elements: [
              assertRootResult(left)
            ],
            meta: {
              brackets: "square",
              dot: !1
            }
          }), "parseInfix")
        });
        function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {
          return composeParslet({
            name: "objectParslet",
            accept: __name((type) => type === "{", "accept"),
            parsePrefix: __name((parser) => {
              parser.consume("{");
              let result = {
                type: "JsdocTypeObject",
                meta: {
                  separator: "comma"
                },
                elements: []
              };
              if (!parser.consume("}")) {
                let separator, fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);
                for (; ; ) {
                  fieldParser.acceptLexerState(parser);
                  let field = fieldParser.parseIntermediateType(Precedence.OBJECT);
                  parser.acceptLexerState(fieldParser), field === void 0 && allowKeyTypes && (field = parser.parseIntermediateType(Precedence.OBJECT));
                  let optional = !1;
                  if (field.type === "JsdocTypeNullable" && (optional = !0, field = field.element), field.type === "JsdocTypeNumber" || field.type === "JsdocTypeName" || field.type === "JsdocTypeStringValue") {
                    let quote2;
                    field.type === "JsdocTypeStringValue" && (quote2 = field.meta.quote), result.elements.push({
                      type: "JsdocTypeObjectField",
                      key: field.value.toString(),
                      right: void 0,
                      optional,
                      readonly: !1,
                      meta: {
                        quote: quote2
                      }
                    });
                  } else if (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField")
                    result.elements.push(field);
                  else
                    throw new UnexpectedTypeError(field);
                  if (parser.lexer.current.startOfLine)
                    separator = "linebreak", parser.consume(",") || parser.consume(";");
                  else if (parser.consume(","))
                    separator = "comma";
                  else if (parser.consume(";"))
                    separator = "semicolon";
                  else
                    break;
                  if (parser.lexer.current.type === "}")
                    break;
                }
                if (result.meta.separator = separator ?? "comma", separator === "linebreak" && (result.meta.propertyIndent = "  "), !parser.consume("}"))
                  throw new Error("Unterminated record type. Missing '}'");
              }
              return result;
            }, "parsePrefix")
          });
        }
        __name(createObjectParslet, "createObjectParslet");
        function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {
          return composeParslet({
            name: "objectFieldParslet",
            precedence: Precedence.KEY_VALUE,
            accept: __name((type) => type === ":", "accept"),
            parseInfix: __name((parser, left) => {
              var _a;
              let optional = !1, readonlyProperty = !1;
              allowOptional && left.type === "JsdocTypeNullable" && (optional = !0, left = left.element), allowReadonly && left.type === "JsdocTypeReadonlyProperty" && (readonlyProperty = !0, left = left.element);
              let parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;
              if (parentParser.acceptLexerState(parser), left.type === "JsdocTypeNumber" || left.type === "JsdocTypeName" || left.type === "JsdocTypeStringValue" || isSquaredProperty(left)) {
                if (isSquaredProperty(left) && !allowSquaredProperties)
                  throw new UnexpectedTypeError(left);
                parentParser.consume(":");
                let quote2;
                left.type === "JsdocTypeStringValue" && (quote2 = left.meta.quote);
                let right = parentParser.parseType(Precedence.KEY_VALUE);
                return parser.acceptLexerState(parentParser), {
                  type: "JsdocTypeObjectField",
                  key: isSquaredProperty(left) ? left : left.value.toString(),
                  right,
                  optional,
                  readonly: readonlyProperty,
                  meta: {
                    quote: quote2
                  }
                };
              } else {
                if (!allowKeyTypes)
                  throw new UnexpectedTypeError(left);
                parentParser.consume(":");
                let right = parentParser.parseType(Precedence.KEY_VALUE);
                return parser.acceptLexerState(parentParser), {
                  type: "JsdocTypeJsdocObjectField",
                  left: assertRootResult(left),
                  right
                };
              }
            }, "parseInfix")
          });
        }
        __name(createObjectFieldParslet, "createObjectFieldParslet");
        function createKeyValueParslet({ allowOptional, allowVariadic }) {
          return composeParslet({
            name: "keyValueParslet",
            precedence: Precedence.KEY_VALUE,
            accept: __name((type) => type === ":", "accept"),
            parseInfix: __name((parser, left) => {
              let optional = !1, variadic = !1;
              if (allowOptional && left.type === "JsdocTypeNullable" && (optional = !0, left = left.element), allowVariadic && left.type === "JsdocTypeVariadic" && left.element !== void 0 && (variadic = !0, left = left.element), left.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(left);
              parser.consume(":");
              let right = parser.parseType(Precedence.KEY_VALUE);
              return {
                type: "JsdocTypeKeyValue",
                key: left.value,
                right,
                optional,
                variadic
              };
            }, "parseInfix")
          });
        }
        __name(createKeyValueParslet, "createKeyValueParslet");
        let jsdocBaseGrammar = [
          ...baseGrammar,
          createFunctionParslet({
            allowWithoutParenthesis: !0,
            allowNamedParameters: ["this", "new"],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1
          }),
          stringValueParslet,
          createSpecialNamePathParslet({
            allowedTypes: ["module", "external", "event"],
            pathGrammar
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !0,
            allowPostfix: !0
          }),
          createNameParslet({
            allowedAdditionalTokens: ["keyof"]
          }),
          symbolParslet,
          arrayBracketsParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar
          })
        ], jsdocGrammar = [
          ...jsdocBaseGrammar,
          createObjectParslet({
            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
            // we leave out the object type deliberately
            objectFieldGrammar: [
              createNameParslet({
                allowedAdditionalTokens: ["typeof", "module", "in"]
              }),
              createObjectFieldParslet({
                allowSquaredProperties: !1,
                allowKeyTypes: !0,
                allowOptional: !1,
                allowReadonly: !1
              }),
              ...jsdocBaseGrammar
            ],
            allowKeyTypes: !0
          }),
          createKeyValueParslet({
            allowOptional: !0,
            allowVariadic: !0
          })
        ], typeOfParslet = composeParslet({
          name: "typeOfParslet",
          accept: __name((type) => type === "typeof", "accept"),
          parsePrefix: __name((parser) => (parser.consume("typeof"), {
            type: "JsdocTypeTypeof",
            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)
          }), "parsePrefix")
        }), objectFieldGrammar$1 = [
          createNameParslet({
            allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
          }),
          nullableParslet,
          optionalParslet,
          stringValueParslet,
          numberParslet,
          createObjectFieldParslet({
            allowSquaredProperties: !1,
            allowKeyTypes: !1,
            allowOptional: !1,
            allowReadonly: !1
          })
        ], closureGrammar = [
          ...baseGrammar,
          createObjectParslet({
            allowKeyTypes: !1,
            objectFieldGrammar: objectFieldGrammar$1
          }),
          createNameParslet({
            allowedAdditionalTokens: ["event", "external", "in"]
          }),
          typeOfParslet,
          createFunctionParslet({
            allowWithoutParenthesis: !1,
            allowNamedParameters: ["this", "new"],
            allowNoReturnType: !0,
            allowNewAsFunctionKeyword: !1
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !1,
            allowPostfix: !1
          }),
          // additional name parslet is needed for some special cases
          createNameParslet({
            allowedAdditionalTokens: ["keyof"]
          }),
          createSpecialNamePathParslet({
            allowedTypes: ["module"],
            pathGrammar
          }),
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !1,
            allowJsdocNamePaths: !0,
            pathGrammar
          }),
          createKeyValueParslet({
            allowOptional: !1,
            allowVariadic: !1
          }),
          symbolParslet
        ], assertsParslet = composeParslet({
          name: "assertsParslet",
          accept: __name((type) => type === "asserts", "accept"),
          parsePrefix: __name((parser) => {
            parser.consume("asserts");
            let left = parser.parseIntermediateType(Precedence.SYMBOL);
            if (left.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left, "A typescript asserts always has to have a name on the left side.");
            return parser.consume("is") ? {
              type: "JsdocTypeAsserts",
              left,
              right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
            } : {
              type: "JsdocTypeAssertsPlain",
              element: left
            };
          }, "parsePrefix")
        });
        function createTupleParslet({ allowQuestionMark }) {
          return composeParslet({
            name: "tupleParslet",
            accept: __name((type) => type === "[", "accept"),
            parsePrefix: __name((parser) => {
              parser.consume("[");
              let result = {
                type: "JsdocTypeTuple",
                elements: []
              };
              if (parser.consume("]"))
                return result;
              let typeList = parser.parseIntermediateType(Precedence.ALL);
              if (typeList.type === "JsdocTypeParameterList" ? typeList.elements[0].type === "JsdocTypeKeyValue" ? result.elements = typeList.elements.map(assertPlainKeyValueResult) : result.elements = typeList.elements.map(assertRootResult) : typeList.type === "JsdocTypeKeyValue" ? result.elements = [assertPlainKeyValueResult(typeList)] : result.elements = [assertRootResult(typeList)], !parser.consume("]"))
                throw new Error("Unterminated '['");
              if (result.elements.some((e) => e.type === "JsdocTypeUnknown"))
                throw new Error("Question mark in tuple not allowed");
              return result;
            }, "parsePrefix")
          });
        }
        __name(createTupleParslet, "createTupleParslet");
        let keyOfParslet = composeParslet({
          name: "keyOfParslet",
          accept: __name((type) => type === "keyof", "accept"),
          parsePrefix: __name((parser) => (parser.consume("keyof"), {
            type: "JsdocTypeKeyof",
            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))
          }), "parsePrefix")
        }), importParslet = composeParslet({
          name: "importParslet",
          accept: __name((type) => type === "import", "accept"),
          parsePrefix: __name((parser) => {
            if (parser.consume("import"), !parser.consume("("))
              throw new Error("Missing parenthesis after import keyword");
            let path = parser.parseType(Precedence.PREFIX);
            if (path.type !== "JsdocTypeStringValue")
              throw new Error("Only string values are allowed as paths for imports");
            if (!parser.consume(")"))
              throw new Error("Missing closing parenthesis after import keyword");
            return {
              type: "JsdocTypeImport",
              element: path
            };
          }, "parsePrefix")
        }), readonlyPropertyParslet = composeParslet({
          name: "readonlyPropertyParslet",
          accept: __name((type) => type === "readonly", "accept"),
          parsePrefix: __name((parser) => (parser.consume("readonly"), {
            type: "JsdocTypeReadonlyProperty",
            element: parser.parseIntermediateType(Precedence.KEY_VALUE)
          }), "parsePrefix")
        }), arrowFunctionParslet = composeParslet({
          name: "arrowFunctionParslet",
          precedence: Precedence.ARROW,
          accept: __name((type) => type === "=>", "accept"),
          parseInfix: __name((parser, left) => (parser.consume("=>"), {
            type: "JsdocTypeFunction",
            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),
            arrow: !0,
            constructor: !1,
            parenthesis: !0,
            returnType: parser.parseType(Precedence.OBJECT)
          }), "parseInfix")
        }), genericArrowFunctionParslet = composeParslet({
          name: "genericArrowFunctionParslet",
          accept: __name((type) => type === "<", "accept"),
          parsePrefix: __name((parser) => {
            let typeParameters = [];
            parser.consume("<");
            do {
              let defaultValue, name = parser.parseIntermediateType(Precedence.SYMBOL);
              if (name.type === "JsdocTypeOptional" && (name = name.element, defaultValue = parser.parseType(Precedence.SYMBOL)), name.type !== "JsdocTypeName")
                throw new UnexpectedTypeError(name);
              let constraint;
              parser.consume("extends") && (constraint = parser.parseType(Precedence.SYMBOL), constraint.type === "JsdocTypeOptional" && (constraint = constraint.element, defaultValue = parser.parseType(Precedence.SYMBOL)));
              let typeParameter = {
                type: "JsdocTypeTypeParameter",
                name
              };
              if (constraint !== void 0 && (typeParameter.constraint = constraint), defaultValue !== void 0 && (typeParameter.defaultValue = defaultValue), typeParameters.push(typeParameter), parser.consume(">"))
                break;
            } while (parser.consume(","));
            let functionBase = parser.parseIntermediateType(Precedence.SYMBOL);
            return functionBase.typeParameters = typeParameters, functionBase;
          }, "parsePrefix")
        }), intersectionParslet = composeParslet({
          name: "intersectionParslet",
          accept: __name((type) => type === "&", "accept"),
          precedence: Precedence.INTERSECTION,
          parseInfix: __name((parser, left) => {
            parser.consume("&");
            let elements = [];
            do
              elements.push(parser.parseType(Precedence.INTERSECTION));
            while (parser.consume("&"));
            return {
              type: "JsdocTypeIntersection",
              elements: [assertRootResult(left), ...elements]
            };
          }, "parseInfix")
        }), predicateParslet = composeParslet({
          name: "predicateParslet",
          precedence: Precedence.INFIX,
          accept: __name((type) => type === "is", "accept"),
          parseInfix: __name((parser, left) => {
            if (left.type !== "JsdocTypeName")
              throw new UnexpectedTypeError(left, "A typescript predicate always has to have a name on the left side.");
            return parser.consume("is"), {
              type: "JsdocTypePredicate",
              left,
              right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))
            };
          }, "parseInfix")
        }), objectSquaredPropertyParslet = composeParslet({
          name: "objectSquareBracketPropertyParslet",
          accept: __name((type) => type === "[", "accept"),
          parsePrefix: __name((parser) => {
            if (parser.baseParser === void 0)
              throw new Error("Only allowed inside object grammar");
            parser.consume("[");
            let key = parser.lexer.current.text;
            parser.consume("Identifier");
            let result;
            if (parser.consume(":")) {
              let parentParser = parser.baseParser;
              parentParser.acceptLexerState(parser), result = {
                type: "JsdocTypeIndexSignature",
                key,
                right: parentParser.parseType(Precedence.INDEX_BRACKETS)
              }, parser.acceptLexerState(parentParser);
            } else if (parser.consume("in")) {
              let parentParser = parser.baseParser;
              parentParser.acceptLexerState(parser), result = {
                type: "JsdocTypeMappedType",
                key,
                right: parentParser.parseType(Precedence.ARRAY_BRACKETS)
              }, parser.acceptLexerState(parentParser);
            } else
              throw new Error("Missing ':' or 'in' inside square bracketed property.");
            if (!parser.consume("]"))
              throw new Error("Unterminated square brackets");
            return result;
          }, "parsePrefix")
        }), readonlyArrayParslet = composeParslet({
          name: "readonlyArrayParslet",
          accept: __name((type) => type === "readonly", "accept"),
          parsePrefix: __name((parser) => (parser.consume("readonly"), {
            type: "JsdocTypeReadonlyArray",
            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))
          }), "parsePrefix")
        }), conditionalParslet = composeParslet({
          name: "conditionalParslet",
          precedence: Precedence.INFIX,
          accept: __name((type) => type === "extends", "accept"),
          parseInfix: __name((parser, left) => {
            parser.consume("extends");
            let extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element, trueType = parser.parseType(Precedence.INFIX);
            return parser.consume(":"), {
              type: "JsdocTypeConditional",
              checksType: assertRootResult(left),
              extendsType,
              trueType,
              falseType: parser.parseType(Precedence.INFIX)
            };
          }, "parseInfix")
        }), objectFieldGrammar = [
          readonlyPropertyParslet,
          createNameParslet({
            allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
          }),
          nullableParslet,
          optionalParslet,
          stringValueParslet,
          numberParslet,
          createObjectFieldParslet({
            allowSquaredProperties: !0,
            allowKeyTypes: !1,
            allowOptional: !0,
            allowReadonly: !0
          }),
          objectSquaredPropertyParslet
        ], typescriptGrammar = [
          ...baseGrammar,
          createObjectParslet({
            allowKeyTypes: !1,
            objectFieldGrammar
          }),
          readonlyArrayParslet,
          typeOfParslet,
          keyOfParslet,
          importParslet,
          stringValueParslet,
          createFunctionParslet({
            allowWithoutParenthesis: !0,
            allowNoReturnType: !1,
            allowNamedParameters: ["this", "new", "args"],
            allowNewAsFunctionKeyword: !0
          }),
          createTupleParslet({
            allowQuestionMark: !1
          }),
          createVariadicParslet({
            allowEnclosingBrackets: !1,
            allowPostfix: !1
          }),
          assertsParslet,
          conditionalParslet,
          createNameParslet({
            allowedAdditionalTokens: ["event", "external", "in"]
          }),
          createSpecialNamePathParslet({
            allowedTypes: ["module"],
            pathGrammar
          }),
          arrayBracketsParslet,
          arrowFunctionParslet,
          genericArrowFunctionParslet,
          createNamePathParslet({
            allowSquareBracketsOnAnyType: !0,
            allowJsdocNamePaths: !1,
            pathGrammar
          }),
          intersectionParslet,
          predicateParslet,
          createKeyValueParslet({
            allowVariadic: !0,
            allowOptional: !0
          })
        ];
        function parse33(expression, mode) {
          switch (mode) {
            case "closure":
              return new Parser(closureGrammar, expression).parse();
            case "jsdoc":
              return new Parser(jsdocGrammar, expression).parse();
            case "typescript":
              return new Parser(typescriptGrammar, expression).parse();
          }
        }
        __name(parse33, "parse");
        function tryParse(expression, modes = ["typescript", "closure", "jsdoc"]) {
          let error;
          for (let mode of modes)
            try {
              return parse33(expression, mode);
            } catch (e) {
              error = e;
            }
          throw error;
        }
        __name(tryParse, "tryParse");
        function transform(rules2, parseResult) {
          let rule = rules2[parseResult.type];
          if (rule === void 0)
            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);
          return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));
        }
        __name(transform, "transform");
        function notAvailableTransform(parseResult) {
          throw new Error("This transform is not available. Are you trying the correct parsing mode?");
        }
        __name(notAvailableTransform, "notAvailableTransform");
        function extractSpecialParams(source) {
          let result = {
            params: []
          };
          for (let param of source.parameters)
            param.type === "JsdocTypeKeyValue" ? param.key === "this" ? result.this = param.right : param.key === "new" ? result.new = param.right : result.params.push(param) : result.params.push(param);
          return result;
        }
        __name(extractSpecialParams, "extractSpecialParams");
        function applyPosition(position, target, value2) {
          return position === "prefix" ? value2 + target : target + value2;
        }
        __name(applyPosition, "applyPosition");
        function quote(value2, quote2) {
          switch (quote2) {
            case "double":
              return `"${value2}"`;
            case "single":
              return `'${value2}'`;
            case void 0:
              return value2;
          }
        }
        __name(quote, "quote");
        function stringifyRules2() {
          return {
            JsdocTypeParenthesis: __name((result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : ""})`, "JsdocTypeParenthesis"),
            JsdocTypeKeyof: __name((result, transform2) => `keyof ${transform2(result.element)}`, "JsdocTypeKeyof"),
            JsdocTypeFunction: __name((result, transform2) => {
              var _a;
              if (result.arrow) {
                if (result.returnType === void 0)
                  throw new Error("Arrow function needs a return type.");
                let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(", ")) !== null && _a !== void 0 ? _a : ""}>` : ""}(${result.parameters.map(transform2).join(", ")}) => ${transform2(result.returnType)}`;
                return result.constructor && (stringified = "new " + stringified), stringified;
              } else {
                let stringified = result.constructor ? "new" : "function";
                return result.parenthesis && (stringified += `(${result.parameters.map(transform2).join(", ")})`, result.returnType !== void 0 && (stringified += `: ${transform2(result.returnType)}`)), stringified;
              }
            }, "JsdocTypeFunction"),
            JsdocTypeName: __name((result) => result.value, "JsdocTypeName"),
            JsdocTypeTuple: __name((result, transform2) => `[${result.elements.map(transform2).join(", ")}]`, "JsdocTypeTuple"),
            JsdocTypeVariadic: __name((result, transform2) => result.meta.position === void 0 ? "..." : applyPosition(result.meta.position, transform2(result.element), "..."), "JsdocTypeVariadic"),
            JsdocTypeNamePath: __name((result, transform2) => {
              let left = transform2(result.left), right = transform2(result.right);
              switch (result.pathType) {
                case "inner":
                  return `${left}~${right}`;
                case "instance":
                  return `${left}#${right}`;
                case "property":
                  return `${left}.${right}`;
                case "property-brackets":
                  return `${left}[${right}]`;
              }
            }, "JsdocTypeNamePath"),
            JsdocTypeStringValue: __name((result) => quote(result.value, result.meta.quote), "JsdocTypeStringValue"),
            JsdocTypeAny: __name(() => "*", "JsdocTypeAny"),
            JsdocTypeGeneric: __name((result, transform2) => {
              if (result.meta.brackets === "square") {
                let element = result.elements[0], transformed = transform2(element);
                return element.type === "JsdocTypeUnion" || element.type === "JsdocTypeIntersection" ? `(${transformed})[]` : `${transformed}[]`;
              } else
                return `${transform2(result.left)}${result.meta.dot ? "." : ""}<${result.infer === !0 ? "infer " : ""}${result.elements.map(transform2).join(", ")}>`;
            }, "JsdocTypeGeneric"),
            JsdocTypeImport: __name((result, transform2) => `import(${transform2(result.element)})`, "JsdocTypeImport"),
            JsdocTypeObjectField: __name((result, transform2) => {
              let text = "";
              return result.readonly && (text += "readonly "), typeof result.key == "string" ? text += quote(result.key, result.meta.quote) : text += transform2(result.key), result.optional && (text += "?"), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
            }, "JsdocTypeObjectField"),
            JsdocTypeJsdocObjectField: __name((result, transform2) => `${transform2(result.left)}: ${transform2(result.right)}`, "JsdocTypeJsdocObjectField"),
            JsdocTypeKeyValue: __name((result, transform2) => {
              let text = result.key;
              return result.optional && (text += "?"), result.variadic && (text = "..." + text), result.right === void 0 ? text : text + `: ${transform2(result.right)}`;
            }, "JsdocTypeKeyValue"),
            JsdocTypeSpecialNamePath: __name((result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`, "JsdocTypeSpecialNamePath"),
            JsdocTypeNotNullable: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "!"), "JsdocTypeNotNullable"),
            JsdocTypeNull: __name(() => "null", "JsdocTypeNull"),
            JsdocTypeNullable: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "?"), "JsdocTypeNullable"),
            JsdocTypeNumber: __name((result) => result.value.toString(), "JsdocTypeNumber"),
            JsdocTypeObject: __name((result, transform2) => {
              var _a, _b;
              return `{${(result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : "") : "") + result.elements.map(transform2).join(result.meta.separator === "comma" ? ", " : result.meta.separator === "linebreak" ? `
` + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : "") : "; ") + (result.meta.separator === "linebreak" && result.elements.length > 1 ? `
` : "")}}`;
            }, "JsdocTypeObject"),
            JsdocTypeOptional: __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), "="), "JsdocTypeOptional"),
            JsdocTypeSymbol: __name((result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : ""})`, "JsdocTypeSymbol"),
            JsdocTypeTypeof: __name((result, transform2) => `typeof ${transform2(result.element)}`, "JsdocTypeTypeof"),
            JsdocTypeUndefined: __name(() => "undefined", "JsdocTypeUndefined"),
            JsdocTypeUnion: __name((result, transform2) => result.elements.map(transform2).join(" | "), "JsdocTypeUnion"),
            JsdocTypeUnknown: __name(() => "?", "JsdocTypeUnknown"),
            JsdocTypeIntersection: __name((result, transform2) => result.elements.map(transform2).join(" & "), "JsdocTypeIntersection"),
            JsdocTypeProperty: __name((result) => quote(result.value, result.meta.quote), "JsdocTypeProperty"),
            JsdocTypePredicate: __name((result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`, "JsdocTypePredicate"),
            JsdocTypeIndexSignature: __name((result, transform2) => `[${result.key}: ${transform2(result.right)}]`, "JsdocTypeIndexSignature"),
            JsdocTypeMappedType: __name((result, transform2) => `[${result.key} in ${transform2(result.right)}]`, "JsdocTypeMappedType"),
            JsdocTypeAsserts: __name((result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`, "JsdocTypeAsserts"),
            JsdocTypeReadonlyArray: __name((result, transform2) => `readonly ${transform2(result.element)}`, "JsdocTypeReadonlyArray"),
            JsdocTypeAssertsPlain: __name((result, transform2) => `asserts ${transform2(result.element)}`, "JsdocTypeAssertsPlain"),
            JsdocTypeConditional: __name((result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`, "JsdocTypeConditional"),
            JsdocTypeTypeParameter: __name((result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : ""}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : ""}`, "JsdocTypeTypeParameter")
          };
        }
        __name(stringifyRules2, "stringifyRules");
        let storedStringifyRules = stringifyRules2();
        function stringify22(result) {
          return transform(storedStringifyRules, result);
        }
        __name(stringify22, "stringify");
        let reservedWords = [
          "null",
          "true",
          "false",
          "break",
          "case",
          "catch",
          "class",
          "const",
          "continue",
          "debugger",
          "default",
          "delete",
          "do",
          "else",
          "export",
          "extends",
          "finally",
          "for",
          "function",
          "if",
          "import",
          "in",
          "instanceof",
          "new",
          "return",
          "super",
          "switch",
          "this",
          "throw",
          "try",
          "typeof",
          "var",
          "void",
          "while",
          "with",
          "yield"
        ];
        function makeName(value2) {
          let result = {
            type: "NameExpression",
            name: value2
          };
          return reservedWords.includes(value2) && (result.reservedWord = !0), result;
        }
        __name(makeName, "makeName");
        let catharsisTransformRules = {
          JsdocTypeOptional: __name((result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.optional = !0, transformed;
          }, "JsdocTypeOptional"),
          JsdocTypeNullable: __name((result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.nullable = !0, transformed;
          }, "JsdocTypeNullable"),
          JsdocTypeNotNullable: __name((result, transform2) => {
            let transformed = transform2(result.element);
            return transformed.nullable = !1, transformed;
          }, "JsdocTypeNotNullable"),
          JsdocTypeVariadic: __name((result, transform2) => {
            if (result.element === void 0)
              throw new Error("dots without value are not allowed in catharsis mode");
            let transformed = transform2(result.element);
            return transformed.repeatable = !0, transformed;
          }, "JsdocTypeVariadic"),
          JsdocTypeAny: __name(() => ({
            type: "AllLiteral"
          }), "JsdocTypeAny"),
          JsdocTypeNull: __name(() => ({
            type: "NullLiteral"
          }), "JsdocTypeNull"),
          JsdocTypeStringValue: __name((result) => makeName(quote(result.value, result.meta.quote)), "JsdocTypeStringValue"),
          JsdocTypeUndefined: __name(() => ({
            type: "UndefinedLiteral"
          }), "JsdocTypeUndefined"),
          JsdocTypeUnknown: __name(() => ({
            type: "UnknownLiteral"
          }), "JsdocTypeUnknown"),
          JsdocTypeFunction: __name((result, transform2) => {
            let params = extractSpecialParams(result), transformed = {
              type: "FunctionType",
              params: params.params.map(transform2)
            };
            return params.this !== void 0 && (transformed.this = transform2(params.this)), params.new !== void 0 && (transformed.new = transform2(params.new)), result.returnType !== void 0 && (transformed.result = transform2(result.returnType)), transformed;
          }, "JsdocTypeFunction"),
          JsdocTypeGeneric: __name((result, transform2) => ({
            type: "TypeApplication",
            applications: result.elements.map((o2) => transform2(o2)),
            expression: transform2(result.left)
          }), "JsdocTypeGeneric"),
          JsdocTypeSpecialNamePath: __name((result) => makeName(result.specialType + ":" + quote(result.value, result.meta.quote)), "JsdocTypeSpecialNamePath"),
          JsdocTypeName: __name((result) => result.value !== "function" ? makeName(result.value) : {
            type: "FunctionType",
            params: []
          }, "JsdocTypeName"),
          JsdocTypeNumber: __name((result) => makeName(result.value.toString()), "JsdocTypeNumber"),
          JsdocTypeObject: __name((result, transform2) => {
            let transformed = {
              type: "RecordType",
              fields: []
            };
            for (let field of result.elements)
              field.type !== "JsdocTypeObjectField" && field.type !== "JsdocTypeJsdocObjectField" ? transformed.fields.push({
                type: "FieldType",
                key: transform2(field),
                value: void 0
              }) : transformed.fields.push(transform2(field));
            return transformed;
          }, "JsdocTypeObject"),
          JsdocTypeObjectField: __name((result, transform2) => {
            if (typeof result.key != "string")
              throw new Error("Index signatures and mapped types are not supported");
            return {
              type: "FieldType",
              key: makeName(quote(result.key, result.meta.quote)),
              value: result.right === void 0 ? void 0 : transform2(result.right)
            };
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: __name((result, transform2) => ({
            type: "FieldType",
            key: transform2(result.left),
            value: transform2(result.right)
          }), "JsdocTypeJsdocObjectField"),
          JsdocTypeUnion: __name((result, transform2) => ({
            type: "TypeUnion",
            elements: result.elements.map((e) => transform2(e))
          }), "JsdocTypeUnion"),
          JsdocTypeKeyValue: __name((result, transform2) => ({
            type: "FieldType",
            key: makeName(result.key),
            value: result.right === void 0 ? void 0 : transform2(result.right)
          }), "JsdocTypeKeyValue"),
          JsdocTypeNamePath: __name((result, transform2) => {
            let leftResult = transform2(result.left), rightValue;
            result.right.type === "JsdocTypeSpecialNamePath" ? rightValue = transform2(result.right).name : rightValue = quote(result.right.value, result.right.meta.quote);
            let joiner = result.pathType === "inner" ? "~" : result.pathType === "instance" ? "#" : ".";
            return makeName(`${leftResult.name}${joiner}${rightValue}`);
          }, "JsdocTypeNamePath"),
          JsdocTypeSymbol: __name((result) => {
            let value2 = "", element = result.element, trailingDots = !1;
            return element?.type === "JsdocTypeVariadic" && (element.meta.position === "prefix" ? value2 = "..." : trailingDots = !0, element = element.element), element?.type === "JsdocTypeName" ? value2 += element.value : element?.type === "JsdocTypeNumber" && (value2 += element.value.toString()), trailingDots && (value2 += "..."), makeName(`${result.value}(${value2})`);
          }, "JsdocTypeSymbol"),
          JsdocTypeParenthesis: __name((result, transform2) => transform2(assertRootResult(result.element)), "JsdocTypeParenthesis"),
          JsdocTypeMappedType: notAvailableTransform,
          JsdocTypeIndexSignature: notAvailableTransform,
          JsdocTypeImport: notAvailableTransform,
          JsdocTypeKeyof: notAvailableTransform,
          JsdocTypeTuple: notAvailableTransform,
          JsdocTypeTypeof: notAvailableTransform,
          JsdocTypeIntersection: notAvailableTransform,
          JsdocTypeProperty: notAvailableTransform,
          JsdocTypePredicate: notAvailableTransform,
          JsdocTypeAsserts: notAvailableTransform,
          JsdocTypeReadonlyArray: notAvailableTransform,
          JsdocTypeAssertsPlain: notAvailableTransform,
          JsdocTypeConditional: notAvailableTransform,
          JsdocTypeTypeParameter: notAvailableTransform
        };
        function catharsisTransform(result) {
          return transform(catharsisTransformRules, result);
        }
        __name(catharsisTransform, "catharsisTransform");
        function getQuoteStyle(quote2) {
          switch (quote2) {
            case void 0:
              return "none";
            case "single":
              return "single";
            case "double":
              return "double";
          }
        }
        __name(getQuoteStyle, "getQuoteStyle");
        function getMemberType(type) {
          switch (type) {
            case "inner":
              return "INNER_MEMBER";
            case "instance":
              return "INSTANCE_MEMBER";
            case "property":
              return "MEMBER";
            case "property-brackets":
              return "MEMBER";
          }
        }
        __name(getMemberType, "getMemberType");
        function nestResults(type, results) {
          return results.length === 2 ? {
            type,
            left: results[0],
            right: results[1]
          } : {
            type,
            left: results[0],
            right: nestResults(type, results.slice(1))
          };
        }
        __name(nestResults, "nestResults");
        let jtpRules = {
          JsdocTypeOptional: __name((result, transform2) => ({
            type: "OPTIONAL",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
            }
          }), "JsdocTypeOptional"),
          JsdocTypeNullable: __name((result, transform2) => ({
            type: "NULLABLE",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
            }
          }), "JsdocTypeNullable"),
          JsdocTypeNotNullable: __name((result, transform2) => ({
            type: "NOT_NULLABLE",
            value: transform2(result.element),
            meta: {
              syntax: result.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
            }
          }), "JsdocTypeNotNullable"),
          JsdocTypeVariadic: __name((result, transform2) => {
            let transformed = {
              type: "VARIADIC",
              meta: {
                syntax: result.meta.position === "prefix" ? "PREFIX_DOTS" : result.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
              }
            };
            return result.element !== void 0 && (transformed.value = transform2(result.element)), transformed;
          }, "JsdocTypeVariadic"),
          JsdocTypeName: __name((result) => ({
            type: "NAME",
            name: result.value
          }), "JsdocTypeName"),
          JsdocTypeTypeof: __name((result, transform2) => ({
            type: "TYPE_QUERY",
            name: transform2(result.element)
          }), "JsdocTypeTypeof"),
          JsdocTypeTuple: __name((result, transform2) => ({
            type: "TUPLE",
            entries: result.elements.map(transform2)
          }), "JsdocTypeTuple"),
          JsdocTypeKeyof: __name((result, transform2) => ({
            type: "KEY_QUERY",
            value: transform2(result.element)
          }), "JsdocTypeKeyof"),
          JsdocTypeImport: __name((result) => ({
            type: "IMPORT",
            path: {
              type: "STRING_VALUE",
              quoteStyle: getQuoteStyle(result.element.meta.quote),
              string: result.element.value
            }
          }), "JsdocTypeImport"),
          JsdocTypeUndefined: __name(() => ({
            type: "NAME",
            name: "undefined"
          }), "JsdocTypeUndefined"),
          JsdocTypeAny: __name(() => ({
            type: "ANY"
          }), "JsdocTypeAny"),
          JsdocTypeFunction: __name((result, transform2) => {
            let specialParams = extractSpecialParams(result), transformed = {
              type: result.arrow ? "ARROW" : "FUNCTION",
              params: specialParams.params.map((param) => {
                if (param.type === "JsdocTypeKeyValue") {
                  if (param.right === void 0)
                    throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                  return {
                    type: "NAMED_PARAMETER",
                    name: param.key,
                    typeName: transform2(param.right)
                  };
                } else
                  return transform2(param);
              }),
              new: null,
              returns: null
            };
            return specialParams.this !== void 0 ? transformed.this = transform2(specialParams.this) : result.arrow || (transformed.this = null), specialParams.new !== void 0 && (transformed.new = transform2(specialParams.new)), result.returnType !== void 0 && (transformed.returns = transform2(result.returnType)), transformed;
          }, "JsdocTypeFunction"),
          JsdocTypeGeneric: __name((result, transform2) => {
            let transformed = {
              type: "GENERIC",
              subject: transform2(result.left),
              objects: result.elements.map(transform2),
              meta: {
                syntax: result.meta.brackets === "square" ? "SQUARE_BRACKET" : result.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
              }
            };
            return result.meta.brackets === "square" && result.elements[0].type === "JsdocTypeFunction" && !result.elements[0].parenthesis && (transformed.objects[0] = {
              type: "NAME",
              name: "function"
            }), transformed;
          }, "JsdocTypeGeneric"),
          JsdocTypeObjectField: __name((result, transform2) => {
            if (typeof result.key != "string")
              throw new Error("Index signatures and mapped types are not supported");
            if (result.right === void 0)
              return {
                type: "RECORD_ENTRY",
                key: result.key,
                quoteStyle: getQuoteStyle(result.meta.quote),
                value: null,
                readonly: !1
              };
            let right = transform2(result.right);
            return result.optional && (right = {
              type: "OPTIONAL",
              value: right,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            }), {
              type: "RECORD_ENTRY",
              key: result.key.toString(),
              quoteStyle: getQuoteStyle(result.meta.quote),
              value: right,
              readonly: !1
            };
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: __name(() => {
            throw new Error("Keys may not be typed in jsdoctypeparser.");
          }, "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: __name((result, transform2) => {
            if (result.right === void 0)
              return {
                type: "RECORD_ENTRY",
                key: result.key,
                quoteStyle: "none",
                value: null,
                readonly: !1
              };
            let right = transform2(result.right);
            return result.optional && (right = {
              type: "OPTIONAL",
              value: right,
              meta: {
                syntax: "SUFFIX_KEY_QUESTION_MARK"
              }
            }), {
              type: "RECORD_ENTRY",
              key: result.key,
              quoteStyle: "none",
              value: right,
              readonly: !1
            };
          }, "JsdocTypeKeyValue"),
          JsdocTypeObject: __name((result, transform2) => {
            let entries = [];
            for (let field of result.elements)
              (field.type === "JsdocTypeObjectField" || field.type === "JsdocTypeJsdocObjectField") && entries.push(transform2(field));
            return {
              type: "RECORD",
              entries
            };
          }, "JsdocTypeObject"),
          JsdocTypeSpecialNamePath: __name((result) => {
            if (result.specialType !== "module")
              throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);
            return {
              type: "MODULE",
              value: {
                type: "FILE_PATH",
                quoteStyle: getQuoteStyle(result.meta.quote),
                path: result.value
              }
            };
          }, "JsdocTypeSpecialNamePath"),
          JsdocTypeNamePath: __name((result, transform2) => {
            let hasEventPrefix = !1, name, quoteStyle;
            result.right.type === "JsdocTypeSpecialNamePath" && result.right.specialType === "event" ? (hasEventPrefix = !0, name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote)) : (name = result.right.value, quoteStyle = getQuoteStyle(result.right.meta.quote));
            let transformed = {
              type: getMemberType(result.pathType),
              owner: transform2(result.left),
              name,
              quoteStyle,
              hasEventPrefix
            };
            if (transformed.owner.type === "MODULE") {
              let tModule = transformed.owner;
              return transformed.owner = transformed.owner.value, tModule.value = transformed, tModule;
            } else
              return transformed;
          }, "JsdocTypeNamePath"),
          JsdocTypeUnion: __name((result, transform2) => nestResults("UNION", result.elements.map(transform2)), "JsdocTypeUnion"),
          JsdocTypeParenthesis: __name((result, transform2) => ({
            type: "PARENTHESIS",
            value: transform2(assertRootResult(result.element))
          }), "JsdocTypeParenthesis"),
          JsdocTypeNull: __name(() => ({
            type: "NAME",
            name: "null"
          }), "JsdocTypeNull"),
          JsdocTypeUnknown: __name(() => ({
            type: "UNKNOWN"
          }), "JsdocTypeUnknown"),
          JsdocTypeStringValue: __name((result) => ({
            type: "STRING_VALUE",
            quoteStyle: getQuoteStyle(result.meta.quote),
            string: result.value
          }), "JsdocTypeStringValue"),
          JsdocTypeIntersection: __name((result, transform2) => nestResults("INTERSECTION", result.elements.map(transform2)), "JsdocTypeIntersection"),
          JsdocTypeNumber: __name((result) => ({
            type: "NUMBER_VALUE",
            number: result.value.toString()
          }), "JsdocTypeNumber"),
          JsdocTypeSymbol: notAvailableTransform,
          JsdocTypeProperty: notAvailableTransform,
          JsdocTypePredicate: notAvailableTransform,
          JsdocTypeMappedType: notAvailableTransform,
          JsdocTypeIndexSignature: notAvailableTransform,
          JsdocTypeAsserts: notAvailableTransform,
          JsdocTypeReadonlyArray: notAvailableTransform,
          JsdocTypeAssertsPlain: notAvailableTransform,
          JsdocTypeConditional: notAvailableTransform,
          JsdocTypeTypeParameter: notAvailableTransform
        };
        function jtpTransform(result) {
          return transform(jtpRules, result);
        }
        __name(jtpTransform, "jtpTransform");
        function identityTransformRules() {
          return {
            JsdocTypeIntersection: __name((result, transform2) => ({
              type: "JsdocTypeIntersection",
              elements: result.elements.map(transform2)
            }), "JsdocTypeIntersection"),
            JsdocTypeGeneric: __name((result, transform2) => ({
              type: "JsdocTypeGeneric",
              left: transform2(result.left),
              elements: result.elements.map(transform2),
              meta: {
                dot: result.meta.dot,
                brackets: result.meta.brackets
              }
            }), "JsdocTypeGeneric"),
            JsdocTypeNullable: __name((result) => result, "JsdocTypeNullable"),
            JsdocTypeUnion: __name((result, transform2) => ({
              type: "JsdocTypeUnion",
              elements: result.elements.map(transform2)
            }), "JsdocTypeUnion"),
            JsdocTypeUnknown: __name((result) => result, "JsdocTypeUnknown"),
            JsdocTypeUndefined: __name((result) => result, "JsdocTypeUndefined"),
            JsdocTypeTypeof: __name((result, transform2) => ({
              type: "JsdocTypeTypeof",
              element: transform2(result.element)
            }), "JsdocTypeTypeof"),
            JsdocTypeSymbol: __name((result, transform2) => {
              let transformed = {
                type: "JsdocTypeSymbol",
                value: result.value
              };
              return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
            }, "JsdocTypeSymbol"),
            JsdocTypeOptional: __name((result, transform2) => ({
              type: "JsdocTypeOptional",
              element: transform2(result.element),
              meta: {
                position: result.meta.position
              }
            }), "JsdocTypeOptional"),
            JsdocTypeObject: __name((result, transform2) => ({
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: result.elements.map(transform2)
            }), "JsdocTypeObject"),
            JsdocTypeNumber: __name((result) => result, "JsdocTypeNumber"),
            JsdocTypeNull: __name((result) => result, "JsdocTypeNull"),
            JsdocTypeNotNullable: __name((result, transform2) => ({
              type: "JsdocTypeNotNullable",
              element: transform2(result.element),
              meta: {
                position: result.meta.position
              }
            }), "JsdocTypeNotNullable"),
            JsdocTypeSpecialNamePath: __name((result) => result, "JsdocTypeSpecialNamePath"),
            JsdocTypeObjectField: __name((result, transform2) => ({
              type: "JsdocTypeObjectField",
              key: result.key,
              right: result.right === void 0 ? void 0 : transform2(result.right),
              optional: result.optional,
              readonly: result.readonly,
              meta: result.meta
            }), "JsdocTypeObjectField"),
            JsdocTypeJsdocObjectField: __name((result, transform2) => ({
              type: "JsdocTypeJsdocObjectField",
              left: transform2(result.left),
              right: transform2(result.right)
            }), "JsdocTypeJsdocObjectField"),
            JsdocTypeKeyValue: __name((result, transform2) => ({
              type: "JsdocTypeKeyValue",
              key: result.key,
              right: result.right === void 0 ? void 0 : transform2(result.right),
              optional: result.optional,
              variadic: result.variadic
            }), "JsdocTypeKeyValue"),
            JsdocTypeImport: __name((result, transform2) => ({
              type: "JsdocTypeImport",
              element: transform2(result.element)
            }), "JsdocTypeImport"),
            JsdocTypeAny: __name((result) => result, "JsdocTypeAny"),
            JsdocTypeStringValue: __name((result) => result, "JsdocTypeStringValue"),
            JsdocTypeNamePath: __name((result) => result, "JsdocTypeNamePath"),
            JsdocTypeVariadic: __name((result, transform2) => {
              let transformed = {
                type: "JsdocTypeVariadic",
                meta: {
                  position: result.meta.position,
                  squareBrackets: result.meta.squareBrackets
                }
              };
              return result.element !== void 0 && (transformed.element = transform2(result.element)), transformed;
            }, "JsdocTypeVariadic"),
            JsdocTypeTuple: __name((result, transform2) => ({
              type: "JsdocTypeTuple",
              elements: result.elements.map(transform2)
            }), "JsdocTypeTuple"),
            JsdocTypeName: __name((result) => result, "JsdocTypeName"),
            JsdocTypeFunction: __name((result, transform2) => {
              let transformed = {
                type: "JsdocTypeFunction",
                arrow: result.arrow,
                parameters: result.parameters.map(transform2),
                constructor: result.constructor,
                parenthesis: result.parenthesis
              };
              return result.returnType !== void 0 && (transformed.returnType = transform2(result.returnType)), transformed;
            }, "JsdocTypeFunction"),
            JsdocTypeKeyof: __name((result, transform2) => ({
              type: "JsdocTypeKeyof",
              element: transform2(result.element)
            }), "JsdocTypeKeyof"),
            JsdocTypeParenthesis: __name((result, transform2) => ({
              type: "JsdocTypeParenthesis",
              element: transform2(result.element)
            }), "JsdocTypeParenthesis"),
            JsdocTypeProperty: __name((result) => result, "JsdocTypeProperty"),
            JsdocTypePredicate: __name((result, transform2) => ({
              type: "JsdocTypePredicate",
              left: transform2(result.left),
              right: transform2(result.right)
            }), "JsdocTypePredicate"),
            JsdocTypeIndexSignature: __name((result, transform2) => ({
              type: "JsdocTypeIndexSignature",
              key: result.key,
              right: transform2(result.right)
            }), "JsdocTypeIndexSignature"),
            JsdocTypeMappedType: __name((result, transform2) => ({
              type: "JsdocTypeMappedType",
              key: result.key,
              right: transform2(result.right)
            }), "JsdocTypeMappedType"),
            JsdocTypeAsserts: __name((result, transform2) => ({
              type: "JsdocTypeAsserts",
              left: transform2(result.left),
              right: transform2(result.right)
            }), "JsdocTypeAsserts"),
            JsdocTypeReadonlyArray: __name((result, transform2) => ({
              type: "JsdocTypeReadonlyArray",
              element: transform2(result.element)
            }), "JsdocTypeReadonlyArray"),
            JsdocTypeAssertsPlain: __name((result, transform2) => ({
              type: "JsdocTypeAssertsPlain",
              element: transform2(result.element)
            }), "JsdocTypeAssertsPlain"),
            JsdocTypeConditional: __name((result, transform2) => ({
              type: "JsdocTypeConditional",
              checksType: transform2(result.checksType),
              extendsType: transform2(result.extendsType),
              trueType: transform2(result.trueType),
              falseType: transform2(result.falseType)
            }), "JsdocTypeConditional"),
            JsdocTypeTypeParameter: __name((result, transform2) => ({
              type: "JsdocTypeTypeParameter",
              name: transform2(result.name),
              constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,
              defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0
            }), "JsdocTypeTypeParameter")
          };
        }
        __name(identityTransformRules, "identityTransformRules");
        let visitorKeys = {
          JsdocTypeAny: [],
          JsdocTypeFunction: ["parameters", "returnType"],
          JsdocTypeGeneric: ["left", "elements"],
          JsdocTypeImport: [],
          JsdocTypeIndexSignature: ["right"],
          JsdocTypeIntersection: ["elements"],
          JsdocTypeKeyof: ["element"],
          JsdocTypeKeyValue: ["right"],
          JsdocTypeMappedType: ["right"],
          JsdocTypeName: [],
          JsdocTypeNamePath: ["left", "right"],
          JsdocTypeNotNullable: ["element"],
          JsdocTypeNull: [],
          JsdocTypeNullable: ["element"],
          JsdocTypeNumber: [],
          JsdocTypeObject: ["elements"],
          JsdocTypeObjectField: ["right"],
          JsdocTypeJsdocObjectField: ["left", "right"],
          JsdocTypeOptional: ["element"],
          JsdocTypeParenthesis: ["element"],
          JsdocTypeSpecialNamePath: [],
          JsdocTypeStringValue: [],
          JsdocTypeSymbol: ["element"],
          JsdocTypeTuple: ["elements"],
          JsdocTypeTypeof: ["element"],
          JsdocTypeUndefined: [],
          JsdocTypeUnion: ["elements"],
          JsdocTypeUnknown: [],
          JsdocTypeVariadic: ["element"],
          JsdocTypeProperty: [],
          JsdocTypePredicate: ["left", "right"],
          JsdocTypeAsserts: ["left", "right"],
          JsdocTypeReadonlyArray: ["element"],
          JsdocTypeAssertsPlain: ["element"],
          JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
          JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
        };
        function _traverse(node, parentNode, property, onEnter, onLeave) {
          onEnter?.(node, parentNode, property);
          let keysToVisit = visitorKeys[node.type];
          for (let key of keysToVisit) {
            let value2 = node[key];
            if (value2 !== void 0)
              if (Array.isArray(value2))
                for (let element of value2)
                  _traverse(element, node, key, onEnter, onLeave);
              else
                _traverse(value2, node, key, onEnter, onLeave);
          }
          onLeave?.(node, parentNode, property);
        }
        __name(_traverse, "_traverse");
        function traverse(node, onEnter, onLeave) {
          _traverse(node, void 0, void 0, onEnter, onLeave);
        }
        __name(traverse, "traverse"), exports2.catharsisTransform = catharsisTransform, exports2.identityTransformRules = identityTransformRules, exports2.jtpTransform = jtpTransform, exports2.parse = parse33, exports2.stringify = stringify22, exports2.stringifyRules = stringifyRules2, exports2.transform = transform, exports2.traverse = traverse, exports2.tryParse = tryParse, exports2.visitorKeys = visitorKeys;
      });
    }
  }), isLiteral = __name((type) => type.name === "literal", "isLiteral"), toEnumOption = __name((element) => element.value.replace(/['|"]/g, ""), "toEnumOption"), convertSig = __name((type) => {
    switch (type.type) {
      case "function":
        return { name: "function" };
      case "object":
        let values = {};
        return type.signature.properties.forEach((prop) => {
          values[prop.key] = convert2(prop.value);
        }), {
          name: "object",
          value: values
        };
      default:
        throw new UnknownArgTypesError({ type, language: "Flow" });
    }
  }, "convertSig"), convert2 = __name((type) => {
    let { name, raw } = type, base = {};
    switch (typeof raw < "u" && (base.raw = raw), type.name) {
      case "literal":
        return { ...base, name: "other", value: type.value };
      case "string":
      case "number":
      case "symbol":
      case "boolean":
        return { ...base, name };
      case "Array":
        return { ...base, name: "array", value: type.elements.map(convert2) };
      case "signature":
        return { ...base, ...convertSig(type) };
      case "union":
        return type.elements?.every(isLiteral) ? { ...base, name: "enum", value: type.elements?.map(toEnumOption) } : { ...base, name, value: type.elements?.map(convert2) };
      case "intersection":
        return { ...base, name, value: type.elements?.map(convert2) };
      default:
        return { ...base, name: "other", value: name };
    }
  }, "convert"), QUOTE_REGEX = /^['"]|['"]$/g, trimQuotes = __name((str2) => str2.replace(QUOTE_REGEX, ""), "trimQuotes"), includesQuotes = __name((str2) => QUOTE_REGEX.test(str2), "includesQuotes"), parseLiteral = __name((str2) => {
    let trimmedValue = trimQuotes(str2);
    return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);
  }, "parseLiteral"), SIGNATURE_REGEXP = /^\(.*\) => /, convert22 = __name((type) => {
    let { name, raw, computed, value: value2 } = type, base = {};
    switch (typeof raw < "u" && (base.raw = raw), name) {
      case "enum": {
        let values2 = computed ? value2 : value2.map((v3) => parseLiteral(v3.value));
        return { ...base, name, value: values2 };
      }
      case "string":
      case "number":
      case "symbol":
        return { ...base, name };
      case "func":
        return { ...base, name: "function" };
      case "bool":
      case "boolean":
        return { ...base, name: "boolean" };
      case "arrayOf":
      case "array":
        return { ...base, name: "array", value: value2 && convert22(value2) };
      case "object":
        return { ...base, name };
      case "objectOf":
        return { ...base, name, value: convert22(value2) };
      case "shape":
      case "exact":
        let values = mapValues(value2, (field) => convert22(field));
        return { ...base, name: "object", value: values };
      case "union":
        return { ...base, name: "union", value: value2.map((v3) => convert22(v3)) };
      case "instanceOf":
      case "element":
      case "elementType":
      default: {
        if (name?.indexOf("|") > 0)
          try {
            let literalValues = name.split("|").map((v3) => JSON.parse(v3));
            return { ...base, name: "enum", value: literalValues };
          } catch {
          }
        let otherVal = value2 ? `${name}(${value2})` : name, otherName = SIGNATURE_REGEXP.test(name) ? "function" : "other";
        return { ...base, name: otherName, value: otherVal };
      }
    }
  }, "convert"), convertSig2 = __name((type) => {
    switch (type.type) {
      case "function":
        return { name: "function" };
      case "object":
        let values = {};
        return type.signature.properties.forEach((prop) => {
          values[prop.key] = convert3(prop.value);
        }), {
          name: "object",
          value: values
        };
      default:
        throw new UnknownArgTypesError({ type, language: "Typescript" });
    }
  }, "convertSig"), convert3 = __name((type) => {
    let { name, raw } = type, base = {};
    switch (typeof raw < "u" && (base.raw = raw), type.name) {
      case "string":
      case "number":
      case "symbol":
      case "boolean":
        return { ...base, name };
      case "Array":
        return { ...base, name: "array", value: type.elements.map(convert3) };
      case "signature":
        return { ...base, ...convertSig2(type) };
      case "union":
        let result;
        return type.elements?.every((element) => element.name === "literal") ? result = {
          ...base,
          name: "enum",
          // @ts-expect-error fix types
          value: type.elements?.map((v3) => parseLiteral(v3.value))
        } : result = { ...base, name, value: type.elements?.map(convert3) }, result;
      case "intersection":
        return { ...base, name, value: type.elements?.map(convert3) };
      default:
        return { ...base, name: "other", value: name };
    }
  }, "convert"), convert4 = __name((docgenInfo) => {
    let { type, tsType, flowType } = docgenInfo;
    try {
      if (type != null)
        return convert22(type);
      if (tsType != null)
        return convert3(tsType);
      if (flowType != null)
        return convert2(flowType);
    } catch (err) {
      console.error(err);
    }
    return null;
  }, "convert"), TypeSystem = ((TypeSystem2) => (TypeSystem2.JAVASCRIPT = "JavaScript", TypeSystem2.FLOW = "Flow", TypeSystem2.TYPESCRIPT = "TypeScript", TypeSystem2.UNKNOWN = "Unknown", TypeSystem2))(TypeSystem || {}), BLACKLIST = ["null", "undefined"];
  function isDefaultValueBlacklisted(value2) {
    return BLACKLIST.some((x3) => x3 === value2);
  }
  __name(isDefaultValueBlacklisted, "isDefaultValueBlacklisted");
  var str = __name((obj) => {
    if (!obj)
      return "";
    if (typeof obj == "string")
      return obj;
    throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);
  }, "str");
  function hasDocgen(component) {
    return !!component.__docgenInfo;
  }
  __name(hasDocgen, "hasDocgen");
  function isValidDocgenSection(docgenSection) {
    return docgenSection != null && Object.keys(docgenSection).length > 0;
  }
  __name(isValidDocgenSection, "isValidDocgenSection");
  function getDocgenSection(component, section) {
    return hasDocgen(component) ? component.__docgenInfo[section] : null;
  }
  __name(getDocgenSection, "getDocgenSection");
  function getDocgenDescription(component) {
    return hasDocgen(component) ? str(component.__docgenInfo.description) : "";
  }
  __name(getDocgenDescription, "getDocgenDescription");
  var Markers;
  (function(Markers2) {
    Markers2.start = "/**", Markers2.nostart = "/***", Markers2.delim = "*", Markers2.end = "*/";
  })(Markers = Markers || (Markers = {}));
  function isSpace(source) {
    return /^\s+$/.test(source);
  }
  __name(isSpace, "isSpace");
  function splitCR(source) {
    let matches3 = source.match(/\r+$/);
    return matches3 == null ? ["", source] : [source.slice(-matches3[0].length), source.slice(0, -matches3[0].length)];
  }
  __name(splitCR, "splitCR");
  function splitSpace(source) {
    let matches3 = source.match(/^\s+/);
    return matches3 == null ? ["", source] : [source.slice(0, matches3[0].length), source.slice(matches3[0].length)];
  }
  __name(splitSpace, "splitSpace");
  function splitLines(source) {
    return source.split(/\n/);
  }
  __name(splitLines, "splitLines");
  function seedSpec(spec = {}) {
    return Object.assign({ tag: "", name: "", type: "", optional: !1, description: "", problems: [], source: [] }, spec);
  }
  __name(seedSpec, "seedSpec");
  function seedTokens(tokens = {}) {
    return Object.assign({ start: "", delimiter: "", postDelimiter: "", tag: "", postTag: "", name: "", postName: "", type: "", postType: "", description: "", end: "", lineEnd: "" }, tokens);
  }
  __name(seedTokens, "seedTokens");
  var reTag = /^@\S+/;
  function getParser({ fence = "```" } = {}) {
    let fencer = getFencer(fence), toggleFence = __name((source, isFenced) => fencer(source) ? !isFenced : isFenced, "toggleFence");
    return __name(function(source) {
      let sections = [[]], isFenced = !1;
      for (let line of source)
        reTag.test(line.tokens.description) && !isFenced ? sections.push([line]) : sections[sections.length - 1].push(line), isFenced = toggleFence(line.tokens.description, isFenced);
      return sections;
    }, "parseBlock");
  }
  __name(getParser, "getParser");
  function getFencer(fence) {
    return typeof fence == "string" ? (source) => source.split(fence).length % 2 === 0 : fence;
  }
  __name(getFencer, "getFencer");
  function getParser2({ startLine = 0, markers = Markers } = {}) {
    let block = null, num = startLine;
    return __name(function(source) {
      let rest = source, tokens = seedTokens();
      if ([tokens.lineEnd, rest] = splitCR(rest), [tokens.start, rest] = splitSpace(rest), block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart) && (block = [], tokens.delimiter = rest.slice(0, markers.start.length), rest = rest.slice(markers.start.length), [tokens.postDelimiter, rest] = splitSpace(rest)), block === null)
        return num++, null;
      let isClosed = rest.trimRight().endsWith(markers.end);
      if (tokens.delimiter === "" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end) && (tokens.delimiter = markers.delim, rest = rest.slice(markers.delim.length), [tokens.postDelimiter, rest] = splitSpace(rest)), isClosed) {
        let trimmed = rest.trimRight();
        tokens.end = rest.slice(trimmed.length - markers.end.length), rest = trimmed.slice(0, -markers.end.length);
      }
      if (tokens.description = rest, block.push({ number: num, source, tokens }), num++, isClosed) {
        let result = block.slice();
        return block = null, result;
      }
      return null;
    }, "parseSource");
  }
  __name(getParser2, "getParser");
  function getParser3({ tokenizers }) {
    return __name(function(source) {
      var _a;
      let spec = seedSpec({ source });
      for (let tokenize of tokenizers)
        if (spec = tokenize(spec), !((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0) && _a.critical)
          break;
      return spec;
    }, "parseSpec");
  }
  __name(getParser3, "getParser");
  function tagTokenizer() {
    return (spec) => {
      let { tokens } = spec.source[0], match = tokens.description.match(/\s*(@(\S+))(\s*)/);
      return match === null ? (spec.problems.push({
        code: "spec:tag:prefix",
        message: 'tag should start with "@" symbol',
        line: spec.source[0].number,
        critical: !0
      }), spec) : (tokens.tag = match[1], tokens.postTag = match[3], tokens.description = tokens.description.slice(match[0].length), spec.tag = match[2], spec);
    };
  }
  __name(tagTokenizer, "tagTokenizer");
  function typeTokenizer(spacing = "compact") {
    let join2 = getJoiner(spacing);
    return (spec) => {
      let curlies = 0, lines = [];
      for (let [i3, { tokens }] of spec.source.entries()) {
        let type = "";
        if (i3 === 0 && tokens.description[0] !== "{")
          return spec;
        for (let ch of tokens.description)
          if (ch === "{" && curlies++, ch === "}" && curlies--, type += ch, curlies === 0)
            break;
        if (lines.push([tokens, type]), curlies === 0)
          break;
      }
      if (curlies !== 0)
        return spec.problems.push({
          code: "spec:type:unpaired-curlies",
          message: "unpaired curlies",
          line: spec.source[0].number,
          critical: !0
        }), spec;
      let parts = [], offset2 = lines[0][0].postDelimiter.length;
      for (let [i3, [tokens, type]] of lines.entries())
        tokens.type = type, i3 > 0 && (tokens.type = tokens.postDelimiter.slice(offset2) + type, tokens.postDelimiter = tokens.postDelimiter.slice(0, offset2)), [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length)), parts.push(tokens.type);
      return parts[0] = parts[0].slice(1), parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1), spec.type = join2(parts), spec;
    };
  }
  __name(typeTokenizer, "typeTokenizer");
  var trim = __name((x3) => x3.trim(), "trim");
  function getJoiner(spacing) {
    return spacing === "compact" ? (t) => t.map(trim).join("") : spacing === "preserve" ? (t) => t.join(`
`) : spacing;
  }
  __name(getJoiner, "getJoiner");
  var isQuoted = __name((s4) => s4 && s4.startsWith('"') && s4.endsWith('"'), "isQuoted");
  function nameTokenizer() {
    let typeEnd = __name((num, { tokens }, i3) => tokens.type === "" ? num : i3, "typeEnd");
    return (spec) => {
      let { tokens } = spec.source[spec.source.reduce(typeEnd, 0)], source = tokens.description.trimLeft(), quotedGroups = source.split('"');
      if (quotedGroups.length > 1 && quotedGroups[0] === "" && quotedGroups.length % 2 === 1)
        return spec.name = quotedGroups[1], tokens.name = `"${quotedGroups[1]}"`, [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;
      let brackets = 0, name = "", optional = !1, defaultValue;
      for (let ch of source) {
        if (brackets === 0 && isSpace(ch))
          break;
        ch === "[" && brackets++, ch === "]" && brackets--, name += ch;
      }
      if (brackets !== 0)
        return spec.problems.push({
          code: "spec:name:unpaired-brackets",
          message: "unpaired brackets",
          line: spec.source[0].number,
          critical: !0
        }), spec;
      let nameToken = name;
      if (name[0] === "[" && name[name.length - 1] === "]") {
        optional = !0, name = name.slice(1, -1);
        let parts = name.split("=");
        if (name = parts[0].trim(), parts[1] !== void 0 && (defaultValue = parts.slice(1).join("=").trim()), name === "")
          return spec.problems.push({
            code: "spec:name:empty-name",
            message: "empty name",
            line: spec.source[0].number,
            critical: !0
          }), spec;
        if (defaultValue === "")
          return spec.problems.push({
            code: "spec:name:empty-default",
            message: "empty default value",
            line: spec.source[0].number,
            critical: !0
          }), spec;
        if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue))
          return spec.problems.push({
            code: "spec:name:invalid-default",
            message: "invalid default value syntax",
            line: spec.source[0].number,
            critical: !0
          }), spec;
      }
      return spec.optional = optional, spec.name = name, tokens.name = nameToken, defaultValue !== void 0 && (spec.default = defaultValue), [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length)), spec;
    };
  }
  __name(nameTokenizer, "nameTokenizer");
  function descriptionTokenizer(spacing = "compact", markers = Markers) {
    let join2 = getJoiner2(spacing);
    return (spec) => (spec.description = join2(spec.source, markers), spec);
  }
  __name(descriptionTokenizer, "descriptionTokenizer");
  function getJoiner2(spacing) {
    return spacing === "compact" ? compactJoiner : spacing === "preserve" ? preserveJoiner : spacing;
  }
  __name(getJoiner2, "getJoiner");
  function compactJoiner(lines, markers = Markers) {
    return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== "").join(" ");
  }
  __name(compactJoiner, "compactJoiner");
  var lineNo = __name((num, { tokens }, i3) => tokens.type === "" ? num : i3, "lineNo"), getDescription = __name(({ tokens }) => (tokens.delimiter === "" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description, "getDescription");
  function preserveJoiner(lines, markers = Markers) {
    if (lines.length === 0)
      return "";
    lines[0].tokens.description === "" && lines[0].tokens.delimiter === markers.start && (lines = lines.slice(1));
    let lastLine = lines[lines.length - 1];
    return lastLine !== void 0 && lastLine.tokens.description === "" && lastLine.tokens.end.endsWith(markers.end) && (lines = lines.slice(0, -1)), lines = lines.slice(lines.reduce(lineNo, 0)), lines.map(getDescription).join(`
`);
  }
  __name(preserveJoiner, "preserveJoiner");
  function getParser4({ startLine = 0, fence = "```", spacing = "compact", markers = Markers, tokenizers = [
    tagTokenizer(),
    typeTokenizer(spacing),
    nameTokenizer(),
    descriptionTokenizer(spacing)
  ] } = {}) {
    if (startLine < 0 || startLine % 1 > 0)
      throw new Error("Invalid startLine");
    let parseSource = getParser2({ startLine, markers }), parseBlock = getParser({ fence }), parseSpec = getParser3({ tokenizers }), joinDescription = getJoiner2(spacing);
    return function(source) {
      let blocks = [];
      for (let line of splitLines(source)) {
        let lines = parseSource(line);
        if (lines === null)
          continue;
        let sections = parseBlock(lines), specs = sections.slice(1).map(parseSpec);
        blocks.push({
          description: joinDescription(sections[0], markers),
          tags: specs,
          source: lines,
          problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])
        });
      }
      return blocks;
    };
  }
  __name(getParser4, "getParser");
  function join(tokens) {
    return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;
  }
  __name(join, "join");
  function getStringifier() {
    return (block) => block.source.map(({ tokens }) => join(tokens)).join(`
`);
  }
  __name(getStringifier, "getStringifier");
  var zeroWidth = {
    line: 0,
    start: 0,
    delimiter: 0,
    postDelimiter: 0,
    tag: 0,
    postTag: 0,
    name: 0,
    postName: 0,
    type: 0,
    postType: 0,
    description: 0,
    end: 0,
    lineEnd: 0
  }, fields = Object.keys(zeroWidth);
  function parse(source, options = {}) {
    return getParser4(options)(source);
  }
  __name(parse, "parse");
  var stringify = getStringifier(), import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);
  function containsJsDoc(value2) {
    return value2 != null && value2.includes("@");
  }
  __name(containsJsDoc, "containsJsDoc");
  function parse2(content) {
    let normalisedContent = `/**
` + (content ?? "").split(`
`).map((line) => ` * ${line}`).join(`
`) + `
*/`, ast = parse(normalisedContent, {
      spacing: "preserve"
    });
    if (!ast || ast.length === 0)
      throw new Error("Cannot parse JSDoc tags.");
    return ast[0];
  }
  __name(parse2, "parse");
  var DEFAULT_OPTIONS = {
    tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
  }, parseJsDoc = __name((value2, options = DEFAULT_OPTIONS) => {
    if (!containsJsDoc(value2))
      return {
        includesJsDoc: !1,
        ignore: !1
      };
    let jsDocAst = parse2(value2), extractedTags = extractJsDocTags(jsDocAst, options.tags);
    return extractedTags.ignore ? {
      includesJsDoc: !0,
      ignore: !0
    } : {
      includesJsDoc: !0,
      ignore: !1,
      // Always use the parsed description to ensure JSDoc is removed from the description.
      description: jsDocAst.description.trim(),
      extractedTags
    };
  }, "parseJsDoc");
  function extractJsDocTags(ast, tags) {
    let extractedTags = {
      params: null,
      deprecated: null,
      returns: null,
      ignore: !1
    };
    for (let tagSpec of ast.tags)
      if (!(tags !== void 0 && !tags.includes(tagSpec.tag)))
        if (tagSpec.tag === "ignore") {
          extractedTags.ignore = !0;
          break;
        } else
          switch (tagSpec.tag) {
            // arg & argument are aliases for param.
            case "param":
            case "arg":
            case "argument": {
              let paramTag = extractParam(tagSpec);
              paramTag != null && (extractedTags.params == null && (extractedTags.params = []), extractedTags.params.push(paramTag));
              break;
            }
            case "deprecated": {
              let deprecatedTag = extractDeprecated(tagSpec);
              deprecatedTag != null && (extractedTags.deprecated = deprecatedTag);
              break;
            }
            case "returns": {
              let returnsTag = extractReturns(tagSpec);
              returnsTag != null && (extractedTags.returns = returnsTag);
              break;
            }
            default:
              break;
          }
    return extractedTags;
  }
  __name(extractJsDocTags, "extractJsDocTags");
  function normaliseParamName(name) {
    return name.replace(/[\.-]$/, "");
  }
  __name(normaliseParamName, "normaliseParamName");
  function extractParam(tag) {
    if (!tag.name || tag.name === "-")
      return null;
    let type = extractType(tag.type);
    return {
      name: tag.name,
      type,
      description: normaliseDescription(tag.description),
      getPrettyName: __name(() => normaliseParamName(tag.name), "getPrettyName"),
      getTypeName: __name(() => type ? extractTypeName(type) : null, "getTypeName")
    };
  }
  __name(extractParam, "extractParam");
  function extractDeprecated(tag) {
    return tag.name ? joinNameAndDescription(tag.name, tag.description) : null;
  }
  __name(extractDeprecated, "extractDeprecated");
  function joinNameAndDescription(name, desc) {
    let joined = name === "" ? desc : `${name} ${desc}`;
    return normaliseDescription(joined);
  }
  __name(joinNameAndDescription, "joinNameAndDescription");
  function normaliseDescription(text) {
    let normalised = text.replace(/^- /g, "").trim();
    return normalised === "" ? null : normalised;
  }
  __name(normaliseDescription, "normaliseDescription");
  function extractReturns(tag) {
    let type = extractType(tag.type);
    return type ? {
      type,
      description: joinNameAndDescription(tag.name, tag.description),
      getTypeName: __name(() => extractTypeName(type), "getTypeName")
    } : null;
  }
  __name(extractReturns, "extractReturns");
  var jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)(), originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;
  jsdocStringifyRules.JsdocTypeAny = () => "any";
  jsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;
  jsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);
  jsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join("|");
  function extractType(typeString) {
    try {
      return (0, import_jsdoc_type_pratt_parser.parse)(typeString, "typescript");
    } catch {
      return null;
    }
  }
  __name(extractType, "extractType");
  function extractTypeName(type) {
    return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);
  }
  __name(extractTypeName, "extractTypeName");
  var MAX_TYPE_SUMMARY_LENGTH = 90, MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;
  function isTooLongForTypeSummary(value2) {
    return value2.length > MAX_TYPE_SUMMARY_LENGTH;
  }
  __name(isTooLongForTypeSummary, "isTooLongForTypeSummary");
  function isTooLongForDefaultValueSummary(value2) {
    return value2.length > MAX_DEFAULT_VALUE_SUMMARY_LENGTH;
  }
  __name(isTooLongForDefaultValueSummary, "isTooLongForDefaultValueSummary");
  function createSummaryValue(summary, detail) {
    return summary === detail ? { summary } : { summary, detail };
  }
  __name(createSummaryValue, "createSummaryValue");
  var normalizeNewlines = __name((string) => string.replace(/\\r\\n/g, "\\n"), "normalizeNewlines");
  function createDefaultValue(defaultValue, type) {
    if (defaultValue != null) {
      let { value: value2 } = defaultValue;
      if (!isDefaultValueBlacklisted(value2))
        return isTooLongForDefaultValueSummary(value2) ? createSummaryValue(type?.name, value2) : createSummaryValue(value2);
    }
    return null;
  }
  __name(createDefaultValue, "createDefaultValue");
  function generateUnionElement({ name, value: value2, elements, raw }) {
    return value2 ?? (elements != null ? elements.map(generateUnionElement).join(" | ") : raw ?? name);
  }
  __name(generateUnionElement, "generateUnionElement");
  function generateUnion({ name, raw, elements }) {
    return elements != null ? createSummaryValue(elements.map(generateUnionElement).join(" | ")) : raw != null ? createSummaryValue(raw.replace(/^\|\s*/, "")) : createSummaryValue(name);
  }
  __name(generateUnion, "generateUnion");
  function generateFuncSignature({ type, raw }) {
    return raw != null ? createSummaryValue(raw) : createSummaryValue(type);
  }
  __name(generateFuncSignature, "generateFuncSignature");
  function generateObjectSignature({ type, raw }) {
    return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(type, raw) : createSummaryValue(raw) : createSummaryValue(type);
  }
  __name(generateObjectSignature, "generateObjectSignature");
  function generateSignature(flowType) {
    let { type } = flowType;
    return type === "object" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);
  }
  __name(generateSignature, "generateSignature");
  function generateDefault({ name, raw }) {
    return raw != null ? isTooLongForTypeSummary(raw) ? createSummaryValue(name, raw) : createSummaryValue(raw) : createSummaryValue(name);
  }
  __name(generateDefault, "generateDefault");
  function createType(type) {
    if (type == null)
      return null;
    switch (type.name) {
      case "union":
        return generateUnion(type);
      case "signature":
        return generateSignature(type);
      default:
        return generateDefault(type);
    }
  }
  __name(createType, "createType");
  var createFlowPropDef = __name((propName, docgenInfo) => {
    let { flowType, description, required, defaultValue } = docgenInfo;
    return {
      name: propName,
      type: createType(flowType),
      required,
      description,
      defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)
    };
  }, "createFlowPropDef");
  function createDefaultValue2({ defaultValue }) {
    if (defaultValue != null) {
      let { value: value2 } = defaultValue;
      if (!isDefaultValueBlacklisted(value2))
        return createSummaryValue(value2);
    }
    return null;
  }
  __name(createDefaultValue2, "createDefaultValue");
  function createType2({ tsType, required }) {
    if (tsType == null)
      return null;
    let typeName = tsType.name;
    return required || (typeName = typeName.replace(" | undefined", "")), createSummaryValue(
      ["Array", "Record", "signature"].includes(tsType.name) ? tsType.raw : typeName
    );
  }
  __name(createType2, "createType");
  var createTsPropDef = __name((propName, docgenInfo) => {
    let { description, required } = docgenInfo;
    return {
      name: propName,
      type: createType2(docgenInfo),
      required,
      description,
      defaultValue: createDefaultValue2(docgenInfo)
    };
  }, "createTsPropDef");
  function createType3(type) {
    return type != null ? createSummaryValue(type.name) : null;
  }
  __name(createType3, "createType");
  function isReactDocgenTypescript(defaultValue) {
    let { computed, func } = defaultValue;
    return typeof computed > "u" && typeof func > "u";
  }
  __name(isReactDocgenTypescript, "isReactDocgenTypescript");
  function isStringValued(type) {
    return type ? type.name === "string" ? !0 : type.name === "enum" ? Array.isArray(type.value) && type.value.every(
      ({ value: tv }) => typeof tv == "string" && tv[0] === '"' && tv[tv.length - 1] === '"'
    ) : !1 : !1;
  }
  __name(isStringValued, "isStringValued");
  function createDefaultValue3(defaultValue, type) {
    if (defaultValue != null) {
      let { value: value2 } = defaultValue;
      if (!isDefaultValueBlacklisted(value2))
        return isReactDocgenTypescript(defaultValue) && isStringValued(type) ? createSummaryValue(JSON.stringify(value2)) : createSummaryValue(value2);
    }
    return null;
  }
  __name(createDefaultValue3, "createDefaultValue");
  function createBasicPropDef(name, type, docgenInfo) {
    let { description, required, defaultValue } = docgenInfo;
    return {
      name,
      type: createType3(type),
      required,
      description,
      defaultValue: createDefaultValue3(defaultValue, type)
    };
  }
  __name(createBasicPropDef, "createBasicPropDef");
  function applyJsDocResult(propDef, jsDocParsingResult) {
    if (jsDocParsingResult?.includesJsDoc) {
      let { description, extractedTags } = jsDocParsingResult;
      description != null && (propDef.description = jsDocParsingResult.description);
      let value2 = {
        ...extractedTags,
        params: extractedTags?.params?.map(
          (x3) => ({
            name: x3.getPrettyName(),
            description: x3.description
          })
        )
      };
      Object.values(value2).filter(Boolean).length > 0 && (propDef.jsDocTags = value2);
    }
    return propDef;
  }
  __name(applyJsDocResult, "applyJsDocResult");
  var javaScriptFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
    let propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);
    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
  }, "javaScriptFactory"), tsFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
    let propDef = createTsPropDef(propName, docgenInfo);
    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
  }, "tsFactory"), flowFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
    let propDef = createFlowPropDef(propName, docgenInfo);
    return propDef.sbType = convert4(docgenInfo), applyJsDocResult(propDef, jsDocParsingResult);
  }, "flowFactory"), unknownFactory = __name((propName, docgenInfo, jsDocParsingResult) => {
    let propDef = createBasicPropDef(propName, { name: "unknown" }, docgenInfo);
    return applyJsDocResult(propDef, jsDocParsingResult);
  }, "unknownFactory"), getPropDefFactory = __name((typeSystem) => {
    switch (typeSystem) {
      case "JavaScript":
        return javaScriptFactory;
      case "TypeScript":
        return tsFactory;
      case "Flow":
        return flowFactory;
      default:
        return unknownFactory;
    }
  }, "getPropDefFactory"), getTypeSystem = __name((docgenInfo) => docgenInfo.type != null ? "JavaScript" : docgenInfo.flowType != null ? "Flow" : docgenInfo.tsType != null ? "TypeScript" : "Unknown", "getTypeSystem"), extractComponentSectionArray = __name((docgenSection) => {
    let typeSystem = getTypeSystem(docgenSection[0]), createPropDef = getPropDefFactory(typeSystem);
    return docgenSection.map((item) => {
      let sanitizedItem = item;
      return item.type?.elements && (sanitizedItem = {
        ...item,
        type: {
          ...item.type,
          value: item.type.elements
        }
      }), extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);
    });
  }, "extractComponentSectionArray"), extractComponentSectionObject = __name((docgenSection) => {
    let docgenPropsKeys = Object.keys(docgenSection), typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]), createPropDef = getPropDefFactory(typeSystem);
    return docgenPropsKeys.map((propName) => {
      let docgenInfo = docgenSection[propName];
      return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;
    }).filter(Boolean);
  }, "extractComponentSectionObject"), extractComponentProps = __name((component, section) => {
    let docgenSection = getDocgenSection(component, section);
    return isValidDocgenSection(docgenSection) ? Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection) : [];
  }, "extractComponentProps");
  function extractProp(propName, docgenInfo, typeSystem, createPropDef) {
    let jsDocParsingResult = parseJsDoc(docgenInfo.description);
    return jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore ? null : {
      propDef: createPropDef(propName, docgenInfo, jsDocParsingResult),
      jsDocTags: jsDocParsingResult.extractedTags,
      docgenInfo,
      typeSystem
    };
  }
  __name(extractProp, "extractProp");
  function extractComponentDescription(component) {
    return component != null ? getDocgenDescription(component) : "";
  }
  __name(extractComponentDescription, "extractComponentDescription");
  var combineParameters2 = __name((...parameterSets) => {
    let mergeKeys = {}, definedParametersSets = parameterSets.filter(Boolean), combined = definedParametersSets.reduce((acc, parameters2) => (Object.entries(parameters2).forEach(([key, value2]) => {
      let existing = acc[key];
      Array.isArray(value2) || typeof existing > "u" ? acc[key] = value2 : isPlainObject(value2) && isPlainObject(existing) ? mergeKeys[key] = !0 : typeof value2 < "u" && (acc[key] = value2);
    }), acc), {});
    return Object.keys(mergeKeys).forEach((key) => {
      let mergeValues = definedParametersSets.filter(Boolean).map((p4) => p4[key]).filter((value2) => typeof value2 < "u");
      mergeValues.every((value2) => isPlainObject(value2)) ? combined[key] = combineParameters2(...mergeValues) : combined[key] = mergeValues[mergeValues.length - 1];
    }), combined;
  }, "combineParameters"), enhanceArgTypes = __name((context) => {
    let {
      component,
      argTypes: userArgTypes,
      parameters: { docs = {} }
    } = context, { extractArgTypes } = docs;
    if (!extractArgTypes || !component)
      return userArgTypes;
    let extractedArgTypes = extractArgTypes(component);
    return extractedArgTypes ? combineParameters2(extractedArgTypes, userArgTypes) : userArgTypes;
  }, "enhanceArgTypes"), ADDON_ID6 = "storybook/docs", PANEL_ID3 = `${ADDON_ID6}/panel`;
  var SNIPPET_RENDERED = `${ADDON_ID6}/snippet-rendered`, SourceType = ((SourceType2) => (SourceType2.AUTO = "auto", SourceType2.CODE = "code", SourceType2.DYNAMIC = "dynamic", SourceType2))(SourceType || {});

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-ZNRFDIVA.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_AB7OOPUX();
  init_chunk_MM7DTO55();
  function eq(value2, other) {
    return value2 === other || Number.isNaN(value2) && Number.isNaN(other);
  }
  __name(eq, "eq");
  function isEqualWith(a3, b3, areValuesEqual) {
    return isEqualWithImpl(a3, b3, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  __name(isEqualWith, "isEqualWith");
  function isEqualWithImpl(a3, b3, property, aParent, bParent, stack, areValuesEqual) {
    let result = areValuesEqual(a3, b3, property, aParent, bParent, stack);
    if (result !== void 0)
      return result;
    if (typeof a3 == typeof b3)
      switch (typeof a3) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined":
          return a3 === b3;
        case "number":
          return a3 === b3 || Object.is(a3, b3);
        case "function":
          return a3 === b3;
        case "object":
          return areObjectsEqual(a3, b3, stack, areValuesEqual);
      }
    return areObjectsEqual(a3, b3, stack, areValuesEqual);
  }
  __name(isEqualWithImpl, "isEqualWithImpl");
  function areObjectsEqual(a3, b3, stack, areValuesEqual) {
    if (Object.is(a3, b3))
      return !0;
    let aTag = getTag(a3), bTag = getTag(b3);
    if (aTag === argumentsTag && (aTag = objectTag), bTag === argumentsTag && (bTag = objectTag), aTag !== bTag)
      return !1;
    switch (aTag) {
      case stringTag:
        return a3.toString() === b3.toString();
      case numberTag: {
        let x3 = a3.valueOf(), y3 = b3.valueOf();
        return eq(x3, y3);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a3.valueOf(), b3.valueOf());
      case regexpTag:
        return a3.source === b3.source && a3.flags === b3.flags;
      case functionTag:
        return a3 === b3;
    }
    stack = stack ?? /* @__PURE__ */ new Map();
    let aStack = stack.get(a3), bStack = stack.get(b3);
    if (aStack != null && bStack != null)
      return aStack === b3;
    stack.set(a3, b3), stack.set(b3, a3);
    try {
      switch (aTag) {
        case mapTag: {
          if (a3.size !== b3.size)
            return !1;
          for (let [key, value2] of a3.entries())
            if (!b3.has(key) || !isEqualWithImpl(value2, b3.get(key), key, a3, b3, stack, areValuesEqual))
              return !1;
          return !0;
        }
        case setTag: {
          if (a3.size !== b3.size)
            return !1;
          let aValues = Array.from(a3.values()), bValues = Array.from(b3.values());
          for (let i3 = 0; i3 < aValues.length; i3++) {
            let aValue = aValues[i3], index2 = bValues.findIndex((bValue) => isEqualWithImpl(aValue, bValue, void 0, a3, b3, stack, areValuesEqual));
            if (index2 === -1)
              return !1;
            bValues.splice(index2, 1);
          }
          return !0;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer < "u" && Buffer.isBuffer(a3) !== Buffer.isBuffer(b3) || a3.length !== b3.length)
            return !1;
          for (let i3 = 0; i3 < a3.length; i3++)
            if (!isEqualWithImpl(a3[i3], b3[i3], i3, a3, b3, stack, areValuesEqual))
              return !1;
          return !0;
        }
        case arrayBufferTag:
          return a3.byteLength !== b3.byteLength ? !1 : areObjectsEqual(new Uint8Array(a3), new Uint8Array(b3), stack, areValuesEqual);
        case dataViewTag:
          return a3.byteLength !== b3.byteLength || a3.byteOffset !== b3.byteOffset ? !1 : areObjectsEqual(new Uint8Array(a3), new Uint8Array(b3), stack, areValuesEqual);
        case errorTag:
          return a3.name === b3.name && a3.message === b3.message;
        case objectTag: {
          if (!(areObjectsEqual(a3.constructor, b3.constructor, stack, areValuesEqual) || isPlainObject(a3) && isPlainObject(b3)))
            return !1;
          let aKeys = [...Object.keys(a3), ...getSymbols(a3)], bKeys = [...Object.keys(b3), ...getSymbols(b3)];
          if (aKeys.length !== bKeys.length)
            return !1;
          for (let i3 = 0; i3 < aKeys.length; i3++) {
            let propKey = aKeys[i3], aProp = a3[propKey];
            if (!Object.hasOwn(b3, propKey))
              return !1;
            let bProp = b3[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a3, b3, stack, areValuesEqual))
              return !1;
          }
          return !0;
        }
        default:
          return !1;
      }
    } finally {
      stack.delete(a3), stack.delete(b3);
    }
  }
  __name(areObjectsEqual, "areObjectsEqual");
  function isEqual(a3, b3) {
    return isEqualWith(a3, b3, noop);
  }
  __name(isEqual, "isEqual");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-FUOHXXZT.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var isProduction = !1, prefix = "Invariant failed";
  function invariant(condition, message) {
    if (!condition) {
      if (isProduction)
        throw new Error(prefix);
      var provided = typeof message == "function" ? message() : message, value2 = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value2);
    }
  }
  __name(invariant, "invariant");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-RW5PKMWM.js
  init_chunk_MM7DTO55();

  // global-externals:storybook/internal/channels
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var channels_default = __STORYBOOK_CHANNELS__, { Channel, HEARTBEAT_INTERVAL, HEARTBEAT_MAX_LATENCY, PostMessageTransport, WebsocketTransport, createBrowserChannel } = __STORYBOOK_CHANNELS__;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-RW5PKMWM.js
  function mockChannel2() {
    let transport = {
      setHandler: __name(() => {
      }, "setHandler"),
      send: __name(() => {
      }, "send")
    };
    return new Channel({ transport });
  }
  __name(mockChannel2, "mockChannel");
  var _AddonStore = class {
    constructor() {
      this.getChannel = __name(() => {
        if (!this.channel) {
          let channel = mockChannel2();
          return this.setChannel(channel), channel;
        }
        return this.channel;
      }, "getChannel"), this.ready = __name(() => this.promise, "ready"), this.hasChannel = __name(() => !!this.channel, "hasChannel"), this.setChannel = __name((channel) => {
        this.channel = channel, this.resolve();
      }, "setChannel"), this.promise = new Promise((res) => {
        this.resolve = () => res(this.getChannel());
      });
    }
  };
  __name(_AddonStore, "AddonStore");
  var AddonStore = _AddonStore, KEY = "__STORYBOOK_ADDONS_PREVIEW";
  function getAddonsStore() {
    return scope[KEY] || (scope[KEY] = new AddonStore()), scope[KEY];
  }
  __name(getAddonsStore, "getAddonsStore");
  var addons2 = getAddonsStore(), _HooksContext = class {
    constructor() {
      this.hookListsMap = void 0, this.mountedDecorators = void 0, this.prevMountedDecorators = void 0, this.currentHooks = void 0, this.nextHookIndex = void 0, this.currentPhase = void 0, this.currentEffects = void 0, this.prevEffects = void 0, this.currentDecoratorName = void 0, this.hasUpdates = void 0, this.currentContext = void 0, this.renderListener = __name((storyId) => {
        storyId === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
      }, "renderListener"), this.init();
    }
    init() {
      this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = !1, this.currentContext = null;
    }
    clean() {
      this.prevEffects.forEach((effect) => {
        effect.destroy && effect.destroy();
      }), this.init(), this.removeRenderListeners();
    }
    getNextHook() {
      let hook = this.currentHooks[this.nextHookIndex];
      return this.nextHookIndex += 1, hook;
    }
    triggerEffects() {
      this.prevEffects.forEach((effect) => {
        !this.currentEffects.includes(effect) && effect.destroy && effect.destroy();
      }), this.currentEffects.forEach((effect) => {
        this.prevEffects.includes(effect) || (effect.destroy = effect.create());
      }), this.prevEffects = this.currentEffects, this.currentEffects = [];
    }
    addRenderListeners() {
      this.removeRenderListeners(), addons2.getChannel().on(STORY_RENDERED, this.renderListener);
    }
    removeRenderListeners() {
      addons2.getChannel().removeListener(STORY_RENDERED, this.renderListener);
    }
  };
  __name(_HooksContext, "HooksContext");
  var HooksContext = _HooksContext;
  function hookify(fn2) {
    let hookified = __name((...args) => {
      let { hooks } = typeof args[0] == "function" ? args[1] : args[0], prevPhase = hooks.currentPhase, prevHooks = hooks.currentHooks, prevNextHookIndex = hooks.nextHookIndex, prevDecoratorName = hooks.currentDecoratorName;
      hooks.currentDecoratorName = fn2.name, hooks.prevMountedDecorators.has(fn2) ? (hooks.currentPhase = "UPDATE", hooks.currentHooks = hooks.hookListsMap.get(fn2) || []) : (hooks.currentPhase = "MOUNT", hooks.currentHooks = [], hooks.hookListsMap.set(fn2, hooks.currentHooks), hooks.prevMountedDecorators.add(fn2)), hooks.nextHookIndex = 0;
      let prevContext = scope.STORYBOOK_HOOKS_CONTEXT;
      scope.STORYBOOK_HOOKS_CONTEXT = hooks;
      let result = fn2(...args);
      if (scope.STORYBOOK_HOOKS_CONTEXT = prevContext, hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null)
        throw new Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      return hooks.currentPhase = prevPhase, hooks.currentHooks = prevHooks, hooks.nextHookIndex = prevNextHookIndex, hooks.currentDecoratorName = prevDecoratorName, result;
    }, "hookified");
    return hookified.originalFn = fn2, hookified;
  }
  __name(hookify, "hookify");
  var numberOfRenders = 0, RENDER_LIMIT = 25, applyHooks = __name((applyDecorators) => (storyFn, decorators4) => {
    let decorated = applyDecorators(
      hookify(storyFn),
      decorators4.map((decorator) => hookify(decorator))
    );
    return (context) => {
      let { hooks } = context;
      hooks.prevMountedDecorators ??= /* @__PURE__ */ new Set(), hooks.mountedDecorators = /* @__PURE__ */ new Set([storyFn, ...decorators4]), hooks.currentContext = context, hooks.hasUpdates = !1;
      let result = decorated(context);
      for (numberOfRenders = 1; hooks.hasUpdates; )
        if (hooks.hasUpdates = !1, hooks.currentEffects = [], result = decorated(context), numberOfRenders += 1, numberOfRenders > RENDER_LIMIT)
          throw new Error(
            "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
          );
      return hooks.addRenderListeners(), result;
    };
  }, "applyHooks"), areDepsEqual = __name((deps, nextDeps) => deps.length === nextDeps.length && deps.every((dep, i3) => dep === nextDeps[i3]), "areDepsEqual"), invalidHooksError = __name(() => new Error("Storybook preview hooks can only be called inside decorators and story functions."), "invalidHooksError");
  function getHooksContextOrNull() {
    return scope.STORYBOOK_HOOKS_CONTEXT || null;
  }
  __name(getHooksContextOrNull, "getHooksContextOrNull");
  function getHooksContextOrThrow() {
    let hooks = getHooksContextOrNull();
    if (hooks == null)
      throw invalidHooksError();
    return hooks;
  }
  __name(getHooksContextOrThrow, "getHooksContextOrThrow");
  function useHook(name, callback, deps) {
    let hooks = getHooksContextOrThrow();
    if (hooks.currentPhase === "MOUNT") {
      deps != null && !Array.isArray(deps) && logger.warn(
        `${name} received a final argument that is not an array (instead, received ${deps}). When specified, the final argument must be an array.`
      );
      let hook = { name, deps };
      return hooks.currentHooks.push(hook), callback(hook), hook;
    }
    if (hooks.currentPhase === "UPDATE") {
      let hook = hooks.getNextHook();
      if (hook == null)
        throw new Error("Rendered more hooks than during the previous render.");
      return hook.name !== name && logger.warn(
        `Storybook has detected a change in the order of Hooks${hooks.currentDecoratorName ? ` called by ${hooks.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
      ), deps != null && hook.deps == null && logger.warn(
        `${name} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
      ), deps != null && hook.deps != null && deps.length !== hook.deps.length && logger.warn(`The final argument passed to ${name} changed size between renders. The order and size of this array must remain constant.
Previous: ${hook.deps}
Incoming: ${deps}`), (deps == null || hook.deps == null || !areDepsEqual(deps, hook.deps)) && (callback(hook), hook.deps = deps), hook;
    }
    throw invalidHooksError();
  }
  __name(useHook, "useHook");
  function useMemoLike(name, nextCreate, deps) {
    let { memoizedState } = useHook(
      name,
      (hook) => {
        hook.memoizedState = nextCreate();
      },
      deps
    );
    return memoizedState;
  }
  __name(useMemoLike, "useMemoLike");
  function useMemo2(nextCreate, deps) {
    return useMemoLike("useMemo", nextCreate, deps);
  }
  __name(useMemo2, "useMemo");
  function useCallback2(callback, deps) {
    return useMemoLike("useCallback", () => callback, deps);
  }
  __name(useCallback2, "useCallback");
  function useRefLike(name, initialValue) {
    return useMemoLike(name, () => ({ current: initialValue }), []);
  }
  __name(useRefLike, "useRefLike");
  function useRef2(initialValue) {
    return useRefLike("useRef", initialValue);
  }
  __name(useRef2, "useRef");
  function triggerUpdate() {
    let hooks = getHooksContextOrNull();
    if (hooks != null && hooks.currentPhase !== "NONE")
      hooks.hasUpdates = !0;
    else
      try {
        addons2.getChannel().emit(FORCE_RE_RENDER);
      } catch {
        logger.warn("State updates of Storybook preview hooks work only in browser");
      }
  }
  __name(triggerUpdate, "triggerUpdate");
  function useStateLike(name, initialState) {
    let stateRef = useRefLike(
      name,
      // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
      typeof initialState == "function" ? initialState() : initialState
    ), setState = __name((update) => {
      stateRef.current = typeof update == "function" ? update(stateRef.current) : update, triggerUpdate();
    }, "setState");
    return [stateRef.current, setState];
  }
  __name(useStateLike, "useStateLike");
  function useState2(initialState) {
    return useStateLike("useState", initialState);
  }
  __name(useState2, "useState");
  function useReducer2(reducer, initialArg, init2) {
    let initialState = init2 != null ? () => init2(initialArg) : initialArg, [state3, setState] = useStateLike("useReducer", initialState), dispatch = __name((action2) => setState((prevState) => reducer(prevState, action2)), "dispatch");
    return [state3, dispatch];
  }
  __name(useReducer2, "useReducer");
  function useEffect2(create2, deps) {
    let hooks = getHooksContextOrThrow(), effect = useMemoLike("useEffect", () => ({ create: create2 }), deps);
    hooks.currentEffects.includes(effect) || hooks.currentEffects.push(effect);
  }
  __name(useEffect2, "useEffect");
  function useChannel2(eventMap, deps = []) {
    let channel = addons2.getChannel();
    return useEffect2(() => (Object.entries(eventMap).forEach(([type, listener]) => channel.on(type, listener)), () => {
      Object.entries(eventMap).forEach(
        ([type, listener]) => channel.removeListener(type, listener)
      );
    }), [...Object.keys(eventMap), ...deps]), useCallback2(channel.emit.bind(channel), [channel]);
  }
  __name(useChannel2, "useChannel");
  function useStoryContext() {
    let { currentContext } = getHooksContextOrThrow();
    if (currentContext == null)
      throw invalidHooksError();
    return currentContext;
  }
  __name(useStoryContext, "useStoryContext");
  function useParameter2(parameterKey, defaultValue) {
    let { parameters: parameters2 } = useStoryContext();
    if (parameterKey)
      return parameters2[parameterKey] ?? defaultValue;
  }
  __name(useParameter2, "useParameter");
  function useArgs2() {
    let channel = addons2.getChannel(), { id: storyId, args } = useStoryContext(), updateArgs = useCallback2(
      (updatedArgs) => channel.emit(UPDATE_STORY_ARGS, { storyId, updatedArgs }),
      [channel, storyId]
    ), resetArgs = useCallback2(
      (argNames) => channel.emit(RESET_STORY_ARGS, { storyId, argNames }),
      [channel, storyId]
    );
    return [args, updateArgs, resetArgs];
  }
  __name(useArgs2, "useArgs");
  function useGlobals2() {
    let channel = addons2.getChannel(), { globals } = useStoryContext(), updateGlobals = useCallback2(
      (newGlobals) => channel.emit(UPDATE_GLOBALS, { globals: newGlobals }),
      [channel]
    );
    return [globals, updateGlobals];
  }
  __name(useGlobals2, "useGlobals");
  var makeDecorator = __name(({
    name,
    parameterName,
    wrapper,
    skipIfNoParametersOrOptions = !1
  }) => {
    let decorator = __name((options) => (storyFn, context) => {
      let parameters2 = context.parameters && context.parameters[parameterName];
      return parameters2 && parameters2.disable || skipIfNoParametersOrOptions && !options && !parameters2 ? storyFn(context) : wrapper(storyFn, context, {
        options,
        parameters: parameters2
      });
    }, "decorator");
    return (...args) => typeof args[0] == "function" ? decorator()(...args) : (...innerArgs) => {
      if (innerArgs.length > 1)
        return args.length > 1 ? decorator(args)(...innerArgs) : decorator(...args)(...innerArgs);
      throw new Error(
        `Passing stories directly into ${name}() is not allowed,
        instead use addDecorator(${name}) and pass options with the '${parameterName}' parameter`
      );
    };
  }, "makeDecorator"), import_memoizerific2 = __toESM(require_memoizerific(), 1), INCOMPATIBLE = Symbol("incompatible"), map = __name((arg, argType) => {
    let type = argType.type;
    if (arg == null || !type || argType.mapping)
      return arg;
    switch (type.name) {
      case "string":
        return String(arg);
      case "enum":
        return arg;
      case "number":
        return Number(arg);
      case "boolean":
        return String(arg) === "true";
      case "array":
        return !type.value || !Array.isArray(arg) ? INCOMPATIBLE : arg.reduce((acc, item, index2) => {
          let mapped = map(item, { type: type.value });
          return mapped !== INCOMPATIBLE && (acc[index2] = mapped), acc;
        }, new Array(arg.length));
      case "object":
        return typeof arg == "string" || typeof arg == "number" ? arg : !type.value || typeof arg != "object" ? INCOMPATIBLE : Object.entries(arg).reduce((acc, [key, val]) => {
          let mapped = map(val, { type: type.value[key] });
          return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
        }, {});
      case "other": {
        let isPrimitiveArg = typeof arg == "string" || typeof arg == "number" || typeof arg == "boolean";
        return type.value === "ReactNode" && isPrimitiveArg ? arg : INCOMPATIBLE;
      }
      default:
        return INCOMPATIBLE;
    }
  }, "map"), mapArgsToTypes = __name((args, argTypes) => Object.entries(args).reduce((acc, [key, value2]) => {
    if (!argTypes[key])
      return acc;
    let mapped = map(value2, argTypes[key]);
    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, { [key]: mapped });
  }, {}), "mapArgsToTypes"), combineArgs = __name((value2, update) => Array.isArray(value2) && Array.isArray(update) ? update.reduce(
    (acc, upd, index2) => (acc[index2] = combineArgs(value2[index2], update[index2]), acc),
    [...value2]
  ).filter((v3) => v3 !== void 0) : !isPlainObject(value2) || !isPlainObject(update) ? update : Object.keys({ ...value2, ...update }).reduce((acc, key) => {
    if (key in update) {
      let combined = combineArgs(value2[key], update[key]);
      combined !== void 0 && (acc[key] = combined);
    } else
      acc[key] = value2[key];
    return acc;
  }, {}), "combineArgs"), validateOptions = __name((args, argTypes) => Object.entries(argTypes).reduce((acc, [key, { options }]) => {
    function allowArg() {
      return key in args && (acc[key] = args[key]), acc;
    }
    if (__name(allowArg, "allowArg"), !options)
      return allowArg();
    if (!Array.isArray(options))
      return once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), allowArg();
    if (options.some((opt) => opt && ["object", "function"].includes(typeof opt)))
      return once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), allowArg();
    let isArray2 = Array.isArray(args[key]), invalidIndex = isArray2 && args[key].findIndex((val) => !options.includes(val)), isValidArray = isArray2 && invalidIndex === -1;
    if (args[key] === void 0 || options.includes(args[key]) || isValidArray)
      return allowArg();
    let field = isArray2 ? `${key}[${invalidIndex}]` : key, supportedOptions = options.map((opt) => typeof opt == "string" ? `'${opt}'` : String(opt)).join(", ");
    return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`), acc;
  }, {}), "validateOptions"), DEEPLY_EQUAL = Symbol("Deeply equal"), deepDiff = __name((value2, update) => {
    if (typeof value2 != typeof update)
      return update;
    if (isEqual(value2, update))
      return DEEPLY_EQUAL;
    if (Array.isArray(value2) && Array.isArray(update)) {
      let res = update.reduce((acc, upd, index2) => {
        let diff2 = deepDiff(value2[index2], upd);
        return diff2 !== DEEPLY_EQUAL && (acc[index2] = diff2), acc;
      }, new Array(update.length));
      return update.length >= value2.length ? res : res.concat(new Array(value2.length - update.length).fill(void 0));
    }
    return isPlainObject(value2) && isPlainObject(update) ? Object.keys({ ...value2, ...update }).reduce((acc, key) => {
      let diff2 = deepDiff(value2?.[key], update?.[key]);
      return diff2 === DEEPLY_EQUAL ? acc : Object.assign(acc, { [key]: diff2 });
    }, {}) : update;
  }, "deepDiff"), UNTARGETED = "UNTARGETED";
  function groupArgsByTarget({
    args,
    argTypes
  }) {
    let groupedArgs = {};
    return Object.entries(args).forEach(([name, value2]) => {
      let { target = UNTARGETED } = argTypes[name] || {};
      groupedArgs[target] = groupedArgs[target] || {}, groupedArgs[target][name] = value2;
    }), groupedArgs;
  }
  __name(groupArgsByTarget, "groupArgsByTarget");
  function deleteUndefined(obj) {
    return Object.keys(obj).forEach((key) => obj[key] === void 0 && delete obj[key]), obj;
  }
  __name(deleteUndefined, "deleteUndefined");
  var _ArgsStore = class {
    constructor() {
      this.initialArgsByStoryId = {}, this.argsByStoryId = {};
    }
    get(storyId) {
      if (!(storyId in this.argsByStoryId))
        throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
      return this.argsByStoryId[storyId];
    }
    setInitial(story) {
      if (!this.initialArgsByStoryId[story.id])
        this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs;
      else if (this.initialArgsByStoryId[story.id] !== story.initialArgs) {
        let delta = deepDiff(this.initialArgsByStoryId[story.id], this.argsByStoryId[story.id]);
        this.initialArgsByStoryId[story.id] = story.initialArgs, this.argsByStoryId[story.id] = story.initialArgs, delta !== DEEPLY_EQUAL && this.updateFromDelta(story, delta);
      }
    }
    updateFromDelta(story, delta) {
      let validatedDelta = validateOptions(delta, story.argTypes);
      this.argsByStoryId[story.id] = combineArgs(this.argsByStoryId[story.id], validatedDelta);
    }
    updateFromPersisted(story, persisted) {
      let mappedPersisted = mapArgsToTypes(persisted, story.argTypes);
      return this.updateFromDelta(story, mappedPersisted);
    }
    update(storyId, argsUpdate) {
      if (!(storyId in this.argsByStoryId))
        throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);
      this.argsByStoryId[storyId] = deleteUndefined({
        ...this.argsByStoryId[storyId],
        ...argsUpdate
      });
    }
  };
  __name(_ArgsStore, "ArgsStore");
  var ArgsStore = _ArgsStore, getValuesFromArgTypes = __name((argTypes = {}) => Object.entries(argTypes).reduce((acc, [arg, { defaultValue }]) => (typeof defaultValue < "u" && (acc[arg] = defaultValue), acc), {}), "getValuesFromArgTypes"), _GlobalsStore = class {
    constructor({
      globals = {},
      globalTypes = {}
    }) {
      this.set({ globals, globalTypes });
    }
    set({ globals = {}, globalTypes = {} }) {
      let delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);
      this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);
      let defaultGlobals = getValuesFromArgTypes(globalTypes);
      this.initialGlobals = { ...defaultGlobals, ...globals }, this.globals = this.initialGlobals, delta && delta !== DEEPLY_EQUAL && this.updateFromPersisted(delta);
    }
    filterAllowedGlobals(globals) {
      return Object.entries(globals).reduce((acc, [key, value2]) => (this.allowedGlobalNames.has(key) ? acc[key] = value2 : logger.warn(
        `Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`
      ), acc), {});
    }
    updateFromPersisted(persisted) {
      let allowedUrlGlobals = this.filterAllowedGlobals(persisted);
      this.globals = { ...this.globals, ...allowedUrlGlobals };
    }
    get() {
      return this.globals;
    }
    update(newGlobals) {
      this.globals = { ...this.globals, ...this.filterAllowedGlobals(newGlobals) };
      for (let key in newGlobals)
        newGlobals[key] === void 0 && (this.globals[key] = this.initialGlobals[key]);
    }
  };
  __name(_GlobalsStore, "GlobalsStore");
  var GlobalsStore = _GlobalsStore, import_memoizerific = __toESM(require_memoizerific(), 1), getImportPathMap = (0, import_memoizerific.default)(1)(
    (entries) => Object.values(entries).reduce(
      (acc, entry) => (acc[entry.importPath] = acc[entry.importPath] || entry, acc),
      {}
    )
  ), _StoryIndexStore = class {
    constructor({ entries } = { v: 5, entries: {} }) {
      this.entries = entries;
    }
    entryFromSpecifier(specifier) {
      let entries = Object.values(this.entries);
      if (specifier === "*")
        return entries[0];
      if (typeof specifier == "string")
        return this.entries[specifier] ? this.entries[specifier] : entries.find((entry) => entry.id.startsWith(specifier));
      let { name, title } = specifier;
      return entries.find((entry) => entry.name === name && entry.title === title);
    }
    storyIdToEntry(storyId) {
      let storyEntry = this.entries[storyId];
      if (!storyEntry)
        throw new MissingStoryAfterHmrError({ storyId });
      return storyEntry;
    }
    importPathToEntry(importPath) {
      return getImportPathMap(this.entries)[importPath];
    }
  };
  __name(_StoryIndexStore, "StoryIndexStore");
  var StoryIndexStore = _StoryIndexStore, normalizeType = __name((type) => typeof type == "string" ? { name: type } : type, "normalizeType"), normalizeControl = __name((control) => typeof control == "string" ? { type: control } : control, "normalizeControl"), normalizeInputType = __name((inputType, key) => {
    let { type, control, ...rest } = inputType, normalized = {
      name: key,
      ...rest
    };
    return type && (normalized.type = normalizeType(type)), control ? normalized.control = normalizeControl(control) : control === !1 && (normalized.control = { disable: !0 }), normalized;
  }, "normalizeInputType"), normalizeInputTypes = __name((inputTypes) => mapValues(inputTypes, normalizeInputType), "normalizeInputTypes"), normalizeArrays = __name((array2) => Array.isArray(array2) ? array2 : array2 ? [array2] : [], "normalizeArrays"), deprecatedStoryAnnotation = dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
  function normalizeStory(key, storyAnnotations, meta) {
    let storyObject = storyAnnotations, userStoryFn = typeof storyAnnotations == "function" ? storyAnnotations : null, { story } = storyObject;
    story && (logger.debug("deprecated story", story), deprecate(deprecatedStoryAnnotation));
    let exportName = storyNameFromExport(key), name = typeof storyObject != "function" && storyObject.name || storyObject.storyName || story?.name || exportName, decorators4 = [
      ...normalizeArrays(storyObject.decorators),
      ...normalizeArrays(story?.decorators)
    ], parameters2 = { ...story?.parameters, ...storyObject.parameters }, args = { ...story?.args, ...storyObject.args }, argTypes = { ...story?.argTypes, ...storyObject.argTypes }, loaders2 = [...normalizeArrays(storyObject.loaders), ...normalizeArrays(story?.loaders)], beforeEach = [
      ...normalizeArrays(storyObject.beforeEach),
      ...normalizeArrays(story?.beforeEach)
    ], afterEach = [
      ...normalizeArrays(storyObject.afterEach),
      ...normalizeArrays(story?.afterEach)
    ], { render, play, tags = [], globals = {} } = storyObject, id2 = parameters2.__id || toId(meta.id, exportName);
    return {
      moduleExport: storyAnnotations,
      id: id2,
      name,
      tags,
      decorators: decorators4,
      parameters: parameters2,
      args,
      argTypes: normalizeInputTypes(argTypes),
      loaders: loaders2,
      beforeEach,
      afterEach,
      globals,
      ...render && { render },
      ...userStoryFn && { userStoryFn },
      ...play && { play }
    };
  }
  __name(normalizeStory, "normalizeStory");
  function normalizeComponentAnnotations(defaultExport, title = defaultExport.title, importPath) {
    let { id: id2, argTypes } = defaultExport;
    return {
      id: sanitize(id2 || title),
      ...defaultExport,
      title,
      ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
      parameters: {
        fileName: importPath,
        ...defaultExport.parameters
      }
    };
  }
  __name(normalizeComponentAnnotations, "normalizeComponentAnnotations");
  var checkGlobals = __name((parameters2) => {
    let { globals, globalTypes } = parameters2;
    (globals || globalTypes) && logger.error(
      "Global args/argTypes can only be set globally",
      JSON.stringify({
        globals,
        globalTypes
      })
    );
  }, "checkGlobals"), checkStorySort = __name((parameters2) => {
    let { options } = parameters2;
    options?.storySort && logger.error("The storySort option parameter can only be set globally");
  }, "checkStorySort"), checkDisallowedParameters = __name((parameters2) => {
    parameters2 && (checkGlobals(parameters2), checkStorySort(parameters2));
  }, "checkDisallowedParameters");
  function processCSFFile(moduleExports, importPath, title) {
    let { default: defaultExport, __namedExportsOrder, ...namedExports } = moduleExports, firstStory = Object.values(namedExports)[0];
    if (isStory(firstStory)) {
      let meta2 = normalizeComponentAnnotations(firstStory.meta.input, title, importPath);
      checkDisallowedParameters(meta2.parameters);
      let csfFile2 = { meta: meta2, stories: {}, moduleExports };
      return Object.keys(namedExports).forEach((key) => {
        if (isExportStory(key, meta2)) {
          let story = namedExports[key], storyMeta = normalizeStory(key, story.input, meta2);
          checkDisallowedParameters(storyMeta.parameters), csfFile2.stories[storyMeta.id] = storyMeta, getStoryChildren(story).forEach((child) => {
            let name = child.input.name, childId = toTestId(storyMeta.id, name);
            child.input.parameters ??= {}, child.input.parameters.__id = childId, csfFile2.stories[childId] = normalizeStory(name, child.input, meta2);
          });
        }
      }), csfFile2.projectAnnotations = firstStory.meta.preview.composed, csfFile2;
    }
    let meta = normalizeComponentAnnotations(
      defaultExport,
      title,
      importPath
    );
    checkDisallowedParameters(meta.parameters);
    let csfFile = { meta, stories: {}, moduleExports };
    return Object.keys(namedExports).forEach((key) => {
      if (isExportStory(key, meta)) {
        let storyMeta = normalizeStory(key, namedExports[key], meta);
        checkDisallowedParameters(storyMeta.parameters), csfFile.stories[storyMeta.id] = storyMeta;
      }
    }), csfFile;
  }
  __name(processCSFFile, "processCSFFile");
  function mountDestructured(playFunction) {
    return playFunction != null && getUsedProps(playFunction).includes("mount");
  }
  __name(mountDestructured, "mountDestructured");
  function getUsedProps(fn2) {
    let match = fn2.toString().match(/[^(]*\(([^)]*)/);
    if (!match)
      return [];
    let args = splitByComma(match[1]);
    if (!args.length)
      return [];
    let first = args[0];
    return first.startsWith("{") && first.endsWith("}") ? splitByComma(first.slice(1, -1).replace(/\s/g, "")).map((prop) => prop.replace(/:.*|=.*/g, "")) : [];
  }
  __name(getUsedProps, "getUsedProps");
  function splitByComma(s4) {
    let result = [], stack = [], start = 0;
    for (let i3 = 0; i3 < s4.length; i3++)
      if (s4[i3] === "{" || s4[i3] === "[")
        stack.push(s4[i3] === "{" ? "}" : "]");
      else if (s4[i3] === stack[stack.length - 1])
        stack.pop();
      else if (!stack.length && s4[i3] === ",") {
        let token = s4.substring(start, i3).trim();
        token && result.push(token), start = i3 + 1;
      }
    let lastToken = s4.substring(start).trim();
    return lastToken && result.push(lastToken), result;
  }
  __name(splitByComma, "splitByComma");
  function decorateStory(storyFn, decorator, bindWithContext) {
    let boundStoryFunction = bindWithContext(storyFn);
    return (context) => decorator(boundStoryFunction, context);
  }
  __name(decorateStory, "decorateStory");
  function sanitizeStoryContextUpdate({
    componentId,
    title,
    kind,
    id: id2,
    name,
    story,
    parameters: parameters2,
    initialArgs,
    argTypes,
    ...update
  } = {}) {
    return update;
  }
  __name(sanitizeStoryContextUpdate, "sanitizeStoryContextUpdate");
  function defaultDecorateStory(storyFn, decorators4) {
    let contextStore = {}, bindWithContext = __name((decoratedStoryFn) => (update) => {
      if (!contextStore.value)
        throw new Error("Decorated function called without init");
      return contextStore.value = {
        ...contextStore.value,
        ...sanitizeStoryContextUpdate(update)
      }, decoratedStoryFn(contextStore.value);
    }, "bindWithContext"), decoratedWithContextStore = decorators4.reduce(
      (story, decorator) => decorateStory(story, decorator, bindWithContext),
      storyFn
    );
    return (context) => (contextStore.value = context, decoratedWithContextStore(context));
  }
  __name(defaultDecorateStory, "defaultDecorateStory");
  function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {
    let { moduleExport, id: id2, name } = storyAnnotations || {}, partialAnnotations = preparePartialAnnotations(
      storyAnnotations,
      componentAnnotations,
      projectAnnotations
    ), applyLoaders = __name(async (context) => {
      let loaded = {};
      for (let loaders2 of [
        normalizeArrays(projectAnnotations.loaders),
        normalizeArrays(componentAnnotations.loaders),
        normalizeArrays(storyAnnotations.loaders)
      ]) {
        if (context.abortSignal.aborted)
          return loaded;
        let loadResults = await Promise.all(loaders2.map((loader) => loader(context)));
        Object.assign(loaded, ...loadResults);
      }
      return loaded;
    }, "applyLoaders"), applyBeforeEach = __name(async (context) => {
      let cleanupCallbacks = new Array();
      for (let beforeEach of [
        ...normalizeArrays(projectAnnotations.beforeEach),
        ...normalizeArrays(componentAnnotations.beforeEach),
        ...normalizeArrays(storyAnnotations.beforeEach)
      ]) {
        if (context.abortSignal.aborted)
          return cleanupCallbacks;
        let cleanup = await beforeEach(context);
        cleanup && cleanupCallbacks.push(cleanup);
      }
      return cleanupCallbacks;
    }, "applyBeforeEach"), applyAfterEach = __name(async (context) => {
      let reversedFinalizers = [
        ...normalizeArrays(projectAnnotations.afterEach),
        ...normalizeArrays(componentAnnotations.afterEach),
        ...normalizeArrays(storyAnnotations.afterEach)
      ].reverse();
      for (let finalizer of reversedFinalizers) {
        if (context.abortSignal.aborted)
          return;
        await finalizer(context);
      }
    }, "applyAfterEach"), undecoratedStoryFn = __name((context) => context.originalStoryFn(context.args, context), "undecoratedStoryFn"), { applyDecorators = defaultDecorateStory, runStep } = projectAnnotations, decorators4 = [
      ...normalizeArrays(storyAnnotations?.decorators),
      ...normalizeArrays(componentAnnotations?.decorators),
      ...normalizeArrays(projectAnnotations?.decorators)
    ], render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render, decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators4), unboundStoryFn = __name((context) => decoratedStoryFn(context), "unboundStoryFn"), playFunction = storyAnnotations?.play ?? componentAnnotations?.play, usesMount = mountDestructured(playFunction);
    if (!render && !usesMount)
      throw new NoRenderFunctionError({ id: id2 });
    let defaultMount = __name((context) => async () => (await context.renderToCanvas(), context.canvas), "defaultMount"), mount = storyAnnotations.mount ?? componentAnnotations.mount ?? projectAnnotations.mount ?? defaultMount, testingLibraryRender = projectAnnotations.testingLibraryRender;
    return {
      storyGlobals: {},
      ...partialAnnotations,
      moduleExport,
      id: id2,
      name,
      story: name,
      originalStoryFn: render,
      undecoratedStoryFn,
      unboundStoryFn,
      applyLoaders,
      applyBeforeEach,
      applyAfterEach,
      playFunction,
      runStep,
      mount,
      testingLibraryRender,
      renderToCanvas: projectAnnotations.renderToCanvas,
      usesMount
    };
  }
  __name(prepareStory, "prepareStory");
  function prepareMeta(componentAnnotations, projectAnnotations, moduleExport) {
    return {
      ...preparePartialAnnotations(void 0, componentAnnotations, projectAnnotations),
      moduleExport
    };
  }
  __name(prepareMeta, "prepareMeta");
  function preparePartialAnnotations(storyAnnotations, componentAnnotations, projectAnnotations) {
    let defaultTags = ["dev", "test"], extraTags = scope.DOCS_OPTIONS?.autodocs === !0 ? ["autodocs"] : [], overrideTags = storyAnnotations?.tags?.includes("test-fn") ? ["!autodocs"] : [], tags = combineTags2(
      ...defaultTags,
      ...extraTags,
      ...projectAnnotations.tags ?? [],
      ...componentAnnotations.tags ?? [],
      ...overrideTags,
      ...storyAnnotations?.tags ?? []
    ), parameters2 = combineParameters2(
      projectAnnotations.parameters,
      componentAnnotations.parameters,
      storyAnnotations?.parameters
    ), { argTypesEnhancers = [], argsEnhancers: argsEnhancers2 = [] } = projectAnnotations, passedArgTypes = combineParameters2(
      projectAnnotations.argTypes,
      componentAnnotations.argTypes,
      storyAnnotations?.argTypes
    );
    if (storyAnnotations) {
      let render = storyAnnotations?.userStoryFn || storyAnnotations?.render || componentAnnotations.render || projectAnnotations.render;
      parameters2.__isArgsStory = render && render.length > 0;
    }
    let passedArgs = {
      ...projectAnnotations.args,
      ...componentAnnotations.args,
      ...storyAnnotations?.args
    }, storyGlobals = {
      ...componentAnnotations.globals,
      ...storyAnnotations?.globals
    }, contextForEnhancers = {
      componentId: componentAnnotations.id,
      title: componentAnnotations.title,
      kind: componentAnnotations.title,
      // Back compat
      id: storyAnnotations?.id || componentAnnotations.id,
      // if there's no story name, we create a fake one since enhancers expect a name
      name: storyAnnotations?.name || "__meta",
      story: storyAnnotations?.name || "__meta",
      // Back compat
      component: componentAnnotations.component,
      subcomponents: componentAnnotations.subcomponents,
      tags,
      parameters: parameters2,
      initialArgs: passedArgs,
      argTypes: passedArgTypes,
      storyGlobals
    };
    contextForEnhancers.argTypes = argTypesEnhancers.reduce(
      (accumulatedArgTypes, enhancer) => enhancer({ ...contextForEnhancers, argTypes: accumulatedArgTypes }),
      contextForEnhancers.argTypes
    );
    let initialArgsBeforeEnhancers = { ...passedArgs };
    contextForEnhancers.initialArgs = [...argsEnhancers2].reduce(
      (accumulatedArgs, enhancer) => ({
        ...accumulatedArgs,
        ...enhancer({
          ...contextForEnhancers,
          initialArgs: accumulatedArgs
        })
      }),
      initialArgsBeforeEnhancers
    );
    let { name, story, ...withoutStoryIdentifiers } = contextForEnhancers;
    return withoutStoryIdentifiers;
  }
  __name(preparePartialAnnotations, "preparePartialAnnotations");
  function prepareContext(context) {
    let { args: unmappedArgs } = context, targetedContext = {
      ...context,
      allArgs: void 0,
      argsByTarget: void 0
    };
    if (scope.FEATURES?.argTypeTargetsV7) {
      let argsByTarget = groupArgsByTarget(context);
      targetedContext = {
        ...context,
        allArgs: context.args,
        argsByTarget,
        args: argsByTarget[UNTARGETED] || {}
      };
    }
    let mappedArgs = Object.entries(targetedContext.args).reduce((acc, [key, val]) => {
      if (!targetedContext.argTypes[key]?.mapping)
        return acc[key] = val, acc;
      let mappingFn = __name((originalValue) => {
        let mapping = targetedContext.argTypes[key].mapping;
        return mapping && originalValue in mapping ? mapping[originalValue] : originalValue;
      }, "mappingFn");
      return acc[key] = Array.isArray(val) ? val.map(mappingFn) : mappingFn(val), acc;
    }, {}), includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {
      let argType = targetedContext.argTypes[key] || {};
      return includeConditionalArg(argType, mappedArgs, targetedContext.globals) && (acc[key] = val), acc;
    }, {});
    return { ...targetedContext, unmappedArgs, args: includedArgs };
  }
  __name(prepareContext, "prepareContext");
  var inferType = __name((value2, name, visited) => {
    let type = typeof value2;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "function":
      case "symbol":
        return { name: type };
      default:
        break;
    }
    return value2 ? visited.has(value2) ? (logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (visited.add(value2), Array.isArray(value2) ? { name: "array", value: value2.length > 0 ? inferType(value2[0], name, new Set(visited)) : { name: "other", value: "unknown" } } : { name: "object", value: mapValues(value2, (field) => inferType(field, name, new Set(visited))) }) : { name: "object", value: {} };
  }, "inferType"), inferArgTypes = __name((context) => {
    let { id: id2, argTypes: userArgTypes = {}, initialArgs = {} } = context, argTypes = mapValues(initialArgs, (arg, key) => ({
      name: key,
      type: inferType(arg, `${id2}.${key}`, /* @__PURE__ */ new Set())
    })), userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({
      name: key
    }));
    return combineParameters2(argTypes, userArgTypesNames, userArgTypes);
  }, "inferArgTypes");
  inferArgTypes.secondPass = !0;
  var matches = __name((name, descriptor) => Array.isArray(descriptor) ? descriptor.includes(name) : name.match(descriptor), "matches"), filterArgTypes = __name((argTypes, include, exclude) => !include && !exclude ? argTypes : argTypes && pickBy(argTypes, (argType, key) => {
    let name = argType.name || key.toString();
    return !!(!include || matches(name, include)) && (!exclude || !matches(name, exclude));
  }), "filterArgTypes"), inferControl = __name((argType, name, matchers) => {
    let { type, options } = argType;
    if (type) {
      if (matchers.color && matchers.color.test(name)) {
        let controlType = type.name;
        if (controlType === "string")
          return { control: { type: "color" } };
        controlType !== "enum" && logger.warn(
          `Addon controls: Control of type color only supports string, received "${controlType}" instead`
        );
      }
      if (matchers.date && matchers.date.test(name))
        return { control: { type: "date" } };
      switch (type.name) {
        case "array":
          return { control: { type: "object" } };
        case "boolean":
          return { control: { type: "boolean" } };
        case "string":
          return { control: { type: "text" } };
        case "number":
          return { control: { type: "number" } };
        case "enum": {
          let { value: value2 } = type;
          return { control: { type: value2?.length <= 5 ? "radio" : "select" }, options: value2 };
        }
        case "function":
        case "symbol":
          return null;
        default:
          return { control: { type: options ? "select" : "object" } };
      }
    }
  }, "inferControl"), inferControls = __name((context) => {
    let {
      argTypes,
      parameters: { __isArgsStory, controls: { include = null, exclude = null, matchers = {} } = {} }
    } = context;
    if (!__isArgsStory)
      return argTypes;
    let filteredArgTypes = filterArgTypes(argTypes, include, exclude), withControls = mapValues(filteredArgTypes, (argType, name) => argType?.type && inferControl(argType, name.toString(), matchers));
    return combineParameters2(withControls, filteredArgTypes);
  }, "inferControls");
  inferControls.secondPass = !0;
  function normalizeProjectAnnotations({
    argTypes,
    globalTypes,
    argTypesEnhancers,
    decorators: decorators4,
    loaders: loaders2,
    beforeEach,
    afterEach,
    initialGlobals: initialGlobals5,
    ...annotations
  }) {
    return {
      ...argTypes && { argTypes: normalizeInputTypes(argTypes) },
      ...globalTypes && { globalTypes: normalizeInputTypes(globalTypes) },
      decorators: normalizeArrays(decorators4),
      loaders: normalizeArrays(loaders2),
      beforeEach: normalizeArrays(beforeEach),
      afterEach: normalizeArrays(afterEach),
      argTypesEnhancers: [
        ...argTypesEnhancers || [],
        inferArgTypes,
        // There's an architectural decision to be made regarding embedded addons in core:
        //
        // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
        // (like inferControls) to live alongside the addon code itself. This maintains the
        // concept of core addons while improving code organization.
        //
        // Option 2: Fully integrate these addons into core, potentially moving UI components
        // into the manager and treating them as core features rather than addons. This is a
        // bigger architectural change requiring careful consideration.
        //
        // For now, we're keeping inferControls here as we need time to properly evaluate
        // these options and their implications. Some features (like Angular's cleanArgsDecorator)
        // currently rely on this behavior.
        //
        // TODO: Make an architectural decision on the handling of core addons
        inferControls
      ],
      initialGlobals: initialGlobals5,
      ...annotations
    };
  }
  __name(normalizeProjectAnnotations, "normalizeProjectAnnotations");
  var composeBeforeAllHooks = __name((hooks) => async () => {
    let cleanups2 = [];
    for (let hook of hooks) {
      let cleanup = await hook();
      cleanup && cleanups2.unshift(cleanup);
    }
    return async () => {
      for (let cleanup of cleanups2)
        await cleanup();
    };
  }, "composeBeforeAllHooks");
  function composeStepRunners(stepRunners) {
    return async (label, play, playContext) => {
      await stepRunners.reduceRight(
        (innerPlay, stepRunner) => async () => stepRunner(label, innerPlay, playContext),
        async () => play(playContext)
      )();
    };
  }
  __name(composeStepRunners, "composeStepRunners");
  function getField(moduleExportList, field) {
    return moduleExportList.map((xs) => xs.default?.[field] ?? xs[field]).filter(Boolean);
  }
  __name(getField, "getField");
  function getArrayField(moduleExportList, field, options = {}) {
    return getField(moduleExportList, field).reduce((prev, cur) => {
      let normalized = normalizeArrays(cur);
      return options.reverseFileOrder ? [...normalized, ...prev] : [...prev, ...normalized];
    }, []);
  }
  __name(getArrayField, "getArrayField");
  function getObjectField(moduleExportList, field) {
    return Object.assign({}, ...getField(moduleExportList, field));
  }
  __name(getObjectField, "getObjectField");
  function getSingletonField(moduleExportList, field) {
    return getField(moduleExportList, field).pop();
  }
  __name(getSingletonField, "getSingletonField");
  function composeConfigs(moduleExportList) {
    let allArgTypeEnhancers = getArrayField(moduleExportList, "argTypesEnhancers"), stepRunners = getField(moduleExportList, "runStep"), beforeAllHooks = getArrayField(moduleExportList, "beforeAll");
    return {
      parameters: combineParameters2(...getField(moduleExportList, "parameters")),
      decorators: getArrayField(moduleExportList, "decorators", {
        reverseFileOrder: !(scope.FEATURES?.legacyDecoratorFileOrder ?? !1)
      }),
      args: getObjectField(moduleExportList, "args"),
      argsEnhancers: getArrayField(moduleExportList, "argsEnhancers"),
      argTypes: getObjectField(moduleExportList, "argTypes"),
      argTypesEnhancers: [
        ...allArgTypeEnhancers.filter((e) => !e.secondPass),
        ...allArgTypeEnhancers.filter((e) => e.secondPass)
      ],
      initialGlobals: getObjectField(moduleExportList, "initialGlobals"),
      globalTypes: getObjectField(moduleExportList, "globalTypes"),
      loaders: getArrayField(moduleExportList, "loaders"),
      beforeAll: composeBeforeAllHooks(beforeAllHooks),
      beforeEach: getArrayField(moduleExportList, "beforeEach"),
      afterEach: getArrayField(moduleExportList, "afterEach"),
      render: getSingletonField(moduleExportList, "render"),
      renderToCanvas: getSingletonField(moduleExportList, "renderToCanvas"),
      applyDecorators: getSingletonField(moduleExportList, "applyDecorators"),
      runStep: composeStepRunners(stepRunners),
      tags: getArrayField(moduleExportList, "tags"),
      mount: getSingletonField(moduleExportList, "mount"),
      testingLibraryRender: getSingletonField(moduleExportList, "testingLibraryRender")
    };
  }
  __name(composeConfigs, "composeConfigs");
  var _ReporterAPI = class {
    constructor() {
      this.reports = [];
    }
    async addReport(report) {
      this.reports.push(report);
    }
  };
  __name(_ReporterAPI, "ReporterAPI");
  var ReporterAPI = _ReporterAPI;
  function getCsfFactoryAnnotations(story, meta, projectAnnotations) {
    return isStory(story) ? {
      story: story.input,
      meta: story.meta.input,
      preview: story.meta.preview.composed
    } : { story, meta: isMeta(meta) ? meta.input : meta, preview: projectAnnotations };
  }
  __name(getCsfFactoryAnnotations, "getCsfFactoryAnnotations");
  function setDefaultProjectAnnotations(_defaultProjectAnnotations) {
    globalThis.defaultProjectAnnotations = _defaultProjectAnnotations;
  }
  __name(setDefaultProjectAnnotations, "setDefaultProjectAnnotations");
  var DEFAULT_STORY_TITLE = "ComposedStory", DEFAULT_STORY_NAME = "Unnamed Story";
  function extractAnnotation(annotation) {
    return annotation ? composeConfigs([annotation]) : {};
  }
  __name(extractAnnotation, "extractAnnotation");
  function setProjectAnnotations(projectAnnotations) {
    let annotations = Array.isArray(projectAnnotations) ? projectAnnotations : [projectAnnotations];
    return globalThis.globalProjectAnnotations = composeConfigs([
      ...getCoreAnnotations(),
      globalThis.defaultProjectAnnotations ?? {},
      composeConfigs(annotations.map(extractAnnotation))
    ]), globalThis.globalProjectAnnotations ?? {};
  }
  __name(setProjectAnnotations, "setProjectAnnotations");
  var cleanups = [];
  function composeStory(storyAnnotations, componentAnnotations, projectAnnotations, defaultConfig, exportsName) {
    if (storyAnnotations === void 0)
      throw new Error("Expected a story but received undefined.");
    componentAnnotations.title = componentAnnotations.title ?? DEFAULT_STORY_TITLE;
    let normalizedComponentAnnotations = normalizeComponentAnnotations(componentAnnotations), storyName = exportsName || storyAnnotations.storyName || storyAnnotations.story?.name || storyAnnotations.name || DEFAULT_STORY_NAME, normalizedStory = normalizeStory(
      storyName,
      storyAnnotations,
      normalizedComponentAnnotations
    ), normalizedProjectAnnotations = normalizeProjectAnnotations(
      composeConfigs([
        defaultConfig ?? globalThis.globalProjectAnnotations ?? {},
        projectAnnotations ?? {}
      ])
    ), story = prepareStory(
      normalizedStory,
      normalizedComponentAnnotations,
      normalizedProjectAnnotations
    ), globals = {
      ...getValuesFromArgTypes(normalizedProjectAnnotations.globalTypes),
      ...normalizedProjectAnnotations.initialGlobals,
      ...story.storyGlobals
    }, reporting = new ReporterAPI(), initializeContext = __name(() => {
      let context = prepareContext({
        hooks: new HooksContext(),
        globals,
        args: { ...story.initialArgs },
        viewMode: "story",
        reporting,
        loaded: {},
        abortSignal: new AbortController().signal,
        step: __name((label, play2) => story.runStep(label, play2, context), "step"),
        canvasElement: null,
        canvas: {},
        userEvent: {},
        globalTypes: normalizedProjectAnnotations.globalTypes,
        ...story,
        context: null,
        mount: null
      });
      return context.parameters.__isPortableStory = !0, context.context = context, story.renderToCanvas && (context.renderToCanvas = async () => {
        let unmount = await story.renderToCanvas?.(
          {
            componentId: story.componentId,
            title: story.title,
            id: story.id,
            name: story.name,
            tags: story.tags,
            showMain: __name(() => {
            }, "showMain"),
            showError: __name((error) => {
              throw new Error(`${error.title}
${error.description}`);
            }, "showError"),
            showException: __name((error) => {
              throw error;
            }, "showException"),
            forceRemount: !0,
            storyContext: context,
            storyFn: __name(() => story.unboundStoryFn(context), "storyFn"),
            unboundStoryFn: story.unboundStoryFn
          },
          context.canvasElement
        );
        unmount && cleanups.push(unmount);
      }), context.mount = story.mount(context), context;
    }, "initializeContext"), loadedContext, play = __name(async (extraContext) => {
      let context = initializeContext();
      return context.canvasElement ??= globalThis?.document?.body, loadedContext && (context.loaded = loadedContext.loaded), Object.assign(context, extraContext), story.playFunction(context);
    }, "play"), run = __name((extraContext) => {
      let context = initializeContext();
      return Object.assign(context, extraContext), runStory(story, context);
    }, "run"), playFunction = story.playFunction ? play : void 0;
    return Object.assign(
      __name(function(extraArgs) {
        let context = initializeContext();
        return loadedContext && (context.loaded = loadedContext.loaded), context.args = {
          ...context.initialArgs,
          ...extraArgs
        }, story.unboundStoryFn(context);
      }, "storyFn"),
      {
        id: story.id,
        storyName,
        load: __name(async () => {
          for (let callback of [...cleanups].reverse())
            await callback();
          cleanups.length = 0;
          let context = initializeContext();
          context.loaded = await story.applyLoaders(context), cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean)), loadedContext = context;
        }, "load"),
        globals,
        args: story.initialArgs,
        parameters: story.parameters,
        argTypes: story.argTypes,
        play: playFunction,
        run,
        reporting,
        tags: story.tags
      }
    );
  }
  __name(composeStory, "composeStory");
  var defaultComposeStory = __name((story, component, project, exportsName) => composeStory(story, component, project, {}, exportsName), "defaultComposeStory");
  function composeStories(storiesImport, globalConfig, composeStoryFn = defaultComposeStory) {
    let { default: metaExport, __esModule, __namedExportsOrder, ...stories } = storiesImport, meta = metaExport;
    return Object.entries(stories).reduce(
      (storiesMap, [exportsName, story]) => {
        let { story: storyAnnotations, meta: componentAnnotations } = getCsfFactoryAnnotations(story);
        return !meta && componentAnnotations && (meta = componentAnnotations), isExportStory(exportsName, meta) ? Object.assign(storiesMap, {
          [exportsName]: composeStoryFn(storyAnnotations, meta, globalConfig, exportsName)
        }) : storiesMap;
      },
      {}
    );
  }
  __name(composeStories, "composeStories");
  function createPlaywrightTest(baseTest) {
    return baseTest.extend({
      mount: __name(async ({ mount, page }, use) => {
        await use(async (storyRef, ...restArgs) => {
          if (!("__pw_type" in storyRef) || "__pw_type" in storyRef && storyRef.__pw_type !== "jsx")
            throw new Error(dedent`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
          let { props, ...storyRefWithoutProps } = storyRef;
          await page.evaluate(async (wrappedStoryRef) => {
            let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef);
            return ("__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef)?.load?.();
          }, storyRefWithoutProps);
          let mountResult = await mount(storyRef, ...restArgs);
          return await page.evaluate(async (wrappedStoryRef) => {
            let unwrappedStoryRef = await globalThis.__pwUnwrapObject?.(wrappedStoryRef), story = "__pw_type" in unwrappedStoryRef ? unwrappedStoryRef.type : unwrappedStoryRef, canvasElement = document.querySelector("#root");
            return story?.play?.({ canvasElement });
          }, storyRefWithoutProps), mountResult;
        });
      }, "mount")
    });
  }
  __name(createPlaywrightTest, "createPlaywrightTest");
  async function runStory(story, context) {
    for (let callback of [...cleanups].reverse())
      await callback();
    if (cleanups.length = 0, !context.canvasElement) {
      let container = document.createElement("div");
      globalThis?.document?.body?.appendChild(container), context.canvasElement = container, cleanups.push(() => {
        globalThis?.document?.body?.contains(container) && globalThis?.document?.body?.removeChild(container);
      });
    }
    if (context.loaded = await story.applyLoaders(context), context.abortSignal.aborted)
      return;
    cleanups.push(...(await story.applyBeforeEach(context)).filter(Boolean));
    let playFunction = story.playFunction, isMountDestructured = story.usesMount;
    if (isMountDestructured || await context.mount(), context.abortSignal.aborted)
      return;
    playFunction && (isMountDestructured || (context.mount = async () => {
      throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
    }), await playFunction(context));
    let cleanUp;
    isTestEnvironment() ? cleanUp = pauseAnimations() : await waitForAnimations(context.abortSignal), await story.applyAfterEach(context), await cleanUp?.();
  }
  __name(runStory, "runStory");
  var CSF_CACHE_SIZE = 1e3, STORY_CACHE_SIZE = 1e4, _StoryStore = class {
    constructor(storyIndex, importFn, projectAnnotations) {
      this.importFn = importFn, this.storyIndex = new StoryIndexStore(storyIndex), this.projectAnnotations = normalizeProjectAnnotations(
        composeConfigs([...getCoreAnnotations(), projectAnnotations])
      );
      let { initialGlobals: initialGlobals5, globalTypes } = this.projectAnnotations;
      this.args = new ArgsStore(), this.userGlobals = new GlobalsStore({ globals: initialGlobals5, globalTypes }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(processCSFFile), this.prepareMetaWithCache = (0, import_memoizerific2.default)(CSF_CACHE_SIZE)(prepareMeta), this.prepareStoryWithCache = (0, import_memoizerific2.default)(STORY_CACHE_SIZE)(prepareStory);
    }
    setProjectAnnotations(projectAnnotations) {
      this.projectAnnotations = normalizeProjectAnnotations(projectAnnotations);
      let { initialGlobals: initialGlobals5, globalTypes } = projectAnnotations;
      this.userGlobals.set({ globals: initialGlobals5, globalTypes });
    }
    // This means that one of the CSF files has changed.
    // If the `importFn` has changed, we will invalidate both caches.
    // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
    // on whether we've loaded the relevant files yet.
    async onStoriesChanged({
      importFn,
      storyIndex
    }) {
      importFn && (this.importFn = importFn), storyIndex && (this.storyIndex.entries = storyIndex.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
    }
    // Get an entry from the index, waiting on initialization if necessary
    async storyIdToEntry(storyId) {
      return this.storyIndex.storyIdToEntry(storyId);
    }
    // To load a single CSF file to service a story we need to look up the importPath in the index
    async loadCSFFileByStoryId(storyId) {
      let { importPath, title } = this.storyIndex.storyIdToEntry(storyId), moduleExports = await this.importFn(importPath);
      return this.processCSFFileWithCache(moduleExports, importPath, title);
    }
    async loadAllCSFFiles() {
      let importPaths = {};
      return Object.entries(this.storyIndex.entries).forEach(([storyId, { importPath }]) => {
        importPaths[importPath] = storyId;
      }), (await Promise.all(
        Object.entries(importPaths).map(async ([importPath, storyId]) => ({
          importPath,
          csfFile: await this.loadCSFFileByStoryId(storyId)
        }))
      )).reduce(
        (acc, { importPath, csfFile }) => (acc[importPath] = csfFile, acc),
        {}
      );
    }
    async cacheAllCSFFiles() {
      this.cachedCSFFiles = await this.loadAllCSFFiles();
    }
    preparedMetaFromCSFFile({ csfFile }) {
      let componentAnnotations = csfFile.meta;
      return this.prepareMetaWithCache(
        componentAnnotations,
        this.projectAnnotations,
        csfFile.moduleExports.default
      );
    }
    // Load the CSF file for a story and prepare the story from it and the project annotations.
    async loadStory({ storyId }) {
      let csfFile = await this.loadCSFFileByStoryId(storyId);
      return this.storyFromCSFFile({ storyId, csfFile });
    }
    // This function is synchronous for convenience -- often times if you have a CSF file already
    // it is easier not to have to await `loadStory`.
    storyFromCSFFile({
      storyId,
      csfFile
    }) {
      let storyAnnotations = csfFile.stories[storyId];
      if (!storyAnnotations)
        throw new MissingStoryFromCsfFileError({ storyId });
      let componentAnnotations = csfFile.meta, story = this.prepareStoryWithCache(
        storyAnnotations,
        componentAnnotations,
        csfFile.projectAnnotations ?? this.projectAnnotations
      );
      return this.args.setInitial(story), this.hooks[story.id] = this.hooks[story.id] || new HooksContext(), story;
    }
    // If we have a CSF file we can get all the stories from it synchronously
    componentStoriesFromCSFFile({
      csfFile
    }) {
      return Object.keys(this.storyIndex.entries).filter((storyId) => !!csfFile.stories[storyId]).map((storyId) => this.storyFromCSFFile({ storyId, csfFile }));
    }
    async loadEntry(id2) {
      let entry = await this.storyIdToEntry(id2), storyImports = entry.type === "docs" ? entry.storiesImports : [], [entryExports, ...csfFiles] = await Promise.all([
        this.importFn(entry.importPath),
        ...storyImports.map((storyImportPath) => {
          let firstStoryEntry = this.storyIndex.importPathToEntry(storyImportPath);
          return this.loadCSFFileByStoryId(firstStoryEntry.id);
        })
      ]);
      return { entryExports, csfFiles };
    }
    // A prepared story does not include args, globals or hooks. These are stored in the story store
    // and updated separately to the (immutable) story.
    getStoryContext(story, { forceInitialArgs = !1 } = {}) {
      let userGlobals = this.userGlobals.get(), { initialGlobals: initialGlobals5 } = this.userGlobals, reporting = new ReporterAPI();
      return prepareContext({
        ...story,
        args: forceInitialArgs ? story.initialArgs : this.args.get(story.id),
        initialGlobals: initialGlobals5,
        globalTypes: this.projectAnnotations.globalTypes,
        userGlobals,
        reporting,
        globals: {
          ...userGlobals,
          ...story.storyGlobals
        },
        hooks: this.hooks[story.id]
      });
    }
    addCleanupCallbacks(story, ...callbacks) {
      this.cleanupCallbacks[story.id] = (this.cleanupCallbacks[story.id] || []).concat(callbacks);
    }
    async cleanupStory(story) {
      this.hooks[story.id].clean();
      let callbacks = this.cleanupCallbacks[story.id];
      if (callbacks)
        for (let callback of [...callbacks].reverse())
          await callback();
      delete this.cleanupCallbacks[story.id];
    }
    extract(options = { includeDocsOnly: !1 }) {
      let { cachedCSFFiles } = this;
      if (console.log("extract: extracting stories", cachedCSFFiles), !cachedCSFFiles)
        throw new CalledExtractOnStoreError();
      let stories = Object.entries(this.storyIndex.entries).reduce(
        (acc, [storyId, entry]) => {
          if (entry.type === "docs")
            return acc;
          let csfFile = cachedCSFFiles[entry.importPath], story = this.storyFromCSFFile({ storyId, csfFile });
          return !options.includeDocsOnly && story.parameters.docsOnly || (acc[storyId] = Object.entries(story).reduce(
            (storyAcc, [key, value2]) => key === "story" && entry.subtype === "test" ? { ...storyAcc, story: entry.parentName } : key === "moduleExport" || typeof value2 == "function" ? storyAcc : Array.isArray(value2) ? Object.assign(storyAcc, { [key]: value2.slice().sort() }) : Object.assign(storyAcc, { [key]: value2 }),
            {
              args: story.initialArgs,
              globals: {
                ...this.userGlobals.initialGlobals,
                ...this.userGlobals.globals,
                ...story.storyGlobals
              },
              storyId: entry.parent ? entry.parent : storyId
            }
          )), acc;
        },
        {}
      );
      return console.log("extract: stories", stories), stories;
    }
  };
  __name(_StoryStore, "StoryStore");
  var StoryStore = _StoryStore;
  function slash(path) {
    return path.startsWith("\\\\?\\") ? path : path.replace(/\\/g, "/");
  }
  __name(slash, "slash");
  var sanitize2 = __name((parts) => {
    if (parts.length === 0)
      return parts;
    let last = parts[parts.length - 1], lastStripped = last?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
    if (parts.length === 1)
      return [lastStripped];
    let nextToLast = parts[parts.length - 2];
    return lastStripped && nextToLast && lastStripped.toLowerCase() === nextToLast.toLowerCase() ? [...parts.slice(0, -2), lastStripped] : lastStripped && (/^(story|stories)([.][^.]+)$/i.test(last) || /^index$/i.test(lastStripped)) ? parts.slice(0, -1) : [...parts.slice(0, -1), lastStripped];
  }, "sanitize");
  function pathJoin(paths) {
    return paths.flatMap((p4) => p4.split("/")).filter(Boolean).join("/");
  }
  __name(pathJoin, "pathJoin");
  var userOrAutoTitleFromSpecifier = __name((fileName, entry, userTitle) => {
    let { directory, importPathMatcher, titlePrefix = "" } = entry || {};
    typeof fileName == "number" && once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
    let normalizedFileName = slash(String(fileName));
    if (importPathMatcher.exec(normalizedFileName)) {
      if (!userTitle) {
        let suffix = normalizedFileName.replace(directory, ""), parts = pathJoin([titlePrefix, suffix]).split("/");
        return parts = sanitize2(parts), parts.join("/");
      }
      return titlePrefix ? pathJoin([titlePrefix, userTitle]) : userTitle;
    }
  }, "userOrAutoTitleFromSpecifier"), userOrAutoTitle = __name((fileName, storiesEntries, userTitle) => {
    for (let i3 = 0; i3 < storiesEntries.length; i3 += 1) {
      let title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i3], userTitle);
      if (title)
        return title;
    }
    return userTitle || void 0;
  }, "userOrAutoTitle"), STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/, storySort = __name((options = {}) => (a3, b3) => {
    if (a3.title === b3.title && !options.includeNames)
      return 0;
    let method = options.method || "configure", order = options.order || [], storyTitleA = a3.title.trim().split(STORY_KIND_PATH_SEPARATOR), storyTitleB = b3.title.trim().split(STORY_KIND_PATH_SEPARATOR);
    options.includeNames && (storyTitleA.push(a3.name), storyTitleB.push(b3.name));
    let depth = 0;
    for (; storyTitleA[depth] || storyTitleB[depth]; ) {
      if (!storyTitleA[depth])
        return -1;
      if (!storyTitleB[depth])
        return 1;
      let nameA = storyTitleA[depth], nameB = storyTitleB[depth];
      if (nameA !== nameB) {
        let indexA = order.indexOf(nameA), indexB = order.indexOf(nameB), indexWildcard = order.indexOf("*");
        return indexA !== -1 || indexB !== -1 ? (indexA === -1 && (indexWildcard !== -1 ? indexA = indexWildcard : indexA = order.length), indexB === -1 && (indexWildcard !== -1 ? indexB = indexWildcard : indexB = order.length), indexA - indexB) : method === "configure" ? 0 : nameA.localeCompare(nameB, options.locales ? options.locales : void 0, {
          numeric: !0,
          sensitivity: "accent"
        });
      }
      let index2 = order.indexOf(nameA);
      index2 === -1 && (index2 = order.indexOf("*")), order = index2 !== -1 && Array.isArray(order[index2 + 1]) ? order[index2 + 1] : [], depth += 1;
    }
    return 0;
  }, "storySort"), sortStoriesCommon = __name((stories, storySortParameter, fileNameOrder) => {
    if (storySortParameter) {
      let sortFn;
      typeof storySortParameter == "function" ? sortFn = storySortParameter : sortFn = storySort(storySortParameter), stories.sort(sortFn);
    } else
      stories.sort(
        (s1, s22) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s22.importPath)
      );
    return stories;
  }, "sortStoriesCommon"), sortStoriesV7 = __name((stories, storySortParameter, fileNameOrder) => {
    try {
      return sortStoriesCommon(stories, storySortParameter, fileNameOrder);
    } catch (err) {
      throw new Error(dedent`
    Error sorting stories with sort parameter ${storySortParameter}:

    > ${err.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
    }
  }, "sortStoriesV7"), PREPARE_ABORTED = new Error("prepareAborted"), { AbortController: AbortController2 } = globalThis;
  function serializeError(error) {
    try {
      let { name = "Error", message = String(error), stack } = error;
      return { name, message, stack };
    } catch {
      return { name: "Error", message: String(error) };
    }
  }
  __name(serializeError, "serializeError");
  var _StoryRender = class {
    constructor(channel, store, renderToScreen, callbacks, id2, viewMode, renderOptions = { autoplay: !0, forceInitialArgs: !1 }, story) {
      this.channel = channel, this.store = store, this.renderToScreen = renderToScreen, this.callbacks = callbacks, this.id = id2, this.viewMode = viewMode, this.renderOptions = renderOptions, this.type = "story", this.notYetRendered = !0, this.rerenderEnqueued = !1, this.disableKeyListeners = !1, this.teardownRender = __name(() => {
      }, "teardownRender"), this.torndown = !1, this.abortController = new AbortController2(), this.renderId = Date.now(), story && (this.story = story, this.phase = "preparing");
    }
    async runPhase(signal, phase, phaseFn) {
      this.phase = phase, this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
        newPhase: this.phase,
        renderId: this.renderId,
        storyId: this.id
      }), phaseFn && (await phaseFn(), this.checkIfAborted(signal));
    }
    checkIfAborted(signal) {
      return signal.aborted && !["finished", "aborted", "errored"].includes(this.phase) && (this.phase = "aborted", this.channel.emit(STORY_RENDER_PHASE_CHANGED, {
        newPhase: this.phase,
        renderId: this.renderId,
        storyId: this.id
      })), signal.aborted;
    }
    async prepare() {
      if (await this.runPhase(this.abortController.signal, "preparing", async () => {
        this.story = await this.store.loadStory({ storyId: this.id });
      }), this.abortController.signal.aborted)
        throw await this.store.cleanupStory(this.story), PREPARE_ABORTED;
    }
    // The two story "renders" are equal and have both loaded the same story
    isEqual(other) {
      return !!(this.id === other.id && this.story && this.story === other.story);
    }
    isPreparing() {
      return ["preparing"].includes(this.phase);
    }
    isPending() {
      return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
        this.phase
      );
    }
    async renderToElement(canvasElement) {
      return this.canvasElement = canvasElement, this.render({ initial: !0, forceRemount: !0 });
    }
    storyContext() {
      if (!this.story)
        throw new Error("Cannot call storyContext before preparing");
      let { forceInitialArgs } = this.renderOptions;
      return this.store.getStoryContext(this.story, { forceInitialArgs });
    }
    async render({
      initial = !1,
      forceRemount = !1
    } = {}) {
      let { canvasElement } = this;
      if (!this.story)
        throw new Error("cannot render when not prepared");
      let story = this.story;
      if (!canvasElement)
        throw new Error("cannot render when canvasElement is unset");
      let {
        id: id2,
        componentId,
        title,
        name,
        tags,
        applyLoaders,
        applyBeforeEach,
        applyAfterEach,
        unboundStoryFn,
        playFunction,
        runStep
      } = story;
      forceRemount && !initial && (this.cancelRender(), this.abortController = new AbortController2());
      let abortSignal = this.abortController.signal, mounted = !1, isMountDestructured = story.usesMount;
      try {
        let context = {
          ...this.storyContext(),
          viewMode: this.viewMode,
          abortSignal,
          canvasElement,
          loaded: {},
          step: __name((label, play) => runStep(label, play, context), "step"),
          context: null,
          canvas: {},
          userEvent: {},
          renderToCanvas: __name(async () => {
            let teardown = await this.renderToScreen(renderContext, canvasElement);
            this.teardownRender = teardown || (() => {
            }), mounted = !0;
          }, "renderToCanvas"),
          // The story provides (set in a renderer) a mount function that is a higher order function
          // (context) => (...args) => Canvas
          //
          // Before assigning it to the context, we resolve the context dependency,
          // so that a user can just call it as await mount(...args) in their play function.
          mount: __name(async (...args) => {
            this.callbacks.showStoryDuringRender?.();
            let mountReturn = null;
            return await this.runPhase(abortSignal, "rendering", async () => {
              mountReturn = await story.mount(context)(...args);
            }), isMountDestructured && await this.runPhase(abortSignal, "playing"), mountReturn;
          }, "mount")
        };
        context.context = context;
        let renderContext = {
          componentId,
          title,
          kind: title,
          id: id2,
          name,
          story: name,
          tags,
          ...this.callbacks,
          showError: __name((error) => (this.phase = "errored", this.callbacks.showError(error)), "showError"),
          showException: __name((error) => (this.phase = "errored", this.callbacks.showException(error)), "showException"),
          forceRemount: forceRemount || this.notYetRendered,
          storyContext: context,
          storyFn: __name(() => unboundStoryFn(context), "storyFn"),
          unboundStoryFn
        };
        if (await this.runPhase(abortSignal, "loading", async () => {
          context.loaded = await applyLoaders(context);
        }), abortSignal.aborted)
          return;
        let cleanupCallbacks = await applyBeforeEach(context);
        if (this.store.addCleanupCallbacks(story, ...cleanupCallbacks), this.checkIfAborted(abortSignal) || (!mounted && !isMountDestructured && await context.mount(), this.notYetRendered = !1, abortSignal.aborted))
          return;
        let ignoreUnhandledErrors = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0, unhandledErrors = /* @__PURE__ */ new Set(), onError = __name((event) => {
          event.error && unhandledErrors.add(event.error);
        }, "onError"), onUnhandledRejection = __name((event) => {
          event.reason && unhandledErrors.add(event.reason);
        }, "onUnhandledRejection");
        if (this.renderOptions.autoplay && forceRemount && playFunction && this.phase !== "errored") {
          window?.addEventListener?.("error", onError), window?.addEventListener?.("unhandledrejection", onUnhandledRejection), this.disableKeyListeners = !0;
          try {
            if (isMountDestructured ? await playFunction(context) : (context.mount = async () => {
              throw new MountMustBeDestructuredError({ playFunction: playFunction.toString() });
            }, await this.runPhase(abortSignal, "playing", async () => playFunction(context))), !mounted)
              throw new NoStoryMountedError();
            this.checkIfAborted(abortSignal), !ignoreUnhandledErrors && unhandledErrors.size > 0 ? await this.runPhase(abortSignal, "errored") : await this.runPhase(abortSignal, "played");
          } catch (error) {
            if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(abortSignal, "errored", async () => {
              this.channel.emit(PLAY_FUNCTION_THREW_EXCEPTION, serializeError(error));
            }), this.story.parameters.throwPlayFunctionExceptions !== !1)
              throw error;
            console.error(error);
          }
          if (!ignoreUnhandledErrors && unhandledErrors.size > 0 && this.channel.emit(
            UNHANDLED_ERRORS_WHILE_PLAYING,
            Array.from(unhandledErrors).map(serializeError)
          ), this.disableKeyListeners = !1, window?.removeEventListener?.("unhandledrejection", onUnhandledRejection), window?.removeEventListener?.("error", onError), abortSignal.aborted)
            return;
        }
        await this.runPhase(abortSignal, "completing", async () => {
          isTestEnvironment() ? this.store.addCleanupCallbacks(story, pauseAnimations()) : await waitForAnimations(abortSignal);
        }), await this.runPhase(abortSignal, "completed", async () => {
          this.channel.emit(STORY_RENDERED, id2);
        }), this.phase !== "errored" && await this.runPhase(abortSignal, "afterEach", async () => {
          await applyAfterEach(context);
        });
        let hasUnhandledErrors = !ignoreUnhandledErrors && unhandledErrors.size > 0, hasSomeReportsFailed = context.reporting.reports.some(
          (report) => report.status === "failed"
        ), hasStoryErrored = hasUnhandledErrors || hasSomeReportsFailed;
        await this.runPhase(
          abortSignal,
          "finished",
          async () => this.channel.emit(STORY_FINISHED, {
            storyId: id2,
            status: hasStoryErrored ? "error" : "success",
            reporters: context.reporting.reports
          })
        );
      } catch (err) {
        this.phase = "errored", this.callbacks.showException(err), await this.runPhase(
          abortSignal,
          "finished",
          async () => this.channel.emit(STORY_FINISHED, {
            storyId: id2,
            status: "error",
            reporters: []
          })
        );
      }
      this.rerenderEnqueued && (this.rerenderEnqueued = !1, this.render());
    }
    /**
     * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
     * enqueued, and will be executed after the current render is completed. Rerendering while playing
     * will not be enqueued, and will be executed immediately, to support rendering args changes while
     * playing.
     */
    async rerender() {
      if (this.isPending() && this.phase !== "playing")
        this.rerenderEnqueued = !0;
      else
        return this.render();
    }
    async remount() {
      return await this.teardown(), this.render({ forceRemount: !0 });
    }
    // If the story is torn down (either a new story is rendered or the docs page removes it)
    // we need to consider the fact that the initial render may not be finished
    // (possibly the loaders or the play function are still running). We use the controller
    // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
    // happens inside the user's code.
    cancelRender() {
      this.abortController.abort();
    }
    cancelPlayFunction() {
      this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
    }
    async teardown() {
      this.torndown = !0, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
      for (let i3 = 0; i3 < 3; i3 += 1) {
        if (!this.isPending()) {
          await this.teardownRender();
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
      window?.location?.reload?.(), await new Promise(() => {
      });
    }
  };
  __name(_StoryRender, "StoryRender");
  var StoryRender = _StoryRender, { fetch } = scope, STORY_INDEX_PATH = "./index.json", _Preview = class {
    constructor(importFn, getProjectAnnotations, channel = addons2.getChannel(), shouldInitialize = !0) {
      this.importFn = importFn, this.getProjectAnnotations = getProjectAnnotations, this.channel = channel, this.storyRenders = [], this.storeInitializationPromise = new Promise((resolve, reject) => {
        this.resolveStoreInitializationPromise = resolve, this.rejectStoreInitializationPromise = reject;
      }), shouldInitialize && this.initialize();
    }
    // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
    // That proxies through to the store once ready, and errors beforehand. This means we can set
    // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
    // similarly integrators can access the `storyStore` on the preview at any time, although
    // it is considered deprecated and we will no longer allow access in 9.0
    get storyStore() {
      return new Proxy(
        {},
        {
          get: __name((_3, method) => {
            if (this.storyStoreValue)
              return deprecate("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[method];
            throw new StoryStoreAccessedBeforeInitializationError();
          }, "get")
        }
      );
    }
    // INITIALIZATION
    async initialize() {
      this.setupListeners();
      try {
        let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
        await this.runBeforeAllHook(projectAnnotations), await this.initializeWithProjectAnnotations(projectAnnotations);
        let userAgent = globalThis?.navigator?.userAgent;
        await this.channel.emit(PREVIEW_INITIALIZED, { userAgent });
      } catch (err) {
        this.rejectStoreInitializationPromise(err);
      }
    }
    ready() {
      return this.storeInitializationPromise;
    }
    setupListeners() {
      this.channel.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this)), this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this)), this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this)), this.channel.on(ARGTYPES_INFO_REQUEST, this.onRequestArgTypesInfo.bind(this)), this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this)), this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this)), this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this)), this.channel.on(STORY_HOT_UPDATED, this.onStoryHotUpdated.bind(this));
    }
    async getProjectAnnotationsOrRenderError() {
      try {
        let projectAnnotations = await this.getProjectAnnotations();
        if (this.renderToCanvas = projectAnnotations.renderToCanvas, !this.renderToCanvas)
          throw new MissingRenderToCanvasError();
        return projectAnnotations;
      } catch (err) {
        throw this.renderPreviewEntryError("Error reading preview.js:", err), err;
      }
    }
    // If initialization gets as far as project annotations, this function runs.
    async initializeWithProjectAnnotations(projectAnnotations) {
      this.projectAnnotationsBeforeInitialization = projectAnnotations;
      try {
        let storyIndex = await this.getStoryIndexFromServer();
        return this.initializeWithStoryIndex(storyIndex);
      } catch (err) {
        throw this.renderPreviewEntryError("Error loading story index:", err), err;
      }
    }
    async runBeforeAllHook(projectAnnotations) {
      try {
        await this.beforeAllCleanup?.(), this.beforeAllCleanup = await projectAnnotations.beforeAll?.();
      } catch (err) {
        throw this.renderPreviewEntryError("Error in beforeAll hook:", err), err;
      }
    }
    async getStoryIndexFromServer() {
      let result = await fetch(STORY_INDEX_PATH);
      if (result.status === 200)
        return result.json();
      throw new StoryIndexFetchError({ text: await result.text() });
    }
    // If initialization gets as far as the story index, this function runs.
    initializeWithStoryIndex(storyIndex) {
      if (!this.projectAnnotationsBeforeInitialization)
        throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
      this.storyStoreValue = new StoryStore(
        storyIndex,
        this.importFn,
        this.projectAnnotationsBeforeInitialization
      ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
    }
    async setInitialGlobals() {
      this.emitGlobals();
    }
    emitGlobals() {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "emitGlobals" });
      let payload = {
        globals: this.storyStoreValue.userGlobals.get() || {},
        globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
      };
      this.channel.emit(SET_GLOBALS, payload);
    }
    // EVENT HANDLERS
    // This happens when a config file gets reloaded
    async onGetProjectAnnotationsChanged({
      getProjectAnnotations
    }) {
      delete this.previewEntryError, this.getProjectAnnotations = getProjectAnnotations;
      let projectAnnotations = await this.getProjectAnnotationsOrRenderError();
      if (await this.runBeforeAllHook(projectAnnotations), !this.storyStoreValue) {
        await this.initializeWithProjectAnnotations(projectAnnotations);
        return;
      }
      this.storyStoreValue.setProjectAnnotations(projectAnnotations), this.emitGlobals();
    }
    async onStoryIndexChanged() {
      if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
        try {
          let storyIndex = await this.getStoryIndexFromServer();
          if (this.projectAnnotationsBeforeInitialization) {
            this.initializeWithStoryIndex(storyIndex);
            return;
          }
          await this.onStoriesChanged({ storyIndex });
        } catch (err) {
          throw this.renderPreviewEntryError("Error loading story index:", err), err;
        }
    }
    // This happens when a glob gets HMR-ed
    async onStoriesChanged({
      importFn,
      storyIndex
    }) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onStoriesChanged" });
      await this.storyStoreValue.onStoriesChanged({ importFn, storyIndex });
    }
    async onUpdateGlobals({
      globals: updatedGlobals,
      currentStory
    }) {
      if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateGlobals" });
      if (this.storyStoreValue.userGlobals.update(updatedGlobals), currentStory) {
        let { initialGlobals: initialGlobals5, storyGlobals, userGlobals, globals } = this.storyStoreValue.getStoryContext(currentStory);
        this.channel.emit(GLOBALS_UPDATED, {
          initialGlobals: initialGlobals5,
          userGlobals,
          storyGlobals,
          globals
        });
      } else {
        let { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
        this.channel.emit(GLOBALS_UPDATED, {
          initialGlobals: initialGlobals5,
          userGlobals: globals,
          storyGlobals: {},
          globals
        });
      }
      await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
    }
    async onUpdateArgs({ storyId, updatedArgs }) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onUpdateArgs" });
      this.storyStoreValue.args.update(storyId, updatedArgs), await Promise.all(
        this.storyRenders.filter((r2) => r2.id === storyId && !r2.renderOptions.forceInitialArgs).map(
          (r2) => (
            // We only run the play function, with in a force remount.
            // But when mount is destructured, the rendering happens inside of the play function.
            r2.story && r2.story.usesMount ? r2.remount() : r2.rerender()
          )
        )
      ), this.channel.emit(STORY_ARGS_UPDATED, {
        storyId,
        args: this.storyStoreValue.args.get(storyId)
      });
    }
    async onRequestArgTypesInfo({ id: id2, payload }) {
      try {
        await this.storeInitializationPromise;
        let story = await this.storyStoreValue?.loadStory(payload);
        this.channel.emit(ARGTYPES_INFO_RESPONSE, {
          id: id2,
          success: !0,
          payload: { argTypes: story?.argTypes || {} },
          error: null
        });
      } catch (e) {
        this.channel.emit(ARGTYPES_INFO_RESPONSE, {
          id: id2,
          success: !1,
          error: e?.message
        });
      }
    }
    async onResetArgs({ storyId, argNames }) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "onResetArgs" });
      let story = this.storyRenders.find((r2) => r2.id === storyId)?.story || await this.storyStoreValue.loadStory({ storyId }), updatedArgs = (argNames || [
        .../* @__PURE__ */ new Set([
          ...Object.keys(story.initialArgs),
          ...Object.keys(this.storyStoreValue.args.get(storyId))
        ])
      ]).reduce((acc, argName) => (acc[argName] = story.initialArgs[argName], acc), {});
      await this.onUpdateArgs({ storyId, updatedArgs });
    }
    // ForceReRender does not include a story id, so we simply must
    // re-render all stories in case they are relevant
    async onForceReRender() {
      await Promise.all(this.storyRenders.map((r2) => r2.rerender()));
    }
    async onForceRemount({ storyId }) {
      await Promise.all(this.storyRenders.filter((r2) => r2.id === storyId).map((r2) => r2.remount()));
    }
    async onStoryHotUpdated() {
      await Promise.all(this.storyRenders.map((r2) => r2.cancelPlayFunction()));
    }
    // Used by docs to render a story to a given element
    // Note this short-circuits the `prepare()` phase of the StoryRender,
    // main to be consistent with the previous behaviour. In the future,
    // we will change it to go ahead and load the story, which will end up being
    // "instant", although async.
    renderStoryToElement(story, element, callbacks, options) {
      if (!this.renderToCanvas || !this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({
          methodName: "renderStoryToElement"
        });
      let render = new StoryRender(
        this.channel,
        this.storyStoreValue,
        this.renderToCanvas,
        callbacks,
        story.id,
        "docs",
        options,
        story
      );
      return render.renderToElement(element), this.storyRenders.push(render), async () => {
        await this.teardownRender(render);
      };
    }
    async teardownRender(render, { viewModeChanged } = {}) {
      this.storyRenders = this.storyRenders.filter((r2) => r2 !== render), await render?.teardown?.({ viewModeChanged });
    }
    // API
    async loadStory({ storyId }) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "loadStory" });
      return this.storyStoreValue.loadStory({ storyId });
    }
    getStoryContext(story, { forceInitialArgs = !1 } = {}) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "getStoryContext" });
      return this.storyStoreValue.getStoryContext(story, { forceInitialArgs });
    }
    async extract(options) {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "extract" });
      if (this.previewEntryError)
        throw this.previewEntryError;
      return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(options);
    }
    // UTILITIES
    renderPreviewEntryError(reason, err) {
      this.previewEntryError = err, logger.error(reason), logger.error(err), this.channel.emit(CONFIG_ERROR, err);
    }
  };
  __name(_Preview, "Preview");
  var Preview = _Preview, _DocsContext = class {
    constructor(channel, store, renderStoryToElement, csfFiles) {
      this.channel = channel, this.store = store, this.renderStoryToElement = renderStoryToElement, this.storyIdByName = __name((storyName) => {
        let storyId = this.nameToStoryId.get(storyName);
        if (storyId)
          return storyId;
        throw new Error(`No story found with that name: ${storyName}`);
      }, "storyIdByName"), this.componentStories = __name(() => this.componentStoriesValue, "componentStories"), this.componentStoriesFromCSFFile = __name((csfFile) => this.store.componentStoriesFromCSFFile({ csfFile }), "componentStoriesFromCSFFile"), this.storyById = __name((storyId) => {
        if (!storyId) {
          if (!this.primaryStory)
            throw new Error(
              "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
            );
          return this.primaryStory;
        }
        let csfFile = this.storyIdToCSFFile.get(storyId);
        if (!csfFile)
          throw new Error(`Called \`storyById\` for story that was never loaded: ${storyId}`);
        return this.store.storyFromCSFFile({ storyId, csfFile });
      }, "storyById"), this.getStoryContext = __name((story) => ({
        ...this.store.getStoryContext(story),
        loaded: {},
        viewMode: "docs"
      }), "getStoryContext"), this.loadStory = __name((id2) => this.store.loadStory({ storyId: id2 }), "loadStory"), this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), csfFiles.forEach((csfFile, index2) => {
        this.referenceCSFFile(csfFile);
      });
    }
    // This docs entry references this CSF file and can synchronously load the stories, as well
    // as reference them by module export. If the CSF is part of the "component" stories, they
    // can also be referenced by name and are in the componentStories list.
    referenceCSFFile(csfFile) {
      this.exportsToCSFFile.set(csfFile.moduleExports, csfFile), this.exportsToCSFFile.set(csfFile.moduleExports.default, csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
        let annotation = csfFile.stories[story.id];
        this.storyIdToCSFFile.set(annotation.id, csfFile), this.exportToStory.set(annotation.moduleExport, story);
      });
    }
    attachCSFFile(csfFile) {
      if (!this.exportsToCSFFile.has(csfFile.moduleExports))
        throw new Error("Cannot attach a CSF file that has not been referenced");
      if (this.attachedCSFFiles.has(csfFile))
        return;
      this.attachedCSFFiles.add(csfFile), this.store.componentStoriesFromCSFFile({ csfFile }).forEach((story) => {
        this.nameToStoryId.set(story.name, story.id), this.componentStoriesValue.push(story), this.primaryStory || (this.primaryStory = story);
      });
    }
    referenceMeta(metaExports, attach) {
      let resolved = this.resolveModuleExport(metaExports);
      if (resolved.type !== "meta")
        throw new Error(
          "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
        );
      attach && this.attachCSFFile(resolved.csfFile);
    }
    get projectAnnotations() {
      let { projectAnnotations } = this.store;
      if (!projectAnnotations)
        throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
      return projectAnnotations;
    }
    resolveAttachedModuleExportType(moduleExportType) {
      if (moduleExportType === "story") {
        if (!this.primaryStory)
          throw new Error(
            "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
          );
        return { type: "story", story: this.primaryStory };
      }
      if (this.attachedCSFFiles.size === 0)
        throw new Error(
          "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
        );
      let firstAttachedCSFFile = Array.from(this.attachedCSFFiles)[0];
      if (moduleExportType === "meta")
        return { type: "meta", csfFile: firstAttachedCSFFile };
      let { component } = firstAttachedCSFFile.meta;
      if (!component)
        throw new Error(
          "Attached CSF file does not defined a component, did you forget to export one?"
        );
      return { type: "component", component };
    }
    resolveModuleExport(moduleExportOrType) {
      let csfFile = this.exportsToCSFFile.get(moduleExportOrType);
      if (csfFile)
        return { type: "meta", csfFile };
      let story = this.exportToStory.get(
        isStory(moduleExportOrType) ? moduleExportOrType.input : moduleExportOrType
      );
      return story ? { type: "story", story } : { type: "component", component: moduleExportOrType };
    }
    resolveOf(moduleExportOrType, validTypes = []) {
      let resolved;
      if (["component", "meta", "story"].includes(moduleExportOrType)) {
        let type = moduleExportOrType;
        resolved = this.resolveAttachedModuleExportType(type);
      } else
        resolved = this.resolveModuleExport(moduleExportOrType);
      if (validTypes.length && !validTypes.includes(resolved.type)) {
        let prettyType = resolved.type === "component" ? "component or unknown" : resolved.type;
        throw new Error(dedent`Invalid value passed to the 'of' prop. The value was resolved to a '${prettyType}' type but the only types for this block are: ${validTypes.join(
          ", "
        )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
      }
      switch (resolved.type) {
        case "component":
          return {
            ...resolved,
            projectAnnotations: this.projectAnnotations
          };
        case "meta":
          return {
            ...resolved,
            preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: resolved.csfFile })
          };
        case "story":
        default:
          return resolved;
      }
    }
  };
  __name(_DocsContext, "DocsContext");
  var DocsContext = _DocsContext, _CsfDocsRender = class {
    constructor(channel, store, entry, callbacks) {
      this.channel = channel, this.store = store, this.entry = entry, this.callbacks = callbacks, this.type = "docs", this.subtype = "csf", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = entry.id, this.renderId = Date.now();
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
      if (this.torndown)
        throw PREPARE_ABORTED;
      let { importPath, title } = this.entry, primaryCsfFile = this.store.processCSFFileWithCache(
        entryExports,
        importPath,
        title
      ), primaryStoryId = Object.keys(primaryCsfFile.stories)[0];
      this.story = this.store.storyFromCSFFile({ storyId: primaryStoryId, csfFile: primaryCsfFile }), this.csfFiles = [primaryCsfFile, ...csfFiles], this.preparing = !1;
    }
    isEqual(other) {
      return !!(this.id === other.id && this.story && this.story === other.story);
    }
    docsContext(renderStoryToElement) {
      if (!this.csfFiles)
        throw new Error("Cannot render docs before preparing");
      let docsContext = new DocsContext(
        this.channel,
        this.store,
        renderStoryToElement,
        this.csfFiles
      );
      return this.csfFiles.forEach((csfFile) => docsContext.attachCSFFile(csfFile)), docsContext;
    }
    async renderToElement(canvasElement, renderStoryToElement) {
      if (!this.story || !this.csfFiles)
        throw new Error("Cannot render docs before preparing");
      let docsContext = this.docsContext(renderStoryToElement), { docs: docsParameter } = this.story.parameters || {};
      if (!docsParameter)
        throw new Error(
          "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
        );
      let renderer = await docsParameter.renderer(), { render } = renderer, renderDocs = __name(async () => {
        try {
          await render(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
        } catch (err) {
          this.callbacks.showException(err);
        }
      }, "renderDocs");
      return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged }) => {
        !viewModeChanged || !canvasElement || renderer.unmount(canvasElement);
      }, renderDocs();
    }
    async teardown({ viewModeChanged } = {}) {
      this.teardownRender?.({ viewModeChanged }), this.torndown = !0;
    }
  };
  __name(_CsfDocsRender, "CsfDocsRender");
  var CsfDocsRender = _CsfDocsRender, _MdxDocsRender = class {
    constructor(channel, store, entry, callbacks) {
      this.channel = channel, this.store = store, this.entry = entry, this.callbacks = callbacks, this.type = "docs", this.subtype = "mdx", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = entry.id, this.renderId = Date.now();
    }
    isPreparing() {
      return this.preparing;
    }
    async prepare() {
      this.preparing = !0;
      let { entryExports, csfFiles = [] } = await this.store.loadEntry(this.id);
      if (this.torndown)
        throw PREPARE_ABORTED;
      this.csfFiles = csfFiles, this.exports = entryExports, this.preparing = !1;
    }
    isEqual(other) {
      return !!(this.id === other.id && this.exports && this.exports === other.exports);
    }
    docsContext(renderStoryToElement) {
      if (!this.csfFiles)
        throw new Error("Cannot render docs before preparing");
      return new DocsContext(
        this.channel,
        this.store,
        renderStoryToElement,
        this.csfFiles
      );
    }
    async renderToElement(canvasElement, renderStoryToElement) {
      if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
        throw new Error("Cannot render docs before preparing");
      let docsContext = this.docsContext(renderStoryToElement), { docs } = this.store.projectAnnotations.parameters ?? {};
      if (!docs)
        throw new Error(
          "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
        );
      let docsParameter = { ...docs, page: this.exports.default }, renderer = await docs.renderer(), { render } = renderer, renderDocs = __name(async () => {
        try {
          await render(docsContext, docsParameter, canvasElement), this.channel.emit(DOCS_RENDERED, this.id);
        } catch (err) {
          this.callbacks.showException(err);
        }
      }, "renderDocs");
      return this.rerender = async () => renderDocs(), this.teardownRender = async ({ viewModeChanged } = {}) => {
        !viewModeChanged || !canvasElement || (renderer.unmount(canvasElement), this.torndown = !0);
      }, renderDocs();
    }
    async teardown({ viewModeChanged } = {}) {
      this.teardownRender?.({ viewModeChanged }), this.torndown = !0;
    }
  };
  __name(_MdxDocsRender, "MdxDocsRender");
  var MdxDocsRender = _MdxDocsRender, globalWindow = globalThis;
  function focusInInput(event) {
    let target = event.composedPath && event.composedPath()[0] || event.target;
    return /input|textarea/i.test(target.tagName) || target.getAttribute("contenteditable") !== null;
  }
  __name(focusInInput, "focusInInput");
  var ATTACHED_MDX_TAG = "attached-mdx", UNATTACHED_MDX_TAG = "unattached-mdx";
  function isMdxEntry({ tags }) {
    return tags?.includes(UNATTACHED_MDX_TAG) || tags?.includes(ATTACHED_MDX_TAG);
  }
  __name(isMdxEntry, "isMdxEntry");
  function isStoryRender(r2) {
    return r2.type === "story";
  }
  __name(isStoryRender, "isStoryRender");
  function isDocsRender(r2) {
    return r2.type === "docs";
  }
  __name(isDocsRender, "isDocsRender");
  function isCsfDocsRender(r2) {
    return isDocsRender(r2) && r2.subtype === "csf";
  }
  __name(isCsfDocsRender, "isCsfDocsRender");
  var _PreviewWithSelection = class extends Preview {
    constructor(importFn, getProjectAnnotations, selectionStore, view) {
      super(importFn, getProjectAnnotations, void 0, !1), this.importFn = importFn, this.getProjectAnnotations = getProjectAnnotations, this.selectionStore = selectionStore, this.view = view, this.initialize();
    }
    setupListeners() {
      super.setupListeners(), globalWindow.onkeydown = this.onKeydown.bind(this), this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this)), this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this)), this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));
    }
    async setInitialGlobals() {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "setInitialGlobals" });
      let { globals } = this.selectionStore.selectionSpecifier || {};
      globals && this.storyStoreValue.userGlobals.updateFromPersisted(globals), this.emitGlobals();
    }
    // If initialization gets as far as the story index, this function runs.
    async initializeWithStoryIndex(storyIndex) {
      return await super.initializeWithStoryIndex(storyIndex), this.selectSpecifiedStory();
    }
    // Use the selection specifier to choose a story, then render it
    async selectSpecifiedStory() {
      if (!this.storyStoreValue)
        throw new CalledPreviewMethodBeforeInitializationError({
          methodName: "selectSpecifiedStory"
        });
      if (this.selectionStore.selection) {
        await this.renderSelection();
        return;
      }
      if (!this.selectionStore.selectionSpecifier) {
        this.renderMissingStory();
        return;
      }
      let { storySpecifier, args } = this.selectionStore.selectionSpecifier, entry = this.storyStoreValue.storyIndex.entryFromSpecifier(storySpecifier);
      if (!entry) {
        storySpecifier === "*" ? this.renderStoryLoadingException(storySpecifier, new EmptyIndexError()) : this.renderStoryLoadingException(
          storySpecifier,
          new NoStoryMatchError({ storySpecifier: storySpecifier.toString() })
        );
        return;
      }
      let { id: storyId, type: viewMode } = entry;
      this.selectionStore.setSelection({ storyId, viewMode }), this.channel.emit(STORY_SPECIFIED, this.selectionStore.selection), this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), await this.renderSelection({ persistedArgs: args });
    }
    // EVENT HANDLERS
    // This happens when a config file gets reloaded
    async onGetProjectAnnotationsChanged({
      getProjectAnnotations
    }) {
      await super.onGetProjectAnnotationsChanged({ getProjectAnnotations }), this.selectionStore.selection && this.renderSelection();
    }
    // This happens when a glob gets HMR-ed
    async onStoriesChanged({
      importFn,
      storyIndex
    }) {
      await super.onStoriesChanged({ importFn, storyIndex }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
    }
    onKeydown(event) {
      if (!this.storyRenders.find((r2) => r2.disableKeyListeners) && !focusInInput(event)) {
        let { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode } = event;
        this.channel.emit(PREVIEW_KEYDOWN, {
          event: { altKey, ctrlKey, metaKey, shiftKey, key, code, keyCode }
        });
      }
    }
    async onSetCurrentStory(selection) {
      this.selectionStore.setSelection({ viewMode: "story", ...selection }), await this.storeInitializationPromise, this.channel.emit(CURRENT_STORY_WAS_SET, this.selectionStore.selection), this.renderSelection();
    }
    onUpdateQueryParams(queryParams) {
      this.selectionStore.setQueryParams(queryParams);
    }
    async onUpdateGlobals({ globals }) {
      let currentStory = this.currentRender instanceof StoryRender && this.currentRender.story || void 0;
      super.onUpdateGlobals({ globals, currentStory }), (this.currentRender instanceof MdxDocsRender || this.currentRender instanceof CsfDocsRender) && await this.currentRender.rerender?.();
    }
    async onUpdateArgs({ storyId, updatedArgs }) {
      super.onUpdateArgs({ storyId, updatedArgs });
    }
    async onPreloadStories({ ids }) {
      await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(ids.map((id2) => this.storyStoreValue?.loadEntry(id2)));
    }
    // RENDERING
    // We can either have:
    // - a story selected in "story" viewMode,
    //     in which case we render it to the root element, OR
    // - a story selected in "docs" viewMode,
    //     in which case we render the docsPage for that story
    async renderSelection({ persistedArgs } = {}) {
      let { renderToCanvas } = this;
      if (!this.storyStoreValue || !renderToCanvas)
        throw new CalledPreviewMethodBeforeInitializationError({ methodName: "renderSelection" });
      let { selection } = this.selectionStore;
      if (!selection)
        throw new Error("Cannot call renderSelection as no selection was made");
      let { storyId } = selection, entry;
      try {
        entry = await this.storyStoreValue.storyIdToEntry(storyId);
      } catch (err) {
        this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(storyId, err);
        return;
      }
      let storyIdChanged = this.currentSelection?.storyId !== storyId, viewModeChanged = this.currentRender?.type !== entry.type;
      entry.type === "story" ? this.view.showPreparingStory({ immediate: viewModeChanged }) : this.view.showPreparingDocs({ immediate: viewModeChanged }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
      let render;
      entry.type === "story" ? render = new StoryRender(
        this.channel,
        this.storyStoreValue,
        renderToCanvas,
        this.mainStoryCallbacks(storyId),
        storyId,
        "story"
      ) : isMdxEntry(entry) ? render = new MdxDocsRender(
        this.channel,
        this.storyStoreValue,
        entry,
        this.mainStoryCallbacks(storyId)
      ) : render = new CsfDocsRender(
        this.channel,
        this.storyStoreValue,
        entry,
        this.mainStoryCallbacks(storyId)
      );
      let lastSelection = this.currentSelection;
      this.currentSelection = selection;
      let lastRender = this.currentRender;
      this.currentRender = render;
      try {
        await render.prepare();
      } catch (err) {
        lastRender && await this.teardownRender(lastRender), err !== PREPARE_ABORTED && this.renderStoryLoadingException(storyId, err);
        return;
      }
      let implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);
      if (persistedArgs && isStoryRender(render) && (invariant(!!render.story), this.storyStoreValue.args.updateFromPersisted(render.story, persistedArgs)), lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {
        this.currentRender = lastRender, this.channel.emit(STORY_UNCHANGED, storyId), this.view.showMain();
        return;
      }
      if (lastRender && await this.teardownRender(lastRender, { viewModeChanged }), lastSelection && (storyIdChanged || viewModeChanged) && this.channel.emit(STORY_CHANGED, storyId), isStoryRender(render)) {
        invariant(!!render.story);
        let {
          parameters: parameters2,
          initialArgs,
          argTypes,
          unmappedArgs,
          initialGlobals: initialGlobals5,
          userGlobals,
          storyGlobals,
          globals
        } = this.storyStoreValue.getStoryContext(render.story);
        this.channel.emit(STORY_PREPARED, {
          id: storyId,
          parameters: parameters2,
          initialArgs,
          argTypes,
          args: unmappedArgs
        }), this.channel.emit(GLOBALS_UPDATED, { userGlobals, storyGlobals, globals, initialGlobals: initialGlobals5 });
      } else {
        let { parameters: parameters2 } = this.storyStoreValue.projectAnnotations, { initialGlobals: initialGlobals5, globals } = this.storyStoreValue.userGlobals;
        if (this.channel.emit(GLOBALS_UPDATED, {
          globals,
          initialGlobals: initialGlobals5,
          storyGlobals: {},
          userGlobals: globals
        }), isCsfDocsRender(render) || render.entry.tags?.includes(ATTACHED_MDX_TAG)) {
          if (!render.csfFiles)
            throw new MdxFileWithNoCsfReferencesError({ storyId });
          ({ parameters: parameters2 } = this.storyStoreValue.preparedMetaFromCSFFile({
            csfFile: render.csfFiles[0]
          }));
        }
        this.channel.emit(DOCS_PREPARED, {
          id: storyId,
          parameters: parameters2
        });
      }
      isStoryRender(render) ? (invariant(!!render.story), this.storyRenders.push(render), this.currentRender.renderToElement(
        this.view.prepareForStory(render.story)
      )) : this.currentRender.renderToElement(
        this.view.prepareForDocs(),
        // This argument is used for docs, which is currently only compatible with HTMLElements
        this.renderStoryToElement.bind(this)
      );
    }
    async teardownRender(render, { viewModeChanged = !1 } = {}) {
      this.storyRenders = this.storyRenders.filter((r2) => r2 !== render), await render?.teardown?.({ viewModeChanged });
    }
    // UTILITIES
    mainStoryCallbacks(storyId) {
      return {
        showStoryDuringRender: __name(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
        showMain: __name(() => this.view.showMain(), "showMain"),
        showError: __name((err) => this.renderError(storyId, err), "showError"),
        showException: __name((err) => this.renderException(storyId, err), "showException")
      };
    }
    renderPreviewEntryError(reason, err) {
      super.renderPreviewEntryError(reason, err), this.view.showErrorDisplay(err);
    }
    renderMissingStory() {
      this.view.showNoPreview(), this.channel.emit(STORY_MISSING);
    }
    renderStoryLoadingException(storySpecifier, err) {
      logger.error(err), this.view.showErrorDisplay(err), this.channel.emit(STORY_MISSING, storySpecifier);
    }
    // renderException is used if we fail to render the story and it is uncaught by the app layer
    renderException(storyId, error) {
      let { name = "Error", message = String(error), stack } = error, renderId = this.currentRender?.renderId;
      this.channel.emit(STORY_THREW_EXCEPTION, { name, message, stack }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId }), this.view.showErrorDisplay(error), logger.error(`Error rendering story '${storyId}':`), logger.error(error);
    }
    // renderError is used by the various app layers to inform the user they have done something
    // wrong -- for instance returned the wrong thing from a story
    renderError(storyId, { title, description }) {
      let renderId = this.currentRender?.renderId;
      this.channel.emit(STORY_ERRORED, { title, description }), this.channel.emit(STORY_RENDER_PHASE_CHANGED, { newPhase: "errored", renderId, storyId }), this.view.showErrorDisplay({ message: title, stack: description }), logger.error(`Error rendering story ${title}: ${description}`);
    }
  };
  __name(_PreviewWithSelection, "PreviewWithSelection");
  var PreviewWithSelection = _PreviewWithSelection, import_picoquery2 = __toESM(require_main(), 1), import_picoquery = __toESM(require_main(), 1), VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/, NUMBER_REGEXP = /^-?[0-9]+(\.[0-9]+)?$/, HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, COLOR_REGEXP = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i, validateArgs = __name((key = "", value2) => key === null || key === "" || !VALIDATION_REGEXP.test(key) ? !1 : value2 == null || value2 instanceof Date || typeof value2 == "number" || typeof value2 == "boolean" ? !0 : typeof value2 == "string" ? VALIDATION_REGEXP.test(value2) || NUMBER_REGEXP.test(value2) || HEX_REGEXP.test(value2) || COLOR_REGEXP.test(value2) : Array.isArray(value2) ? value2.every((v3) => validateArgs(key, v3)) : isPlainObject(value2) ? Object.entries(value2).every(([k3, v3]) => validateArgs(k3, v3)) : !1, "validateArgs"), QUERY_OPTIONS = {
    delimiter: ";",
    // we're parsing a single query param
    nesting: !0,
    arrayRepeat: !0,
    arrayRepeatSyntax: "bracket",
    nestingSyntax: "js",
    // objects are encoded using dot notation
    valueDeserializer(str2) {
      if (str2.startsWith("!")) {
        if (str2 === "!undefined")
          return;
        if (str2 === "!null")
          return null;
        if (str2 === "!true")
          return !0;
        if (str2 === "!false")
          return !1;
        if (str2.startsWith("!date(") && str2.endsWith(")"))
          return new Date(str2.replaceAll(" ", "+").slice(6, -1));
        if (str2.startsWith("!hex(") && str2.endsWith(")"))
          return `#${str2.slice(5, -1)}`;
        let color2 = str2.slice(1).match(COLOR_REGEXP);
        if (color2)
          return str2.startsWith("!rgba") || str2.startsWith("!RGBA") ? `${color2[1]}(${color2[2]}, ${color2[3]}, ${color2[4]}, ${color2[5]})` : str2.startsWith("!hsla") || str2.startsWith("!HSLA") ? `${color2[1]}(${color2[2]}, ${color2[3]}%, ${color2[4]}%, ${color2[5]})` : str2.startsWith("!rgb") || str2.startsWith("!RGB") ? `${color2[1]}(${color2[2]}, ${color2[3]}, ${color2[4]})` : `${color2[1]}(${color2[2]}, ${color2[3]}%, ${color2[4]}%)`;
      }
      return NUMBER_REGEXP.test(str2) ? Number(str2) : str2;
    }
  }, parseArgsParam = __name((argsString) => {
    let parts = argsString.split(";").map((part) => part.replace("=", "~").replace(":", "="));
    return Object.entries((0, import_picoquery.parse)(parts.join(";"), QUERY_OPTIONS)).reduce((acc, [key, value2]) => validateArgs(key, value2) ? Object.assign(acc, { [key]: value2 }) : (once.warn(dedent`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), acc), {});
  }, "parseArgsParam"), { history, document: document2 } = scope;
  function pathToId(path) {
    let match = (path || "").match(/^\/story\/(.+)/);
    if (!match)
      throw new Error(`Invalid path '${path}',  must start with '/story/'`);
    return match[1];
  }
  __name(pathToId, "pathToId");
  var getQueryString = __name(({
    selection,
    extraParams
  }) => {
    let search = document2?.location.search.slice(1), { path, selectedKind, selectedStory, ...rest } = (0, import_picoquery2.parse)(search);
    return `?${(0, import_picoquery2.stringify)({
      ...rest,
      ...extraParams,
      ...selection && { id: selection.storyId, viewMode: selection.viewMode }
    })}`;
  }, "getQueryString"), setPath = __name((selection) => {
    if (!selection)
      return;
    let query = getQueryString({ selection }), { hash = "" } = document2.location;
    document2.title = selection.storyId, history.replaceState({}, "", `${document2.location.pathname}${query}${hash}`);
  }, "setPath"), isObject = __name((val) => val != null && typeof val == "object" && Array.isArray(val) === !1, "isObject"), getFirstString = __name((v3) => {
    if (v3 !== void 0) {
      if (typeof v3 == "string")
        return v3;
      if (Array.isArray(v3))
        return getFirstString(v3[0]);
      if (isObject(v3))
        return getFirstString(
          Object.values(v3).filter(Boolean)
        );
    }
  }, "getFirstString"), getSelectionSpecifierFromPath = __name(() => {
    if (typeof document2 < "u") {
      let queryStr = document2.location.search.slice(1), query = (0, import_picoquery2.parse)(queryStr), args = typeof query.args == "string" ? parseArgsParam(query.args) : void 0, globals = typeof query.globals == "string" ? parseArgsParam(query.globals) : void 0, viewMode = getFirstString(query.viewMode);
      (typeof viewMode != "string" || !viewMode.match(/docs|story/)) && (viewMode = "story");
      let path = getFirstString(query.path), storyId = path ? pathToId(path) : getFirstString(query.id);
      if (storyId)
        return { storySpecifier: storyId, args, globals, viewMode };
    }
    return null;
  }, "getSelectionSpecifierFromPath"), _UrlStore = class {
    constructor() {
      this.selectionSpecifier = getSelectionSpecifierFromPath();
    }
    setSelection(selection) {
      this.selection = selection, setPath(this.selection);
    }
    setQueryParams(queryParams) {
      let query = getQueryString({ extraParams: queryParams }), { hash = "" } = document2.location;
      history.replaceState({}, "", `${document2.location.pathname}${query}${hash}`);
    }
  };
  __name(_UrlStore, "UrlStore");
  var UrlStore = _UrlStore, import_ansi_to_html = __toESM(require_ansi_to_html(), 1), import_picoquery3 = __toESM(require_main(), 1), { document: document3 } = scope, PREPARING_DELAY = 100, Mode = ((Mode2) => (Mode2.MAIN = "MAIN", Mode2.NOPREVIEW = "NOPREVIEW", Mode2.PREPARING_STORY = "PREPARING_STORY", Mode2.PREPARING_DOCS = "PREPARING_DOCS", Mode2.ERROR = "ERROR", Mode2))(Mode || {}), classes = {
    PREPARING_STORY: "sb-show-preparing-story",
    PREPARING_DOCS: "sb-show-preparing-docs",
    MAIN: "sb-show-main",
    NOPREVIEW: "sb-show-nopreview",
    ERROR: "sb-show-errordisplay"
  }, layoutClassMap = {
    centered: "sb-main-centered",
    fullscreen: "sb-main-fullscreen",
    padded: "sb-main-padded"
  }, ansiConverter = new import_ansi_to_html.default({
    escapeXML: !0
  }), _WebView = class {
    constructor() {
      if (this.testing = !1, typeof document3 < "u") {
        let { __SPECIAL_TEST_PARAMETER__ } = (0, import_picoquery3.parse)(document3.location.search.slice(1));
        switch (__SPECIAL_TEST_PARAMETER__) {
          case "preparing-story": {
            this.showPreparingStory(), this.testing = !0;
            break;
          }
          case "preparing-docs": {
            this.showPreparingDocs(), this.testing = !0;
            break;
          }
          default:
        }
      }
    }
    // Get ready to render a story, returning the element to render to
    prepareForStory(story) {
      return this.showStory(), this.applyLayout(story.parameters.layout), document3.documentElement.scrollTop = 0, document3.documentElement.scrollLeft = 0, this.storyRoot();
    }
    storyRoot() {
      return document3.getElementById("storybook-root");
    }
    prepareForDocs() {
      return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), document3.documentElement.scrollTop = 0, document3.documentElement.scrollLeft = 0, this.docsRoot();
    }
    docsRoot() {
      return document3.getElementById("storybook-docs");
    }
    applyLayout(layout = "padded") {
      if (layout === "none") {
        document3.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
        return;
      }
      this.checkIfLayoutExists(layout);
      let layoutClass = layoutClassMap[layout];
      document3.body.classList.remove(this.currentLayoutClass), document3.body.classList.add(layoutClass), this.currentLayoutClass = layoutClass;
    }
    checkIfLayoutExists(layout) {
      layoutClassMap[layout] || logger.warn(
        dedent`
          The desired layout: ${layout} is not a valid option.
          The possible options are: ${Object.keys(layoutClassMap).join(", ")}, none.
        `
      );
    }
    showMode(mode) {
      clearTimeout(this.preparingTimeout), Object.keys(Mode).forEach((otherMode) => {
        otherMode === mode ? document3.body.classList.add(classes[otherMode]) : document3.body.classList.remove(classes[otherMode]);
      });
    }
    showErrorDisplay({ message = "", stack = "" }) {
      let header = message, detail = stack, parts = message.split(`
`);
      parts.length > 1 && ([header] = parts, detail = parts.slice(1).join(`
`).replace(/^\n/, "")), document3.getElementById("error-message").innerHTML = ansiConverter.toHtml(header), document3.getElementById("error-stack").innerHTML = ansiConverter.toHtml(detail), this.showMode(
        "ERROR"
        /* ERROR */
      );
    }
    showNoPreview() {
      this.testing || (this.showMode(
        "NOPREVIEW"
        /* NOPREVIEW */
      ), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
    }
    showPreparingStory({ immediate = !1 } = {}) {
      clearTimeout(this.preparingTimeout), immediate ? this.showMode(
        "PREPARING_STORY"
        /* PREPARING_STORY */
      ) : this.preparingTimeout = setTimeout(
        () => this.showMode(
          "PREPARING_STORY"
          /* PREPARING_STORY */
        ),
        PREPARING_DELAY
      );
    }
    showPreparingDocs({ immediate = !1 } = {}) {
      clearTimeout(this.preparingTimeout), immediate ? this.showMode(
        "PREPARING_DOCS"
        /* PREPARING_DOCS */
      ) : this.preparingTimeout = setTimeout(() => this.showMode(
        "PREPARING_DOCS"
        /* PREPARING_DOCS */
      ), PREPARING_DELAY);
    }
    showMain() {
      this.showMode(
        "MAIN"
        /* MAIN */
      );
    }
    showDocs() {
      this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
    }
    showStory() {
      this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
    }
    showStoryDuringRender() {
      document3.body.classList.add(classes.MAIN);
    }
  };
  __name(_WebView, "WebView");
  var WebView = _WebView, _PreviewWeb = class extends PreviewWithSelection {
    constructor(importFn, getProjectAnnotations) {
      super(importFn, getProjectAnnotations, new UrlStore(), new WebView()), this.importFn = importFn, this.getProjectAnnotations = getProjectAnnotations, scope.__STORYBOOK_PREVIEW__ = this;
    }
  };
  __name(_PreviewWeb, "PreviewWeb");
  var { document: document4 } = scope, runScriptTypes = [
    "application/javascript",
    "application/ecmascript",
    "application/x-ecmascript",
    "application/x-javascript",
    "text/ecmascript",
    "text/javascript",
    "text/javascript1.0",
    "text/javascript1.1",
    "text/javascript1.2",
    "text/javascript1.3",
    "text/javascript1.4",
    "text/javascript1.5",
    "text/jscript",
    "text/livescript",
    "text/x-ecmascript",
    "text/x-javascript",
    // Support modern javascript
    "module"
  ], SCRIPT = "script", SCRIPTS_ROOT_ID = "scripts-root";
  function simulateDOMContentLoaded() {
    let DOMContentLoadedEvent = document4.createEvent("Event");
    DOMContentLoadedEvent.initEvent("DOMContentLoaded", !0, !0), document4.dispatchEvent(DOMContentLoadedEvent);
  }
  __name(simulateDOMContentLoaded, "simulateDOMContentLoaded");
  function insertScript($script, callback, $scriptRoot) {
    let scriptEl = document4.createElement("script");
    scriptEl.type = $script.type === "module" ? "module" : "text/javascript", $script.src ? (scriptEl.onload = callback, scriptEl.onerror = callback, scriptEl.src = $script.src) : scriptEl.textContent = $script.innerText, $scriptRoot ? $scriptRoot.appendChild(scriptEl) : document4.head.appendChild(scriptEl), $script.parentNode.removeChild($script), $script.src || callback();
  }
  __name(insertScript, "insertScript");
  function insertScriptsSequentially(scriptsToExecute, callback, index2 = 0) {
    scriptsToExecute[index2](() => {
      index2++, index2 === scriptsToExecute.length ? callback() : insertScriptsSequentially(scriptsToExecute, callback, index2);
    });
  }
  __name(insertScriptsSequentially, "insertScriptsSequentially");
  function simulatePageLoad($container) {
    let $scriptsRoot = document4.getElementById(SCRIPTS_ROOT_ID);
    $scriptsRoot ? $scriptsRoot.innerHTML = "" : ($scriptsRoot = document4.createElement("div"), $scriptsRoot.id = SCRIPTS_ROOT_ID, document4.body.appendChild($scriptsRoot));
    let $scripts = Array.from($container.querySelectorAll(SCRIPT));
    if ($scripts.length) {
      let scriptsToExecute = [];
      $scripts.forEach(($script) => {
        let typeAttr = $script.getAttribute("type");
        (!typeAttr || runScriptTypes.includes(typeAttr)) && scriptsToExecute.push((callback) => insertScript($script, callback, $scriptsRoot));
      }), scriptsToExecute.length && insertScriptsSequentially(scriptsToExecute, simulateDOMContentLoaded, void 0);
    } else
      simulateDOMContentLoaded();
  }
  __name(simulatePageLoad, "simulatePageLoad");
  async function emitTransformCode(source, context) {
    let transform = context.parameters?.docs?.source?.transform, { id: id2, unmappedArgs } = context, transformed = transform && source ? transform?.(source, context) : source, result = transformed ? await transformed : void 0;
    addons2.getChannel().emit(SNIPPET_RENDERED, {
      id: id2,
      source: result,
      args: unmappedArgs
    });
  }
  __name(emitTransformCode, "emitTransformCode");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/csf/index.js
  init_chunk_AB7OOPUX();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-GTKOCWCT.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var ADDON_ID7 = "storybook/highlight", HIGHLIGHT = `${ADDON_ID7}/add`, REMOVE_HIGHLIGHT = `${ADDON_ID7}/remove`, RESET_HIGHLIGHT = `${ADDON_ID7}/reset`, SCROLL_INTO_VIEW = `${ADDON_ID7}/scroll-into-view`, MAX_Z_INDEX = 2147483647, MIN_TOUCH_AREA_SIZE = 28;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-ECQ75MKQ.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-PB6FZ3WE.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/preview-api/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_AB7OOPUX();
  init_chunk_MM7DTO55();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-PB6FZ3WE.js
  var config = {
    depth: 10,
    clearOnStoryChange: !0,
    limit: 50
  }, configureActions = __name((options = {}) => {
    Object.assign(config, options);
  }, "configureActions"), findProto = __name((obj, callback) => {
    let proto = Object.getPrototypeOf(obj);
    return !proto || callback(proto) ? proto : findProto(proto, callback);
  }, "findProto"), isReactSyntheticEvent = __name((e) => !!(typeof e == "object" && e && findProto(e, (proto) => /^Synthetic(?:Base)?Event$/.test(proto.constructor.name)) && typeof e.persist == "function"), "isReactSyntheticEvent"), serializeArg = __name((a3) => {
    if (isReactSyntheticEvent(a3)) {
      let e = Object.create(
        a3.constructor.prototype,
        Object.getOwnPropertyDescriptors(a3)
      );
      e.persist();
      let viewDescriptor = Object.getOwnPropertyDescriptor(e, "view"), view = viewDescriptor?.value;
      return typeof view == "object" && view?.constructor.name === "Window" && Object.defineProperty(e, "view", {
        ...viewDescriptor,
        value: Object.create(view.constructor.prototype)
      }), e;
    }
    return a3;
  }, "serializeArg");
  function action(name, options = {}) {
    let actionOptions = {
      ...config,
      ...options
    }, handler = __name(function(...args) {
      if (options.implicit) {
        let storyRenderer = ("__STORYBOOK_PREVIEW__" in scope ? scope.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
          (render) => render.phase === "playing" || render.phase === "rendering"
        );
        if (storyRenderer) {
          let deprecated = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, error = new ImplicitActionsDuringRendering({
            phase: storyRenderer.phase,
            name,
            deprecated
          });
          if (deprecated)
            console.warn(error);
          else
            throw error;
        }
      }
      let channel = addons2.getChannel(), id2 = Date.now().toString(36) + Math.random().toString(36).substring(2), minDepth = 5, serializedArgs = args.map(serializeArg), normalizedArgs = args.length > 1 ? serializedArgs : serializedArgs[0], actionDisplayToEmit = {
        id: id2,
        count: 0,
        data: { name, args: normalizedArgs },
        options: {
          ...actionOptions,
          maxDepth: minDepth + (actionOptions.depth || 3)
        }
      };
      channel.emit(EVENT_ID, actionDisplayToEmit);
    }, "actionHandler");
    return handler.isAction = !0, handler.implicit = options.implicit, handler;
  }
  __name(action, "action");
  var actions = __name((...args) => {
    let options = config, names = args;
    names.length === 1 && Array.isArray(names[0]) && ([names] = names), names.length !== 1 && typeof names[names.length - 1] != "string" && (options = {
      ...config,
      ...names.pop()
    });
    let namesObject = names[0];
    (names.length !== 1 || typeof namesObject == "string") && (namesObject = {}, names.forEach((name) => {
      namesObject[name] = name;
    }));
    let actionsObject = {};
    return Object.keys(namesObject).forEach((name) => {
      actionsObject[name] = action(namesObject[name], options);
    }), actionsObject;
  }, "actions");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/csf/index.js
  init_chunk_MM7DTO55();

  // global-externals:storybook/test
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  var test_default = __STORYBOOK_TEST__, { buildQueries, clearAllMocks, configure, createEvent, expect, findAllByAltText, findAllByDisplayValue, findAllByLabelText, findAllByPlaceholderText, findAllByRole, findAllByTestId, findAllByText, findAllByTitle, findByAltText, findByDisplayValue, findByLabelText, findByPlaceholderText, findByRole, findByTestId, findByText, findByTitle, fireEvent, fn, getAllByAltText, getAllByDisplayValue, getAllByLabelText, getAllByPlaceholderText, getAllByRole, getAllByTestId, getAllByText, getAllByTitle, getByAltText, getByDisplayValue, getByLabelText, getByPlaceholderText, getByRole, getByTestId, getByText, getByTitle, getConfig, getDefaultNormalizer, getElementError, getNodeText, getQueriesForElement, getRoles, getSuggestedQuery, isInaccessible, isMockFunction, logDOM, logRoles, mocked, mocks, onMockCall, prettyDOM, prettyFormat, queries, queryAllByAltText, queryAllByAttribute, queryAllByDisplayValue, queryAllByLabelText, queryAllByPlaceholderText, queryAllByRole, queryAllByTestId, queryAllByText, queryAllByTitle, queryByAltText, queryByAttribute, queryByDisplayValue, queryByLabelText, queryByPlaceholderText, queryByRole, queryByTestId, queryByText, queryByTitle, queryHelpers, resetAllMocks, restoreAllMocks, sb, screen, spyOn, uninstrumentedUserEvent, userEvent, waitFor, waitForElementToBeRemoved, within } = __STORYBOOK_TEST__;

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/instrumenter/index.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/_browser-chunks/chunk-JVSKG4YS.js
  init_define_module();
  init_define_process_env();
  init_define_process_env_NODE_PATH();
  init_chunk_MM7DTO55();
  var f = {
    reset: [0, 0],
    bold: [1, 22, "\x1B[22m\x1B[1m"],
    dim: [2, 22, "\x1B[22m\x1B[2m"],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBright: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
    bgBlackBright: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }, h = Object.entries(f);
  function a(n2) {
    return String(n2);
  }
  __name(a, "a");
  a.open = "";
  a.close = "";
  var B = h.reduce(
    (n2, [e]) => (n2[e] = a, n2),
    { isColorSupported: !1 }
  );
  function C(n2 = !1) {
    let e = typeof process < "u" ? process : void 0, i3 = e?.env || {}, g3 = e?.argv || [];
    return !("NO_COLOR" in i3 || g3.includes("--no-color")) && ("FORCE_COLOR" in i3 || g3.includes("--color") || e?.platform === "win32" || n2 && i3.TERM !== "dumb" || "CI" in i3) || typeof window < "u" && !!window.chrome;
  }
  __name(C, "C");
  function p(n2 = !1) {
    let e = C(n2), i3 = __name((r2, t, c3, o2) => {
      let l2 = "", s22 = 0;
      do
        l2 += r2.substring(s22, o2) + c3, s22 = o2 + t.length, o2 = r2.indexOf(t, s22);
      while (~o2);
      return l2 + r2.substring(s22);
    }, "i"), g3 = __name((r2, t, c3 = r2) => {
      let o2 = __name((l2) => {
        let s22 = String(l2), b3 = s22.indexOf(t, r2.length);
        return ~b3 ? r2 + i3(s22, t, c3, b3) + t : r2 + s22 + t;
      }, "o");
      return o2.open = r2, o2.close = t, o2;
    }, "g"), u3 = {
      isColorSupported: e
    }, d3 = __name((r2) => `\x1B[${r2}m`, "d");
    for (let [r2, t] of h)
      u3[r2] = e ? g3(
        d3(t[0]),
        d3(t[1]),
        t[2]
      ) : a;
    return u3;
  }
  __name(p, "p");
  var s = p();
  function _mergeNamespaces(n2, m22) {
    return m22.forEach(function(e) {
      e && typeof e != "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k3) {
        if (k3 !== "default" && !(k3 in n2)) {
          var d3 = Object.getOwnPropertyDescriptor(e, k3);
          Object.defineProperty(n2, k3, d3.get ? d3 : {
            enumerable: !0,
            get: __name(function() {
              return e[k3];
            }, "get")
          });
        }
      });
    }), Object.freeze(n2);
  }
  __name(_mergeNamespaces, "_mergeNamespaces");
  function getKeysOfEnumerableProperties(object2, compareKeys) {
    let rawKeys = Object.keys(object2), keys = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
    if (Object.getOwnPropertySymbols)
      for (let symbol of Object.getOwnPropertySymbols(object2))
        Object.getOwnPropertyDescriptor(object2, symbol).enumerable && keys.push(symbol);
    return keys;
  }
  __name(getKeysOfEnumerableProperties, "getKeysOfEnumerableProperties");
  function printIteratorEntries(iterator, config2, indentation, depth, refs, printer2, separator = ": ") {
    let result = "", width = 0, current = iterator.next();
    if (!current.done) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (; !current.done; ) {
        if (result += indentationNext, width++ === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        let name = printer2(current.value[0], config2, indentationNext, depth, refs), value2 = printer2(current.value[1], config2, indentationNext, depth, refs);
        result += name + separator + value2, current = iterator.next(), current.done ? config2.min || (result += ",") : result += `,${config2.spacingInner}`;
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  __name(printIteratorEntries, "printIteratorEntries");
  function printIteratorValues(iterator, config2, indentation, depth, refs, printer2) {
    let result = "", width = 0, current = iterator.next();
    if (!current.done) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (; !current.done; ) {
        if (result += indentationNext, width++ === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        result += printer2(current.value, config2, indentationNext, depth, refs), current = iterator.next(), current.done ? config2.min || (result += ",") : result += `,${config2.spacingInner}`;
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  __name(printIteratorValues, "printIteratorValues");
  function printListItems(list, config2, indentation, depth, refs, printer2) {
    let result = "";
    list = list instanceof ArrayBuffer ? new DataView(list) : list;
    let isDataView = __name((l2) => l2 instanceof DataView, "isDataView"), length2 = isDataView(list) ? list.byteLength : list.length;
    if (length2 > 0) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (let i3 = 0; i3 < length2; i3++) {
        if (result += indentationNext, i3 === config2.maxWidth) {
          result += "\u2026";
          break;
        }
        (isDataView(list) || i3 in list) && (result += printer2(isDataView(list) ? list.getInt8(i3) : list[i3], config2, indentationNext, depth, refs)), i3 < length2 - 1 ? result += `,${config2.spacingInner}` : config2.min || (result += ",");
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  __name(printListItems, "printListItems");
  function printObjectProperties(val, config2, indentation, depth, refs, printer2) {
    let result = "", keys = getKeysOfEnumerableProperties(val, config2.compareKeys);
    if (keys.length > 0) {
      result += config2.spacingOuter;
      let indentationNext = indentation + config2.indent;
      for (let i3 = 0; i3 < keys.length; i3++) {
        let key = keys[i3], name = printer2(key, config2, indentationNext, depth, refs), value2 = printer2(val[key], config2, indentationNext, depth, refs);
        result += `${indentationNext + name}: ${value2}`, i3 < keys.length - 1 ? result += `,${config2.spacingInner}` : config2.min || (result += ",");
      }
      result += config2.spacingOuter + indentation;
    }
    return result;
  }
  __name(printObjectProperties, "printObjectProperties");
  var asymmetricMatcher = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, SPACE$2 = " ", serialize$5 = __name((val, config2, indentation, depth, refs, printer2) => {
    let stringedValue = val.toString();
    if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining")
      return ++depth > config2.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}[${printListItems(val.sample, config2, indentation, depth, refs, printer2)}]`;
    if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining")
      return ++depth > config2.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config2, indentation, depth, refs, printer2)}}`;
    if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining")
      return stringedValue + SPACE$2 + printer2(val.sample, config2, indentation, depth, refs);
    if (typeof val.toAsymmetricMatcher != "function")
      throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
    return val.toAsymmetricMatcher();
  }, "serialize$5"), test$5 = __name((val) => val && val.$$typeof === asymmetricMatcher, "test$5"), plugin$5 = {
    serialize: serialize$5,
    test: test$5
  }, SPACE$1 = " ", OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
  function testName(name) {
    return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
  }
  __name(testName, "testName");
  var test$4 = __name((val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name), "test$4");
  function isNamedNodeMap(collection) {
    return collection.constructor.name === "NamedNodeMap";
  }
  __name(isNamedNodeMap, "isNamedNodeMap");
  var serialize$4 = __name((collection, config2, indentation, depth, refs, printer2) => {
    let name = collection.constructor.name;
    return ++depth > config2.maxDepth ? `[${name}]` : (config2.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config2, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config2, indentation, depth, refs, printer2)}]`);
  }, "serialize$4"), plugin$4 = {
    serialize: serialize$4,
    test: test$4
  };
  function escapeHTML(str2) {
    return str2.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
  }
  __name(escapeHTML, "escapeHTML");
  function printProps(keys, props, config2, indentation, depth, refs, printer2) {
    let indentationNext = indentation + config2.indent, colors3 = config2.colors;
    return keys.map((key) => {
      let value2 = props[key], printed = printer2(value2, config2, indentationNext, depth, refs);
      return typeof value2 != "string" && (printed.includes(`
`) && (printed = config2.spacingOuter + indentationNext + printed + config2.spacingOuter + indentation), printed = `{${printed}}`), `${config2.spacingInner + indentation + colors3.prop.open + key + colors3.prop.close}=${colors3.value.open}${printed}${colors3.value.close}`;
    }).join("");
  }
  __name(printProps, "printProps");
  function printChildren(children, config2, indentation, depth, refs, printer2) {
    return children.map((child) => config2.spacingOuter + indentation + (typeof child == "string" ? printText(child, config2) : printer2(child, config2, indentation, depth, refs))).join("");
  }
  __name(printChildren, "printChildren");
  function printText(text, config2) {
    let contentColor = config2.colors.content;
    return contentColor.open + escapeHTML(text) + contentColor.close;
  }
  __name(printText, "printText");
  function printComment(comment, config2) {
    let commentColor = config2.colors.comment;
    return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
  }
  __name(printComment, "printComment");
  function printElement(type, printedProps, printedChildren, config2, indentation) {
    let tagColor = config2.colors.tag;
    return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config2.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config2.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config2.min ? "" : " "}/`}>${tagColor.close}`;
  }
  __name(printElement, "printElement");
  function printElementAsLeaf(type, config2) {
    let tagColor = config2.colors.tag;
    return `${tagColor.open}<${type}${tagColor.close} \u2026${tagColor.open} />${tagColor.close}`;
  }
  __name(printElementAsLeaf, "printElementAsLeaf");
  var ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, FRAGMENT_NODE = 11, ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
  function testHasAttribute(val) {
    try {
      return typeof val.hasAttribute == "function" && val.hasAttribute("is");
    } catch {
      return !1;
    }
  }
  __name(testHasAttribute, "testHasAttribute");
  function testNode(val) {
    let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement = typeof tagName == "string" && tagName.includes("-") || testHasAttribute(val);
    return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
  }
  __name(testNode, "testNode");
  var test$3 = __name((val) => {
    var _val$constructor;
    return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
  }, "test$3");
  function nodeIsText(node) {
    return node.nodeType === TEXT_NODE;
  }
  __name(nodeIsText, "nodeIsText");
  function nodeIsComment(node) {
    return node.nodeType === COMMENT_NODE;
  }
  __name(nodeIsComment, "nodeIsComment");
  function nodeIsFragment(node) {
    return node.nodeType === FRAGMENT_NODE;
  }
  __name(nodeIsFragment, "nodeIsFragment");
  var serialize$3 = __name((node, config2, indentation, depth, refs, printer2) => {
    if (nodeIsText(node))
      return printText(node.data, config2);
    if (nodeIsComment(node))
      return printComment(node.data, config2);
    let type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
    return ++depth > config2.maxDepth ? printElementAsLeaf(type, config2) : printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config2, indentation + config2.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation);
  }, "serialize$3"), plugin$3 = {
    serialize: serialize$3,
    test: test$3
  }, IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@", getImmutableName = __name((name) => `Immutable.${name}`, "getImmutableName"), printAsLeaf = __name((name) => `[${name}]`, "printAsLeaf"), SPACE = " ", LAZY = "\u2026";
  function printImmutableEntries(val, config2, indentation, depth, refs, printer2, type) {
    return ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer2)}}`;
  }
  __name(printImmutableEntries, "printImmutableEntries");
  function getRecordEntries(val) {
    let i3 = 0;
    return { next() {
      if (i3 < val._keys.length) {
        let key = val._keys[i3++];
        return {
          done: !1,
          value: [key, val.get(key)]
        };
      }
      return {
        done: !0,
        value: void 0
      };
    } };
  }
  __name(getRecordEntries, "getRecordEntries");
  function printImmutableRecord(val, config2, indentation, depth, refs, printer2) {
    let name = getImmutableName(val._name || "Record");
    return ++depth > config2.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config2, indentation, depth, refs, printer2)}}`;
  }
  __name(printImmutableRecord, "printImmutableRecord");
  function printImmutableSeq(val, config2, indentation, depth, refs, printer2) {
    let name = getImmutableName("Seq");
    return ++depth > config2.maxDepth ? printAsLeaf(name) : val[IS_KEYED_SENTINEL] ? `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer2) : LAZY}}` : `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config2, indentation, depth, refs, printer2) : LAZY}]`;
  }
  __name(printImmutableSeq, "printImmutableSeq");
  function printImmutableValues(val, config2, indentation, depth, refs, printer2, type) {
    return ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${printIteratorValues(val.values(), config2, indentation, depth, refs, printer2)}]`;
  }
  __name(printImmutableValues, "printImmutableValues");
  var serialize$2 = __name((val, config2, indentation, depth, refs, printer2) => val[IS_MAP_SENTINEL] ? printImmutableEntries(val, config2, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, "List") : val[IS_SET_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, "Stack") : val[IS_SEQ_SENTINEL] ? printImmutableSeq(val, config2, indentation, depth, refs, printer2) : printImmutableRecord(val, config2, indentation, depth, refs, printer2), "serialize$2"), test$2 = __name((val) => val && (val[IS_ITERABLE_SENTINEL] === !0 || val[IS_RECORD_SENTINEL] === !0), "test$2"), plugin$2 = {
    serialize: serialize$2,
    test: test$2
  };
  function getDefaultExportFromCjs(x3) {
    return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3.default : x3;
  }
  __name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
  var reactIs$1 = { exports: {} }, reactIs_production = {}, hasRequiredReactIs_production;
  function requireReactIs_production() {
    if (hasRequiredReactIs_production) return reactIs_production;
    hasRequiredReactIs_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function typeOf(object2) {
      if (typeof object2 == "object" && object2 !== null) {
        var $$typeof = object2.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object2 = object2.type, object2) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object2;
              default:
                switch (object2 = object2 && object2.$$typeof, object2) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object2;
                  case REACT_CONSUMER_TYPE:
                    return object2;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    return __name(typeOf, "typeOf"), reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_production.ContextProvider = REACT_CONTEXT_TYPE, reactIs_production.Element = REACT_ELEMENT_TYPE, reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_production.Fragment = REACT_FRAGMENT_TYPE, reactIs_production.Lazy = REACT_LAZY_TYPE, reactIs_production.Memo = REACT_MEMO_TYPE, reactIs_production.Portal = REACT_PORTAL_TYPE, reactIs_production.Profiler = REACT_PROFILER_TYPE, reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_production.Suspense = REACT_SUSPENSE_TYPE, reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_production.isContextConsumer = function(object2) {
      return typeOf(object2) === REACT_CONSUMER_TYPE;
    }, reactIs_production.isContextProvider = function(object2) {
      return typeOf(object2) === REACT_CONTEXT_TYPE;
    }, reactIs_production.isElement = function(object2) {
      return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
    }, reactIs_production.isForwardRef = function(object2) {
      return typeOf(object2) === REACT_FORWARD_REF_TYPE;
    }, reactIs_production.isFragment = function(object2) {
      return typeOf(object2) === REACT_FRAGMENT_TYPE;
    }, reactIs_production.isLazy = function(object2) {
      return typeOf(object2) === REACT_LAZY_TYPE;
    }, reactIs_production.isMemo = function(object2) {
      return typeOf(object2) === REACT_MEMO_TYPE;
    }, reactIs_production.isPortal = function(object2) {
      return typeOf(object2) === REACT_PORTAL_TYPE;
    }, reactIs_production.isProfiler = function(object2) {
      return typeOf(object2) === REACT_PROFILER_TYPE;
    }, reactIs_production.isStrictMode = function(object2) {
      return typeOf(object2) === REACT_STRICT_MODE_TYPE;
    }, reactIs_production.isSuspense = function(object2) {
      return typeOf(object2) === REACT_SUSPENSE_TYPE;
    }, reactIs_production.isSuspenseList = function(object2) {
      return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
    }, reactIs_production.isValidElementType = function(type) {
      return typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0);
    }, reactIs_production.typeOf = typeOf, reactIs_production;
  }
  __name(requireReactIs_production, "requireReactIs_production");
  var reactIs_development$1 = {}, hasRequiredReactIs_development$1;
  function requireReactIs_development$1() {
    return hasRequiredReactIs_development$1 || (hasRequiredReactIs_development$1 = 1, (function() {
      function typeOf(object2) {
        if (typeof object2 == "object" && object2 !== null) {
          var $$typeof = object2.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object2 = object2.type, object2) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_VIEW_TRANSITION_TYPE:
                  return object2;
                default:
                  switch (object2 = object2 && object2.$$typeof, object2) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object2;
                    case REACT_CONSUMER_TYPE:
                      return object2;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      __name(typeOf, "typeOf");
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE, reactIs_development$1.Element = REACT_ELEMENT_TYPE, reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE, reactIs_development$1.Lazy = REACT_LAZY_TYPE, reactIs_development$1.Memo = REACT_MEMO_TYPE, reactIs_development$1.Portal = REACT_PORTAL_TYPE, reactIs_development$1.Profiler = REACT_PROFILER_TYPE, reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE, reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_development$1.isContextConsumer = function(object2) {
        return typeOf(object2) === REACT_CONSUMER_TYPE;
      }, reactIs_development$1.isContextProvider = function(object2) {
        return typeOf(object2) === REACT_CONTEXT_TYPE;
      }, reactIs_development$1.isElement = function(object2) {
        return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
      }, reactIs_development$1.isForwardRef = function(object2) {
        return typeOf(object2) === REACT_FORWARD_REF_TYPE;
      }, reactIs_development$1.isFragment = function(object2) {
        return typeOf(object2) === REACT_FRAGMENT_TYPE;
      }, reactIs_development$1.isLazy = function(object2) {
        return typeOf(object2) === REACT_LAZY_TYPE;
      }, reactIs_development$1.isMemo = function(object2) {
        return typeOf(object2) === REACT_MEMO_TYPE;
      }, reactIs_development$1.isPortal = function(object2) {
        return typeOf(object2) === REACT_PORTAL_TYPE;
      }, reactIs_development$1.isProfiler = function(object2) {
        return typeOf(object2) === REACT_PROFILER_TYPE;
      }, reactIs_development$1.isStrictMode = function(object2) {
        return typeOf(object2) === REACT_STRICT_MODE_TYPE;
      }, reactIs_development$1.isSuspense = function(object2) {
        return typeOf(object2) === REACT_SUSPENSE_TYPE;
      }, reactIs_development$1.isSuspenseList = function(object2) {
        return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
      }, reactIs_development$1.isValidElementType = function(type) {
        return typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0);
      }, reactIs_development$1.typeOf = typeOf;
    })()), reactIs_development$1;
  }
  __name(requireReactIs_development$1, "requireReactIs_development$1");
  var hasRequiredReactIs$1;
  function requireReactIs$1() {
    return hasRequiredReactIs$1 || (hasRequiredReactIs$1 = 1, reactIs$1.exports = requireReactIs_development$1()), reactIs$1.exports;
  }
  __name(requireReactIs$1, "requireReactIs$1");
  var reactIsExports$1 = requireReactIs$1(), index$1 = getDefaultExportFromCjs(reactIsExports$1), ReactIs19 = _mergeNamespaces({
    __proto__: null,
    default: index$1
  }, [reactIsExports$1]), reactIs = { exports: {} }, reactIs_production_min = {}, hasRequiredReactIs_production_min;
  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b3 = Symbol.for("react.element"), c3 = Symbol.for("react.portal"), d3 = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f22 = Symbol.for("react.profiler"), g3 = Symbol.for("react.provider"), h22 = Symbol.for("react.context"), k3 = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m22 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p22 = Symbol.for("react.memo"), q3 = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u3;
    u3 = Symbol.for("react.module.reference");
    function v3(a22) {
      if (typeof a22 == "object" && a22 !== null) {
        var r2 = a22.$$typeof;
        switch (r2) {
          case b3:
            switch (a22 = a22.type, a22) {
              case d3:
              case f22:
              case e:
              case m22:
              case n2:
                return a22;
              default:
                switch (a22 = a22 && a22.$$typeof, a22) {
                  case k3:
                  case h22:
                  case l2:
                  case q3:
                  case p22:
                  case g3:
                    return a22;
                  default:
                    return r2;
                }
            }
          case c3:
            return r2;
        }
      }
    }
    return __name(v3, "v"), reactIs_production_min.ContextConsumer = h22, reactIs_production_min.ContextProvider = g3, reactIs_production_min.Element = b3, reactIs_production_min.ForwardRef = l2, reactIs_production_min.Fragment = d3, reactIs_production_min.Lazy = q3, reactIs_production_min.Memo = p22, reactIs_production_min.Portal = c3, reactIs_production_min.Profiler = f22, reactIs_production_min.StrictMode = e, reactIs_production_min.Suspense = m22, reactIs_production_min.SuspenseList = n2, reactIs_production_min.isAsyncMode = function() {
      return !1;
    }, reactIs_production_min.isConcurrentMode = function() {
      return !1;
    }, reactIs_production_min.isContextConsumer = function(a22) {
      return v3(a22) === h22;
    }, reactIs_production_min.isContextProvider = function(a22) {
      return v3(a22) === g3;
    }, reactIs_production_min.isElement = function(a22) {
      return typeof a22 == "object" && a22 !== null && a22.$$typeof === b3;
    }, reactIs_production_min.isForwardRef = function(a22) {
      return v3(a22) === l2;
    }, reactIs_production_min.isFragment = function(a22) {
      return v3(a22) === d3;
    }, reactIs_production_min.isLazy = function(a22) {
      return v3(a22) === q3;
    }, reactIs_production_min.isMemo = function(a22) {
      return v3(a22) === p22;
    }, reactIs_production_min.isPortal = function(a22) {
      return v3(a22) === c3;
    }, reactIs_production_min.isProfiler = function(a22) {
      return v3(a22) === f22;
    }, reactIs_production_min.isStrictMode = function(a22) {
      return v3(a22) === e;
    }, reactIs_production_min.isSuspense = function(a22) {
      return v3(a22) === m22;
    }, reactIs_production_min.isSuspenseList = function(a22) {
      return v3(a22) === n2;
    }, reactIs_production_min.isValidElementType = function(a22) {
      return typeof a22 == "string" || typeof a22 == "function" || a22 === d3 || a22 === f22 || a22 === e || a22 === m22 || a22 === n2 || a22 === t || typeof a22 == "object" && a22 !== null && (a22.$$typeof === q3 || a22.$$typeof === p22 || a22.$$typeof === g3 || a22.$$typeof === h22 || a22.$$typeof === l2 || a22.$$typeof === u3 || a22.getModuleId !== void 0);
    }, reactIs_production_min.typeOf = v3, reactIs_production_min;
  }
  __name(requireReactIs_production_min, "requireReactIs_production_min");
  var reactIs_development = {}, hasRequiredReactIs_development;
  function requireReactIs_development() {
    return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0));
      }
      __name(isValidElementType, "isValidElementType");
      function typeOf(object2) {
        if (typeof object2 == "object" && object2 !== null) {
          var $$typeof = object2.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object2.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      __name(typeOf, "typeOf");
      var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment2 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler2 = REACT_PROFILER_TYPE, StrictMode2 = REACT_STRICT_MODE_TYPE, Suspense2 = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1, hasWarnedAboutDeprecatedIsConcurrentMode = !1;
      function isAsyncMode(object2) {
        return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      __name(isAsyncMode, "isAsyncMode");
      function isConcurrentMode(object2) {
        return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      __name(isConcurrentMode, "isConcurrentMode");
      function isContextConsumer(object2) {
        return typeOf(object2) === REACT_CONTEXT_TYPE;
      }
      __name(isContextConsumer, "isContextConsumer");
      function isContextProvider(object2) {
        return typeOf(object2) === REACT_PROVIDER_TYPE;
      }
      __name(isContextProvider, "isContextProvider");
      function isElement(object2) {
        return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
      }
      __name(isElement, "isElement");
      function isForwardRef(object2) {
        return typeOf(object2) === REACT_FORWARD_REF_TYPE;
      }
      __name(isForwardRef, "isForwardRef");
      function isFragment(object2) {
        return typeOf(object2) === REACT_FRAGMENT_TYPE;
      }
      __name(isFragment, "isFragment");
      function isLazy(object2) {
        return typeOf(object2) === REACT_LAZY_TYPE;
      }
      __name(isLazy, "isLazy");
      function isMemo(object2) {
        return typeOf(object2) === REACT_MEMO_TYPE;
      }
      __name(isMemo, "isMemo");
      function isPortal(object2) {
        return typeOf(object2) === REACT_PORTAL_TYPE;
      }
      __name(isPortal, "isPortal");
      function isProfiler(object2) {
        return typeOf(object2) === REACT_PROFILER_TYPE;
      }
      __name(isProfiler, "isProfiler");
      function isStrictMode(object2) {
        return typeOf(object2) === REACT_STRICT_MODE_TYPE;
      }
      __name(isStrictMode, "isStrictMode");
      function isSuspense(object2) {
        return typeOf(object2) === REACT_SUSPENSE_TYPE;
      }
      __name(isSuspense, "isSuspense");
      function isSuspenseList(object2) {
        return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
      }
      __name(isSuspenseList, "isSuspenseList"), reactIs_development.ContextConsumer = ContextConsumer, reactIs_development.ContextProvider = ContextProvider, reactIs_development.Element = Element2, reactIs_development.ForwardRef = ForwardRef, reactIs_development.Fragment = Fragment2, reactIs_development.Lazy = Lazy, reactIs_development.Memo = Memo, reactIs_development.Portal = Portal, reactIs_development.Profiler = Profiler2, reactIs_development.StrictMode = StrictMode2, reactIs_development.Suspense = Suspense2, reactIs_development.SuspenseList = SuspenseList, reactIs_development.isAsyncMode = isAsyncMode, reactIs_development.isConcurrentMode = isConcurrentMode, reactIs_development.isContextConsumer = isContextConsumer, reactIs_development.isContextProvider = isContextProvider, reactIs_development.isElement = isElement, reactIs_development.isForwardRef = isForwardRef, reactIs_development.isFragment = isFragment, reactIs_development.isLazy = isLazy, reactIs_development.isMemo = isMemo, reactIs_development.isPortal = isPortal, reactIs_development.isProfiler = isProfiler, reactIs_development.isStrictMode = isStrictMode, reactIs_development.isSuspense = isSuspense, reactIs_development.isSuspenseList = isSuspenseList, reactIs_development.isValidElementType = isValidElementType, reactIs_development.typeOf = typeOf;
    })()), reactIs_development;
  }
  __name(requireReactIs_development, "requireReactIs_development");
  var hasRequiredReactIs;
  function requireReactIs() {
    return hasRequiredReactIs || (hasRequiredReactIs = 1, reactIs.exports = requireReactIs_development()), reactIs.exports;
  }
  __name(requireReactIs, "requireReactIs");
  var reactIsExports = requireReactIs(), index = getDefaultExportFromCjs(reactIsExports), ReactIs18 = _mergeNamespaces({
    __proto__: null,
    default: index
  }, [reactIsExports]), reactIsMethods = [
    "isAsyncMode",
    "isConcurrentMode",
    "isContextConsumer",
    "isContextProvider",
    "isElement",
    "isForwardRef",
    "isFragment",
    "isLazy",
    "isMemo",
    "isPortal",
    "isProfiler",
    "isStrictMode",
    "isSuspense",
    "isSuspenseList",
    "isValidElementType"
  ], ReactIs = Object.fromEntries(reactIsMethods.map((m22) => [m22, (v3) => ReactIs18[m22](v3) || ReactIs19[m22](v3)]));
  function getChildren(arg, children = []) {
    if (Array.isArray(arg))
      for (let item of arg)
        getChildren(item, children);
    else arg != null && arg !== !1 && arg !== "" && children.push(arg);
    return children;
  }
  __name(getChildren, "getChildren");
  function getType(element) {
    let type = element.type;
    if (typeof type == "string")
      return type;
    if (typeof type == "function")
      return type.displayName || type.name || "Unknown";
    if (ReactIs.isFragment(element))
      return "React.Fragment";
    if (ReactIs.isSuspense(element))
      return "React.Suspense";
    if (typeof type == "object" && type !== null) {
      if (ReactIs.isContextProvider(element))
        return "Context.Provider";
      if (ReactIs.isContextConsumer(element))
        return "Context.Consumer";
      if (ReactIs.isForwardRef(element)) {
        if (type.displayName)
          return type.displayName;
        let functionName = type.render.displayName || type.render.name || "";
        return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
      }
      if (ReactIs.isMemo(element)) {
        let functionName = type.displayName || type.type.displayName || type.type.name || "";
        return functionName === "" ? "Memo" : `Memo(${functionName})`;
      }
    }
    return "UNDEFINED";
  }
  __name(getType, "getType");
  function getPropKeys$1(element) {
    let { props } = element;
    return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
  }
  __name(getPropKeys$1, "getPropKeys$1");
  var serialize$1 = __name((element, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? printElementAsLeaf(getType(element), config2) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config2, indentation + config2.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation), "serialize$1"), test$1 = __name((val) => val != null && ReactIs.isElement(val), "test$1"), plugin$1 = {
    serialize: serialize$1,
    test: test$1
  }, testSymbol = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
  function getPropKeys(object2) {
    let { props } = object2;
    return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
  }
  __name(getPropKeys, "getPropKeys");
  var serialize = __name((object2, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? printElementAsLeaf(object2.type, config2) : printElement(object2.type, object2.props ? printProps(getPropKeys(object2), object2.props, config2, indentation + config2.indent, depth, refs, printer2) : "", object2.children ? printChildren(object2.children, config2, indentation + config2.indent, depth, refs, printer2) : "", config2, indentation), "serialize"), test = __name((val) => val && val.$$typeof === testSymbol, "test"), plugin = {
    serialize,
    test
  }, toString = Object.prototype.toString, toISOString = Date.prototype.toISOString, errorToString = Error.prototype.toString, regExpToString = RegExp.prototype.toString;
  function getConstructorName(val) {
    return typeof val.constructor == "function" && val.constructor.name || "Object";
  }
  __name(getConstructorName, "getConstructorName");
  function isWindow(val) {
    return typeof window < "u" && val === window;
  }
  __name(isWindow, "isWindow");
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP = /\n/g, _PrettyFormatPluginError = class extends Error {
    constructor(message, stack) {
      super(message), this.stack = stack, this.name = this.constructor.name;
    }
  };
  __name(_PrettyFormatPluginError, "PrettyFormatPluginError");
  var PrettyFormatPluginError = _PrettyFormatPluginError;
  function isToStringedArrayType(toStringed) {
    return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
  }
  __name(isToStringedArrayType, "isToStringedArrayType");
  function printNumber(val) {
    return Object.is(val, -0) ? "-0" : String(val);
  }
  __name(printNumber, "printNumber");
  function printBigInt(val) {
    return `${val}n`;
  }
  __name(printBigInt, "printBigInt");
  function printFunction(val, printFunctionName) {
    return printFunctionName ? `[Function ${val.name || "anonymous"}]` : "[Function]";
  }
  __name(printFunction, "printFunction");
  function printSymbol(val) {
    return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  }
  __name(printSymbol, "printSymbol");
  function printError(val) {
    return `[${errorToString.call(val)}]`;
  }
  __name(printError, "printError");
  function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
    if (val === !0 || val === !1)
      return `${val}`;
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    let typeOf = typeof val;
    if (typeOf === "number")
      return printNumber(val);
    if (typeOf === "bigint")
      return printBigInt(val);
    if (typeOf === "string")
      return escapeString ? `"${val.replaceAll(/"|\\/g, "\\$&")}"` : `"${val}"`;
    if (typeOf === "function")
      return printFunction(val, printFunctionName);
    if (typeOf === "symbol")
      return printSymbol(val);
    let toStringed = toString.call(val);
    return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction(val, printFunctionName) : toStringed === "[object Symbol]" ? printSymbol(val) : toStringed === "[object Date]" ? Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val) : toStringed === "[object Error]" ? printError(val) : toStringed === "[object RegExp]" ? escapeRegex ? regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : regExpToString.call(val) : val instanceof Error ? printError(val) : null;
  }
  __name(printBasicValue, "printBasicValue");
  function printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON) {
    if (refs.includes(val))
      return "[Circular]";
    refs = [...refs], refs.push(val);
    let hitMaxDepth = ++depth > config2.maxDepth, min = config2.min;
    if (config2.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON)
      return printer(val.toJSON(), config2, indentation, depth, refs, !0);
    let toStringed = toString.call(val);
    return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config2, indentation, depth, refs, printer)}]` : isToStringedArrayType(toStringed) ? hitMaxDepth ? `[${val.constructor.name}]` : `${min || !config2.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config2, indentation, depth, refs, printer)}]` : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer, " => ")}}` : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config2, indentation, depth, refs, printer)}}` : hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min || !config2.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config2, indentation, depth, refs, printer)}}`;
  }
  __name(printComplexValue, "printComplexValue");
  var ErrorPlugin = {
    test: __name((val) => val && val instanceof Error, "test"),
    serialize(val, config2, indentation, depth, refs, printer2) {
      if (refs.includes(val))
        return "[Circular]";
      refs = [...refs, val];
      let hitMaxDepth = ++depth > config2.maxDepth, { message, cause, ...rest } = val, entries = {
        message,
        ...typeof cause < "u" ? { cause } : {},
        ...val instanceof AggregateError ? { errors: val.errors } : {},
        ...rest
      }, name = val.name !== "Error" ? val.name : getConstructorName(val);
      return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config2, indentation, depth, refs, printer2)}}`;
    }
  };
  function isNewPlugin(plugin2) {
    return plugin2.serialize != null;
  }
  __name(isNewPlugin, "isNewPlugin");
  function printPlugin(plugin2, val, config2, indentation, depth, refs) {
    let printed;
    try {
      printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config2, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config2, indentation, depth, refs), (str2) => {
        let indentationNext = indentation + config2.indent;
        return indentationNext + str2.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
      }, {
        edgeSpacing: config2.spacingOuter,
        min: config2.min,
        spacing: config2.spacingInner
      }, config2.colors);
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
    if (typeof printed != "string")
      throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
    return printed;
  }
  __name(printPlugin, "printPlugin");
  function findPlugin(plugins2, val) {
    for (let plugin2 of plugins2)
      try {
        if (plugin2.test(val))
          return plugin2;
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
    return null;
  }
  __name(findPlugin, "findPlugin");
  function printer(val, config2, indentation, depth, refs, hasCalledToJSON) {
    let plugin2 = findPlugin(config2.plugins, val);
    if (plugin2 !== null)
      return printPlugin(plugin2, val, config2, indentation, depth, refs);
    let basicResult = printBasicValue(val, config2.printFunctionName, config2.escapeRegex, config2.escapeString);
    return basicResult !== null ? basicResult : printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON);
  }
  __name(printer, "printer");
  var DEFAULT_THEME = {
    comment: "gray",
    content: "reset",
    prop: "yellow",
    tag: "cyan",
    value: "green"
  }, DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME), DEFAULT_OPTIONS2 = {
    callToJSON: !0,
    compareKeys: void 0,
    escapeRegex: !1,
    escapeString: !0,
    highlight: !1,
    indent: 2,
    maxDepth: Number.POSITIVE_INFINITY,
    maxWidth: Number.POSITIVE_INFINITY,
    min: !1,
    plugins: [],
    printBasicPrototype: !0,
    printFunctionName: !0,
    theme: DEFAULT_THEME
  };
  function validateOptions2(options) {
    for (let key of Object.keys(options))
      if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS2, key))
        throw new Error(`pretty-format: Unknown option "${key}".`);
    if (options.min && options.indent !== void 0 && options.indent !== 0)
      throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
  }
  __name(validateOptions2, "validateOptions");
  function getColorsHighlight() {
    return DEFAULT_THEME_KEYS.reduce((colors3, key) => {
      let value2 = DEFAULT_THEME[key], color2 = value2 && s[value2];
      if (color2 && typeof color2.close == "string" && typeof color2.open == "string")
        colors3[key] = color2;
      else
        throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value2}" is undefined in ansi-styles.`);
      return colors3;
    }, /* @__PURE__ */ Object.create(null));
  }
  __name(getColorsHighlight, "getColorsHighlight");
  function getColorsEmpty() {
    return DEFAULT_THEME_KEYS.reduce((colors3, key) => (colors3[key] = {
      close: "",
      open: ""
    }, colors3), /* @__PURE__ */ Object.create(null));
  }
  __name(getColorsEmpty, "getColorsEmpty");
  function getPrintFunctionName(options) {
    return options?.printFunctionName ?? DEFAULT_OPTIONS2.printFunctionName;
  }
  __name(getPrintFunctionName, "getPrintFunctionName");
  function getEscapeRegex(options) {
    return options?.escapeRegex ?? DEFAULT_OPTIONS2.escapeRegex;
  }
  __name(getEscapeRegex, "getEscapeRegex");
  function getEscapeString(options) {
    return options?.escapeString ?? DEFAULT_OPTIONS2.escapeString;
  }
  __name(getEscapeString, "getEscapeString");
  function getConfig2(options) {
    return {
      callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS2.callToJSON,
      colors: options?.highlight ? getColorsHighlight() : getColorsEmpty(),
      compareKeys: typeof options?.compareKeys == "function" || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS2.compareKeys,
      escapeRegex: getEscapeRegex(options),
      escapeString: getEscapeString(options),
      indent: options?.min ? "" : createIndent(options?.indent ?? DEFAULT_OPTIONS2.indent),
      maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS2.maxDepth,
      maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS2.maxWidth,
      min: options?.min ?? DEFAULT_OPTIONS2.min,
      plugins: options?.plugins ?? DEFAULT_OPTIONS2.plugins,
      printBasicPrototype: options?.printBasicPrototype ?? !0,
      printFunctionName: getPrintFunctionName(options),
      spacingInner: options?.min ? " " : `
`,
      spacingOuter: options?.min ? "" : `
`
    };
  }
  __name(getConfig2, "getConfig");
  function createIndent(indent) {
    return Array.from({ length: indent + 1 }).join(" ");
  }
  __name(createIndent, "createIndent");
  function format2(val, options) {
    if (options && (validateOptions2(options), options.plugins)) {
      let plugin2 = findPlugin(options.plugins, val);
      if (plugin2 !== null)
        return printPlugin(plugin2, val, getConfig2(options), "", 0, []);
    }
    let basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
    return basicResult !== null ? basicResult : printComplexValue(val, getConfig2(options), "", 0, []);
  }
  __name(format2, "format");
  var plugins = {
    AsymmetricMatcher: plugin$5,
    DOMCollection: plugin$4,
    DOMElement: plugin$3,
    Immutable: plugin$2,
    ReactElement: plugin$1,
    ReactTestComponent: plugin,
    Error: ErrorPlugin
  }, ansiColors = {
    bold: ["1", "22"],
    dim: ["2", "22"],
    italic: ["3", "23"],
    underline: ["4", "24"],
    // 5 & 6 are blinking
    inverse: ["7", "27"],
    hidden: ["8", "28"],
    strike: ["9", "29"],
    // 10-20 are fonts
    // 21-29 are resets for 1-9
    black: ["30", "39"],
    red: ["31", "39"],
    green: ["32", "39"],
    yellow: ["33", "39"],
    blue: ["34", "39"],
    magenta: ["35", "39"],
    cyan: ["36", "39"],
    white: ["37", "39"],
    brightblack: ["30;1", "39"],
    brightred: ["31;1", "39"],
    brightgreen: ["32;1", "39"],
    brightyellow: ["33;1", "39"],
    brightblue: ["34;1", "39"],
    brightmagenta: ["35;1", "39"],
    brightcyan: ["36;1", "39"],
    brightwhite: ["37;1", "39"],
    grey: ["90", "39"]
  }, styles = {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red"
  }, truncator = "\u2026";
  function colorise(value2, styleType) {
    let color2 = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
    return color2 ? `\x1B[${color2[0]}m${String(value2)}\x1B[${color2[1]}m` : String(value2);
  }
  __name(colorise, "colorise");
  function normaliseOptions({
    showHidden = !1,
    depth = 2,
    colors: colors3 = !1,
    customInspect = !0,
    showProxy = !1,
    maxArrayLength = 1 / 0,
    breakLength = 1 / 0,
    seen = [],
    // eslint-disable-next-line no-shadow
    truncate: truncate2 = 1 / 0,
    stylize = String
  } = {}, inspect3) {
    let options = {
      showHidden: !!showHidden,
      depth: Number(depth),
      colors: !!colors3,
      customInspect: !!customInspect,
      showProxy: !!showProxy,
      maxArrayLength: Number(maxArrayLength),
      breakLength: Number(breakLength),
      truncate: Number(truncate2),
      seen,
      inspect: inspect3,
      stylize
    };
    return options.colors && (options.stylize = colorise), options;
  }
  __name(normaliseOptions, "normaliseOptions");
  function isHighSurrogate(char) {
    return char >= "\uD800" && char <= "\uDBFF";
  }
  __name(isHighSurrogate, "isHighSurrogate");
  function truncate(string, length2, tail = truncator) {
    string = String(string);
    let tailLength = tail.length, stringLength = string.length;
    if (tailLength > length2 && stringLength > tailLength)
      return tail;
    if (stringLength > length2 && stringLength > tailLength) {
      let end = length2 - tailLength;
      return end > 0 && isHighSurrogate(string[end - 1]) && (end = end - 1), `${string.slice(0, end)}${tail}`;
    }
    return string;
  }
  __name(truncate, "truncate");
  function inspectList(list, options, inspectItem, separator = ", ") {
    inspectItem = inspectItem || options.inspect;
    let size = list.length;
    if (size === 0)
      return "";
    let originalLength = options.truncate, output = "", peek = "", truncated = "";
    for (let i3 = 0; i3 < size; i3 += 1) {
      let last = i3 + 1 === list.length, secondToLast = i3 + 2 === list.length;
      truncated = `${truncator}(${list.length - i3})`;
      let value2 = list[i3];
      options.truncate = originalLength - output.length - (last ? 0 : separator.length);
      let string = peek || inspectItem(value2, options) + (last ? "" : separator), nextLength = output.length + string.length, truncatedLength = nextLength + truncated.length;
      if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i3 + 1], options) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
        break;
      if (output += string, !last && !secondToLast && nextLength + peek.length >= originalLength) {
        truncated = `${truncator}(${list.length - i3 - 1})`;
        break;
      }
      truncated = "";
    }
    return `${output}${truncated}`;
  }
  __name(inspectList, "inspectList");
  function quoteComplexKey(key) {
    return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
  }
  __name(quoteComplexKey, "quoteComplexKey");
  function inspectProperty([key, value2], options) {
    return options.truncate -= 2, typeof key == "string" ? key = quoteComplexKey(key) : typeof key != "number" && (key = `[${options.inspect(key, options)}]`), options.truncate -= key.length, value2 = options.inspect(value2, options), `${key}: ${value2}`;
  }
  __name(inspectProperty, "inspectProperty");
  function inspectArray(array2, options) {
    let nonIndexProperties = Object.keys(array2).slice(array2.length);
    if (!array2.length && !nonIndexProperties.length)
      return "[]";
    options.truncate -= 4;
    let listContents = inspectList(array2, options);
    options.truncate -= listContents.length;
    let propertyContents = "";
    return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
  }
  __name(inspectArray, "inspectArray");
  var getArrayName = __name((array2) => typeof Buffer == "function" && array2 instanceof Buffer ? "Buffer" : array2[Symbol.toStringTag] ? array2[Symbol.toStringTag] : array2.constructor.name, "getArrayName");
  function inspectTypedArray(array2, options) {
    let name = getArrayName(array2);
    options.truncate -= name.length + 4;
    let nonIndexProperties = Object.keys(array2).slice(array2.length);
    if (!array2.length && !nonIndexProperties.length)
      return `${name}[]`;
    let output = "";
    for (let i3 = 0; i3 < array2.length; i3++) {
      let string = `${options.stylize(truncate(array2[i3], options.truncate), "number")}${i3 === array2.length - 1 ? "" : ", "}`;
      if (options.truncate -= string.length, array2[i3] !== array2.length && options.truncate <= 3) {
        output += `${truncator}(${array2.length - array2[i3] + 1})`;
        break;
      }
      output += string;
    }
    let propertyContents = "";
    return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
  }
  __name(inspectTypedArray, "inspectTypedArray");
  function inspectDate(dateObject, options) {
    let stringRepresentation = dateObject.toJSON();
    if (stringRepresentation === null)
      return "Invalid Date";
    let split = stringRepresentation.split("T"), date = split[0];
    return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
  }
  __name(inspectDate, "inspectDate");
  function inspectFunction(func, options) {
    let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
    return name ? options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special") : options.stylize(`[${functionType}]`, "special");
  }
  __name(inspectFunction, "inspectFunction");
  function inspectMapEntry([key, value2], options) {
    return options.truncate -= 4, key = options.inspect(key, options), options.truncate -= key.length, value2 = options.inspect(value2, options), `${key} => ${value2}`;
  }
  __name(inspectMapEntry, "inspectMapEntry");
  function mapToEntries(map2) {
    let entries = [];
    return map2.forEach((value2, key) => {
      entries.push([key, value2]);
    }), entries;
  }
  __name(mapToEntries, "mapToEntries");
  function inspectMap(map2, options) {
    return map2.size === 0 ? "Map{}" : (options.truncate -= 7, `Map{ ${inspectList(mapToEntries(map2), options, inspectMapEntry)} }`);
  }
  __name(inspectMap, "inspectMap");
  var isNaN2 = Number.isNaN || ((i3) => i3 !== i3);
  function inspectNumber(number, options) {
    return isNaN2(number) ? options.stylize("NaN", "number") : number === 1 / 0 ? options.stylize("Infinity", "number") : number === -1 / 0 ? options.stylize("-Infinity", "number") : number === 0 ? options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options.stylize(truncate(String(number), options.truncate), "number");
  }
  __name(inspectNumber, "inspectNumber");
  function inspectBigInt(number, options) {
    let nums = truncate(number.toString(), options.truncate - 1);
    return nums !== truncator && (nums += "n"), options.stylize(nums, "bigint");
  }
  __name(inspectBigInt, "inspectBigInt");
  function inspectRegExp(value2, options) {
    let flags = value2.toString().split("/")[2], sourceLength = options.truncate - (2 + flags.length), source = value2.source;
    return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
  }
  __name(inspectRegExp, "inspectRegExp");
  function arrayFromSet(set) {
    let values = [];
    return set.forEach((value2) => {
      values.push(value2);
    }), values;
  }
  __name(arrayFromSet, "arrayFromSet");
  function inspectSet(set, options) {
    return set.size === 0 ? "Set{}" : (options.truncate -= 7, `Set{ ${inspectList(arrayFromSet(set), options)} }`);
  }
  __name(inspectSet, "inspectSet");
  var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters = {
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    "'": "\\'",
    "\\": "\\\\"
  }, hex = 16, unicodeLength = 4;
  function escape(char) {
    return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
  }
  __name(escape, "escape");
  function inspectString(string, options) {
    return stringEscapeChars.test(string) && (string = string.replace(stringEscapeChars, escape)), options.stylize(`'${truncate(string, options.truncate - 2)}'`, "string");
  }
  __name(inspectString, "inspectString");
  function inspectSymbol(value2) {
    return "description" in Symbol.prototype ? value2.description ? `Symbol(${value2.description})` : "Symbol()" : value2.toString();
  }
  __name(inspectSymbol, "inspectSymbol");
  var getPromiseValue = __name(() => "Promise{\u2026}", "getPromiseValue"), promise_default = getPromiseValue;
  function inspectObject(object2, options) {
    let properties = Object.getOwnPropertyNames(object2), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : [];
    if (properties.length === 0 && symbols.length === 0)
      return "{}";
    if (options.truncate -= 4, options.seen = options.seen || [], options.seen.includes(object2))
      return "[Circular]";
    options.seen.push(object2);
    let propertyContents = inspectList(properties.map((key) => [key, object2[key]]), options, inspectProperty), symbolContents = inspectList(symbols.map((key) => [key, object2[key]]), options, inspectProperty);
    options.seen.pop();
    let sep = "";
    return propertyContents && symbolContents && (sep = ", "), `{ ${propertyContents}${sep}${symbolContents} }`;
  }
  __name(inspectObject, "inspectObject");
  var toStringTag = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
  function inspectClass(value2, options) {
    let name = "";
    return toStringTag && toStringTag in value2 && (name = value2[toStringTag]), name = name || value2.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options.truncate -= name.length, `${name}${inspectObject(value2, options)}`;
  }
  __name(inspectClass, "inspectClass");
  function inspectArguments(args, options) {
    return args.length === 0 ? "Arguments[]" : (options.truncate -= 13, `Arguments[ ${inspectList(args, options)} ]`);
  }
  __name(inspectArguments, "inspectArguments");
  var errorKeys = [
    "stack",
    "line",
    "column",
    "name",
    "message",
    "fileName",
    "lineNumber",
    "columnNumber",
    "number",
    "description",
    "cause"
  ];
  function inspectObject2(error, options) {
    let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1), name = error.name;
    options.truncate -= name.length;
    let message = "";
    if (typeof error.message == "string" ? message = truncate(error.message, options.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options.truncate -= message.length + 5, options.seen = options.seen || [], options.seen.includes(error))
      return "[Circular]";
    options.seen.push(error);
    let propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
    return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
  }
  __name(inspectObject2, "inspectObject");
  function inspectAttribute([key, value2], options) {
    return options.truncate -= 3, value2 ? `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value2}"`, "string")}` : `${options.stylize(String(key), "yellow")}`;
  }
  __name(inspectAttribute, "inspectAttribute");
  function inspectNodeCollection(collection, options) {
    return inspectList(collection, options, inspectNode, `
`);
  }
  __name(inspectNodeCollection, "inspectNodeCollection");
  function inspectNode(node, options) {
    switch (node.nodeType) {
      case 1:
        return inspectHTML(node, options);
      case 3:
        return options.inspect(node.data, options);
      default:
        return options.inspect(node, options);
    }
  }
  __name(inspectNode, "inspectNode");
  function inspectHTML(element, options) {
    let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options.stylize(`<${name}`, "special"), headClose = options.stylize(">", "special"), tail = options.stylize(`</${name}>`, "special");
    options.truncate -= name.length * 2 + 5;
    let propertyContents = "";
    properties.length > 0 && (propertyContents += " ", propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ")), options.truncate -= propertyContents.length;
    let truncate2 = options.truncate, children = inspectNodeCollection(element.children, options);
    return children && children.length > truncate2 && (children = `${truncator}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
  }
  __name(inspectHTML, "inspectHTML");
  var symbolsSupported = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect = Symbol.for("nodejs.util.inspect.custom"), constructorMap = /* @__PURE__ */ new WeakMap(), stringTagMap = {}, baseTypesMap = {
    undefined: __name((value2, options) => options.stylize("undefined", "undefined"), "undefined"),
    null: __name((value2, options) => options.stylize("null", "null"), "null"),
    boolean: __name((value2, options) => options.stylize(String(value2), "boolean"), "boolean"),
    Boolean: __name((value2, options) => options.stylize(String(value2), "boolean"), "Boolean"),
    number: inspectNumber,
    Number: inspectNumber,
    bigint: inspectBigInt,
    BigInt: inspectBigInt,
    string: inspectString,
    String: inspectString,
    function: inspectFunction,
    Function: inspectFunction,
    symbol: inspectSymbol,
    // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
    Symbol: inspectSymbol,
    Array: inspectArray,
    Date: inspectDate,
    Map: inspectMap,
    Set: inspectSet,
    RegExp: inspectRegExp,
    Promise: promise_default,
    // WeakSet, WeakMap are totally opaque to us
    WeakSet: __name((value2, options) => options.stylize("WeakSet{\u2026}", "special"), "WeakSet"),
    WeakMap: __name((value2, options) => options.stylize("WeakMap{\u2026}", "special"), "WeakMap"),
    Arguments: inspectArguments,
    Int8Array: inspectTypedArray,
    Uint8Array: inspectTypedArray,
    Uint8ClampedArray: inspectTypedArray,
    Int16Array: inspectTypedArray,
    Uint16Array: inspectTypedArray,
    Int32Array: inspectTypedArray,
    Uint32Array: inspectTypedArray,
    Float32Array: inspectTypedArray,
    Float64Array: inspectTypedArray,
    Generator: __name(() => "", "Generator"),
    DataView: __name(() => "", "DataView"),
    ArrayBuffer: __name(() => "", "ArrayBuffer"),
    Error: inspectObject2,
    HTMLCollection: inspectNodeCollection,
    NodeList: inspectNodeCollection
  }, inspectCustom = __name((value2, options, type, inspectFn) => chaiInspect in value2 && typeof value2[chaiInspect] == "function" ? value2[chaiInspect](options) : nodeInspect in value2 && typeof value2[nodeInspect] == "function" ? value2[nodeInspect](options.depth, options, inspectFn) : "inspect" in value2 && typeof value2.inspect == "function" ? value2.inspect(options.depth, options) : "constructor" in value2 && constructorMap.has(value2.constructor) ? constructorMap.get(value2.constructor)(value2, options) : stringTagMap[type] ? stringTagMap[type](value2, options) : "", "inspectCustom"), toString2 = Object.prototype.toString;
  function inspect(value2, opts = {}) {
    let options = normaliseOptions(opts, inspect), { customInspect } = options, type = value2 === null ? "null" : typeof value2;
    if (type === "object" && (type = toString2.call(value2).slice(8, -1)), type in baseTypesMap)
      return baseTypesMap[type](value2, options);
    if (customInspect && value2) {
      let output = inspectCustom(value2, options, type, inspect);
      if (output)
        return typeof output == "string" ? output : inspect(output, options);
    }
    let proto = value2 ? Object.getPrototypeOf(value2) : !1;
    return proto === Object.prototype || proto === null ? inspectObject(value2, options) : value2 && typeof HTMLElement == "function" && value2 instanceof HTMLElement ? inspectHTML(value2, options) : "constructor" in value2 ? value2.constructor !== Object ? inspectClass(value2, options) : inspectObject(value2, options) : value2 === Object(value2) ? inspectObject(value2, options) : options.stylize(String(value2), type);
  }
  __name(inspect, "inspect");
  var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins, PLUGINS = [
    ReactTestComponent,
    ReactElement,
    DOMElement,
    DOMCollection,
    Immutable,
    AsymmetricMatcher
  ];
  function stringify2(object2, maxDepth = 10, { maxLength, ...options } = {}) {
    let MAX_LENGTH = maxLength ?? 1e4, result;
    try {
      result = format2(object2, {
        maxDepth,
        escapeString: !1,
        plugins: PLUGINS,
        ...options
      });
    } catch {
      result = format2(object2, {
        callToJSON: !1,
        maxDepth,
        escapeString: !1,
        plugins: PLUGINS,
        ...options
      });
    }
    return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify2(object2, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
      maxLength,
      ...options
    }) : result;
  }
  __name(stringify2, "stringify");
  var formatRegExp = /%[sdjifoOc%]/g;
  function format22(...args) {
    if (typeof args[0] != "string") {
      let objects = [];
      for (let i22 = 0; i22 < args.length; i22++)
        objects.push(inspect2(args[i22], {
          depth: 0,
          colors: !1
        }));
      return objects.join(" ");
    }
    let len = args.length, i3 = 1, template = args[0], str2 = String(template).replace(formatRegExp, (x3) => {
      if (x3 === "%%")
        return "%";
      if (i3 >= len)
        return x3;
      switch (x3) {
        case "%s": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : typeof value2 == "number" && value2 === 0 && 1 / value2 < 0 ? "-0" : typeof value2 == "object" && value2 !== null ? typeof value2.toString == "function" && value2.toString !== Object.prototype.toString ? value2.toString() : inspect2(value2, {
            depth: 0,
            colors: !1
          }) : String(value2);
        }
        case "%d": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : Number(value2).toString();
        }
        case "%i": {
          let value2 = args[i3++];
          return typeof value2 == "bigint" ? `${value2.toString()}n` : Number.parseInt(String(value2)).toString();
        }
        case "%f":
          return Number.parseFloat(String(args[i3++])).toString();
        case "%o":
          return inspect2(args[i3++], {
            showHidden: !0,
            showProxy: !0
          });
        case "%O":
          return inspect2(args[i3++]);
        case "%c":
          return i3++, "";
        case "%j":
          try {
            return JSON.stringify(args[i3++]);
          } catch (err) {
            let m22 = err.message;
            if (m22.includes("circular structure") || m22.includes("cyclic structures") || m22.includes("cyclic object"))
              return "[Circular]";
            throw err;
          }
        default:
          return x3;
      }
    });
    for (let x3 = args[i3]; i3 < len; x3 = args[++i3])
      x3 === null || typeof x3 != "object" ? str2 += ` ${x3}` : str2 += ` ${inspect2(x3)}`;
    return str2;
  }
  __name(format22, "format");
  function inspect2(obj, options = {}) {
    return options.truncate === 0 && (options.truncate = Number.POSITIVE_INFINITY), inspect(obj, options);
  }
  __name(inspect2, "inspect");
  function getDefaultExportFromCjs2(x3) {
    return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3.default : x3;
  }
  __name(getDefaultExportFromCjs2, "getDefaultExportFromCjs");
  function assertTypes(value2, name, types2) {
    let receivedType = typeof value2;
    if (!types2.includes(receivedType))
      throw new TypeError(`${name} value must be ${types2.join(" or ")}, received "${receivedType}"`);
  }
  __name(assertTypes, "assertTypes");
  function isObject2(item) {
    return item != null && typeof item == "object" && !Array.isArray(item);
  }
  __name(isObject2, "isObject");
  function isFinalObj(obj) {
    return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
  }
  __name(isFinalObj, "isFinalObj");
  function getType2(value2) {
    return Object.prototype.toString.apply(value2).slice(8, -1);
  }
  __name(getType2, "getType");
  function collectOwnProperties(obj, collector) {
    let collect = typeof collector == "function" ? collector : (key) => collector.add(key);
    Object.getOwnPropertyNames(obj).forEach(collect), Object.getOwnPropertySymbols(obj).forEach(collect);
  }
  __name(collectOwnProperties, "collectOwnProperties");
  function getOwnProperties(obj) {
    let ownProps = /* @__PURE__ */ new Set();
    return isFinalObj(obj) ? [] : (collectOwnProperties(obj, ownProps), Array.from(ownProps));
  }
  __name(getOwnProperties, "getOwnProperties");
  var defaultCloneOptions = { forceWritable: !1 };
  function deepClone(val, options = defaultCloneOptions) {
    return clone(val, /* @__PURE__ */ new WeakMap(), options);
  }
  __name(deepClone, "deepClone");
  function clone(val, seen, options = defaultCloneOptions) {
    let k3, out;
    if (seen.has(val))
      return seen.get(val);
    if (Array.isArray(val)) {
      for (out = Array.from({ length: k3 = val.length }), seen.set(val, out); k3--; )
        out[k3] = clone(val[k3], seen, options);
      return out;
    }
    if (Object.prototype.toString.call(val) === "[object Object]") {
      out = Object.create(Object.getPrototypeOf(val)), seen.set(val, out);
      let props = getOwnProperties(val);
      for (let k22 of props) {
        let descriptor = Object.getOwnPropertyDescriptor(val, k22);
        if (!descriptor)
          continue;
        let cloned = clone(val[k22], seen, options);
        options.forceWritable ? Object.defineProperty(out, k22, {
          enumerable: descriptor.enumerable,
          configurable: !0,
          writable: !0,
          value: cloned
        }) : "get" in descriptor ? Object.defineProperty(out, k22, {
          ...descriptor,
          get() {
            return cloned;
          }
        }) : Object.defineProperty(out, k22, {
          ...descriptor,
          value: cloned
        });
      }
      return out;
    }
    return val;
  }
  __name(clone, "clone");
  function noop2() {
  }
  __name(noop2, "noop");
  var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0, _Diff = class {
    0;
    1;
    constructor(op, text) {
      this[0] = op, this[1] = text;
    }
  };
  __name(_Diff, "Diff");
  var Diff = _Diff;
  function diff_commonPrefix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
      return 0;
    let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerstart = 0;
    for (; pointermin < pointermid; )
      text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid) ? (pointermin = pointermid, pointerstart = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    return pointermid;
  }
  __name(diff_commonPrefix, "diff_commonPrefix");
  function diff_commonSuffix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
      return 0;
    let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerend = 0;
    for (; pointermin < pointermid; )
      text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend) ? (pointermin = pointermid, pointerend = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    return pointermid;
  }
  __name(diff_commonSuffix, "diff_commonSuffix");
  function diff_commonOverlap_(text1, text2) {
    let text1_length = text1.length, text2_length = text2.length;
    if (text1_length === 0 || text2_length === 0)
      return 0;
    text1_length > text2_length ? text1 = text1.substring(text1_length - text2_length) : text1_length < text2_length && (text2 = text2.substring(0, text1_length));
    let text_length = Math.min(text1_length, text2_length);
    if (text1 === text2)
      return text_length;
    let best = 0, length2 = 1;
    for (; ; ) {
      let pattern = text1.substring(text_length - length2), found = text2.indexOf(pattern);
      if (found === -1)
        return best;
      length2 += found, (found === 0 || text1.substring(text_length - length2) === text2.substring(0, length2)) && (best = length2, length2++);
    }
  }
  __name(diff_commonOverlap_, "diff_commonOverlap_");
  function diff_cleanupSemantic(diffs) {
    let changes = !1, equalities = [], equalitiesLength = 0, lastEquality = null, pointer2 = 0, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0;
    for (; pointer2 < diffs.length; )
      diffs[pointer2][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer2, length_insertions1 = length_insertions2, length_deletions1 = length_deletions2, length_insertions2 = 0, length_deletions2 = 0, lastEquality = diffs[pointer2][1]) : (diffs[pointer2][0] === DIFF_INSERT ? length_insertions2 += diffs[pointer2][1].length : length_deletions2 += diffs[pointer2][1].length, lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer2 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0, lastEquality = null, changes = !0)), pointer2++;
    for (changes && diff_cleanupMerge(diffs), diff_cleanupSemanticLossless(diffs), pointer2 = 1; pointer2 < diffs.length; ) {
      if (diffs[pointer2 - 1][0] === DIFF_DELETE && diffs[pointer2][0] === DIFF_INSERT) {
        let deletion = diffs[pointer2 - 1][1], insertion = diffs[pointer2][1], overlap_length1 = diff_commonOverlap_(deletion, insertion), overlap_length2 = diff_commonOverlap_(insertion, deletion);
        overlap_length1 >= overlap_length2 ? (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) && (diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))), diffs[pointer2 - 1][1] = deletion.substring(0, deletion.length - overlap_length1), diffs[pointer2 + 1][1] = insertion.substring(overlap_length1), pointer2++) : (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) && (diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))), diffs[pointer2 - 1][0] = DIFF_INSERT, diffs[pointer2 - 1][1] = insertion.substring(0, insertion.length - overlap_length2), diffs[pointer2 + 1][0] = DIFF_DELETE, diffs[pointer2 + 1][1] = deletion.substring(overlap_length2), pointer2++), pointer2++;
      }
      pointer2++;
    }
  }
  __name(diff_cleanupSemantic, "diff_cleanupSemantic");
  var nonAlphaNumericRegex_ = /[^a-z0-9]/i, whitespaceRegex_ = /\s/, linebreakRegex_ = /[\r\n]/, blanklineEndRegex_ = /\n\r?\n$/, blanklineStartRegex_ = /^\r?\n\r?\n/;
  function diff_cleanupSemanticLossless(diffs) {
    let pointer2 = 1;
    for (; pointer2 < diffs.length - 1; ) {
      if (diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL) {
        let equality1 = diffs[pointer2 - 1][1], edit = diffs[pointer2][1], equality2 = diffs[pointer2 + 1][1], commonOffset = diff_commonSuffix(equality1, edit);
        if (commonOffset) {
          let commonString = edit.substring(edit.length - commonOffset);
          equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
        }
        let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        for (; edit.charAt(0) === equality2.charAt(0); ) {
          equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
          let score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
        }
        diffs[pointer2 - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer2 - 1][1] = bestEquality1 : (diffs.splice(pointer2 - 1, 1), pointer2--), diffs[pointer2][1] = bestEdit, bestEquality2 ? diffs[pointer2 + 1][1] = bestEquality2 : (diffs.splice(pointer2 + 1, 1), pointer2--));
      }
      pointer2++;
    }
  }
  __name(diff_cleanupSemanticLossless, "diff_cleanupSemanticLossless");
  function diff_cleanupMerge(diffs) {
    diffs.push(new Diff(DIFF_EQUAL, ""));
    let pointer2 = 0, count_delete = 0, count_insert = 0, text_delete = "", text_insert = "", commonlength;
    for (; pointer2 < diffs.length; )
      switch (diffs[pointer2][0]) {
        case DIFF_INSERT:
          count_insert++, text_insert += diffs[pointer2][1], pointer2++;
          break;
        case DIFF_DELETE:
          count_delete++, text_delete += diffs[pointer2][1], pointer2++;
          break;
        case DIFF_EQUAL:
          count_delete + count_insert > 1 ? (count_delete !== 0 && count_insert !== 0 && (commonlength = diff_commonPrefix(text_insert, text_delete), commonlength !== 0 && (pointer2 - count_delete - count_insert > 0 && diffs[pointer2 - count_delete - count_insert - 1][0] === DIFF_EQUAL ? diffs[pointer2 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength) : (diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))), pointer2++), text_insert = text_insert.substring(commonlength), text_delete = text_delete.substring(commonlength)), commonlength = diff_commonSuffix(text_insert, text_delete), commonlength !== 0 && (diffs[pointer2][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer2][1], text_insert = text_insert.substring(0, text_insert.length - commonlength), text_delete = text_delete.substring(0, text_delete.length - commonlength))), pointer2 -= count_delete + count_insert, diffs.splice(pointer2, count_delete + count_insert), text_delete.length && (diffs.splice(pointer2, 0, new Diff(DIFF_DELETE, text_delete)), pointer2++), text_insert.length && (diffs.splice(pointer2, 0, new Diff(DIFF_INSERT, text_insert)), pointer2++), pointer2++) : pointer2 !== 0 && diffs[pointer2 - 1][0] === DIFF_EQUAL ? (diffs[pointer2 - 1][1] += diffs[pointer2][1], diffs.splice(pointer2, 1)) : pointer2++, count_insert = 0, count_delete = 0, text_delete = "", text_insert = "";
          break;
      }
    diffs[diffs.length - 1][1] === "" && diffs.pop();
    let changes = !1;
    for (pointer2 = 1; pointer2 < diffs.length - 1; )
      diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL && (diffs[pointer2][1].substring(diffs[pointer2][1].length - diffs[pointer2 - 1][1].length) === diffs[pointer2 - 1][1] ? (diffs[pointer2][1] = diffs[pointer2 - 1][1] + diffs[pointer2][1].substring(0, diffs[pointer2][1].length - diffs[pointer2 - 1][1].length), diffs[pointer2 + 1][1] = diffs[pointer2 - 1][1] + diffs[pointer2 + 1][1], diffs.splice(pointer2 - 1, 1), changes = !0) : diffs[pointer2][1].substring(0, diffs[pointer2 + 1][1].length) === diffs[pointer2 + 1][1] && (diffs[pointer2 - 1][1] += diffs[pointer2 + 1][1], diffs[pointer2][1] = diffs[pointer2][1].substring(diffs[pointer2 + 1][1].length) + diffs[pointer2 + 1][1], diffs.splice(pointer2 + 1, 1), changes = !0)), pointer2++;
    changes && diff_cleanupMerge(diffs);
  }
  __name(diff_cleanupMerge, "diff_cleanupMerge");
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two)
      return 6;
    let char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_), lineBreak1 = whitespace1 && char1.match(linebreakRegex_), lineBreak2 = whitespace2 && char2.match(linebreakRegex_), blankLine1 = lineBreak1 && one.match(blanklineEndRegex_), blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
  }
  __name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
  var NO_DIFF_MESSAGE = "Compared values have no visual difference.", SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", build = {}, hasRequiredBuild;
  function requireBuild() {
    if (hasRequiredBuild) return build;
    hasRequiredBuild = 1, Object.defineProperty(build, "__esModule", {
      value: !0
    }), build.default = diffSequence;
    let pkg = "diff-sequences", NOT_YET_SET = 0, countCommonItemsF = __name((aIndex, aEnd, bIndex, bEnd, isCommon) => {
      let nCommon = 0;
      for (; aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex); )
        aIndex += 1, bIndex += 1, nCommon += 1;
      return nCommon;
    }, "countCommonItemsF"), countCommonItemsR = __name((aStart, aIndex, bStart, bIndex, isCommon) => {
      let nCommon = 0;
      for (; aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex); )
        aIndex -= 1, bIndex -= 1, nCommon += 1;
      return nCommon;
    }, "countCommonItemsR"), extendPathsF = __name((d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
      let iF = 0, kF = -d3, aFirst = aIndexesF[iF], aIndexPrev1 = aFirst;
      aIndexesF[iF] += countCommonItemsF(
        aFirst + 1,
        aEnd,
        bF + aFirst - kF + 1,
        bEnd,
        isCommon
      );
      let nF = d3 < iMaxF ? d3 : iMaxF;
      for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
        if (iF !== d3 && aIndexPrev1 < aIndexesF[iF])
          aFirst = aIndexesF[iF];
        else if (aFirst = aIndexPrev1 + 1, aEnd <= aFirst)
          return iF - 1;
        aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
      }
      return iMaxF;
    }, "extendPathsF"), extendPathsR = __name((d3, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
      let iR = 0, kR = d3, aFirst = aIndexesR[iR], aIndexPrev1 = aFirst;
      aIndexesR[iR] -= countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
      let nR = d3 < iMaxR ? d3 : iMaxR;
      for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
        if (iR !== d3 && aIndexesR[iR] < aIndexPrev1)
          aFirst = aIndexesR[iR];
        else if (aFirst = aIndexPrev1 - 1, aFirst < aStart)
          return iR - 1;
        aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aFirst - countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bR + aFirst - kR - 1,
          isCommon
        );
      }
      return iMaxR;
    }, "extendPathsR"), extendOverlappablePathsF = __name((d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
      let bF = bStart - aStart, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapF = -baDeltaLength - (d3 - 1), kMaxOverlapF = -baDeltaLength + (d3 - 1), aIndexPrev1 = NOT_YET_SET, nF = d3 < iMaxF ? d3 : iMaxF;
      for (let iF = 0, kF = -d3; iF <= nF; iF += 1, kF += 2) {
        let insert = iF === 0 || iF !== d3 && aIndexPrev1 < aIndexesF[iF], aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev + 1, bFirst = bF + aFirst - kF, nCommonF = countCommonItemsF(
          aFirst + 1,
          aEnd,
          bFirst + 1,
          bEnd,
          isCommon
        ), aLast = aFirst + nCommonF;
        if (aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aLast, kMinOverlapF <= kF && kF <= kMaxOverlapF) {
          let iR = (d3 - 1 - (kF + baDeltaLength)) / 2;
          if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
            let bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1), nCommonR = countCommonItemsR(
              aStart,
              aLastPrev,
              bStart,
              bLastPrev,
              isCommon
            ), aIndexPrevFirst = aLastPrev - nCommonR, bIndexPrevFirst = bLastPrev - nCommonR, aEndPreceding = aIndexPrevFirst + 1, bEndPreceding = bIndexPrevFirst + 1;
            division.nChangePreceding = d3 - 1, d3 - 1 === aEndPreceding + bEndPreceding - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aEndPreceding, division.bEndPreceding = bEndPreceding), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aEndPreceding, division.bCommonPreceding = bEndPreceding), division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aFirst + 1, division.bCommonFollowing = bFirst + 1);
            let aStartFollowing = aLast + 1, bStartFollowing = bFirst + nCommonF + 1;
            return division.nChangeFollowing = d3 - 1, d3 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing), !0;
          }
        }
      }
      return !1;
    }, "extendOverlappablePathsF"), extendOverlappablePathsR = __name((d3, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
      let bR = bEnd - aEnd, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapR = baDeltaLength - d3, kMaxOverlapR = baDeltaLength + d3, aIndexPrev1 = NOT_YET_SET, nR = d3 < iMaxR ? d3 : iMaxR;
      for (let iR = 0, kR = d3; iR <= nR; iR += 1, kR -= 2) {
        let insert = iR === 0 || iR !== d3 && aIndexesR[iR] < aIndexPrev1, aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev - 1, bFirst = bR + aFirst - kR, nCommonR = countCommonItemsR(
          aStart,
          aFirst - 1,
          bStart,
          bFirst - 1,
          isCommon
        ), aLast = aFirst - nCommonR;
        if (aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aLast, kMinOverlapR <= kR && kR <= kMaxOverlapR) {
          let iF = (d3 + (kR - baDeltaLength)) / 2;
          if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
            let bLast = bFirst - nCommonR;
            if (division.nChangePreceding = d3, d3 === aLast + bLast - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aLast, division.bEndPreceding = bLast), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aLast, division.bCommonPreceding = bLast), division.nChangeFollowing = d3 - 1, d3 === 1)
              division.nCommonFollowing = 0, division.aStartFollowing = aEnd, division.bStartFollowing = bEnd;
            else {
              let bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1), nCommonF = countCommonItemsF(
                aLastPrev,
                aEnd,
                bLastPrev,
                bEnd,
                isCommon
              );
              division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aLastPrev, division.bCommonFollowing = bLastPrev);
              let aStartFollowing = aLastPrev + nCommonF, bStartFollowing = bLastPrev + nCommonF;
              d3 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing);
            }
            return !0;
          }
        }
      }
      return !1;
    }, "extendOverlappablePathsR"), divide = __name((nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
      let bF = bStart - aStart, bR = bEnd - aEnd, aLength = aEnd - aStart, bLength = bEnd - bStart, baDeltaLength = bLength - aLength, iMaxF = aLength, iMaxR = aLength;
      if (aIndexesF[0] = aStart - 1, aIndexesR[0] = aEnd, baDeltaLength % 2 === 0) {
        let dMin = (nChange || baDeltaLength) / 2, dMax = (aLength + bLength) / 2;
        for (let d3 = 1; d3 <= dMax; d3 += 1)
          if (iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d3 < dMin)
            iMaxR = extendPathsR(d3, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
          else if (
            // If a reverse path overlaps a forward path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsR(
              d3,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          )
            return;
      } else {
        let dMin = ((nChange || baDeltaLength) + 1) / 2, dMax = (aLength + bLength + 1) / 2, d3 = 1;
        for (iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d3 += 1; d3 <= dMax; d3 += 1)
          if (iMaxR = extendPathsR(
            d3 - 1,
            aStart,
            bStart,
            bR,
            isCommon,
            aIndexesR,
            iMaxR
          ), d3 < dMin)
            iMaxF = extendPathsF(d3, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
          else if (
            // If a forward path overlaps a reverse path in the same diagonal,
            // return a division of the index intervals at the middle change.
            extendOverlappablePathsF(
              d3,
              aStart,
              aEnd,
              bStart,
              bEnd,
              isCommon,
              aIndexesF,
              iMaxF,
              aIndexesR,
              iMaxR,
              division
            )
          )
            return;
      }
      throw new Error(
        `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
      );
    }, "divide"), findSubsequences = __name((nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
      if (bEnd - bStart < aEnd - aStart) {
        if (transposed = !transposed, transposed && callbacks.length === 1) {
          let { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
          callbacks[1] = {
            foundSubsequence: __name((nCommon, bCommon, aCommon) => {
              foundSubsequence2(nCommon, aCommon, bCommon);
            }, "foundSubsequence"),
            isCommon: __name((bIndex, aIndex) => isCommon2(aIndex, bIndex), "isCommon")
          };
        }
        let tStart = aStart, tEnd = aEnd;
        aStart = bStart, aEnd = bEnd, bStart = tStart, bEnd = tEnd;
      }
      let { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
      divide(
        nChange,
        aStart,
        aEnd,
        bStart,
        bEnd,
        isCommon,
        aIndexesF,
        aIndexesR,
        division
      );
      let {
        nChangePreceding,
        aEndPreceding,
        bEndPreceding,
        nCommonPreceding,
        aCommonPreceding,
        bCommonPreceding,
        nCommonFollowing,
        aCommonFollowing,
        bCommonFollowing,
        nChangeFollowing,
        aStartFollowing,
        bStartFollowing
      } = division;
      aStart < aEndPreceding && bStart < bEndPreceding && findSubsequences(
        nChangePreceding,
        aStart,
        aEndPreceding,
        bStart,
        bEndPreceding,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      ), nCommonPreceding !== 0 && foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding), nCommonFollowing !== 0 && foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing), aStartFollowing < aEnd && bStartFollowing < bEnd && findSubsequences(
        nChangeFollowing,
        aStartFollowing,
        aEnd,
        bStartFollowing,
        bEnd,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }, "findSubsequences"), validateLength = __name((name, arg) => {
      if (typeof arg != "number")
        throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
      if (!Number.isSafeInteger(arg))
        throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
      if (arg < 0)
        throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
    }, "validateLength"), validateCallback = __name((name, arg) => {
      let type = typeof arg;
      if (type !== "function")
        throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
    }, "validateCallback");
    function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
      validateLength("aLength", aLength), validateLength("bLength", bLength), validateCallback("isCommon", isCommon), validateCallback("foundSubsequence", foundSubsequence);
      let nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
      if (nCommonF !== 0 && foundSubsequence(nCommonF, 0, 0), aLength !== nCommonF || bLength !== nCommonF) {
        let aStart = nCommonF, bStart = nCommonF, nCommonR = countCommonItemsR(
          aStart,
          aLength - 1,
          bStart,
          bLength - 1,
          isCommon
        ), aEnd = aLength - nCommonR, bEnd = bLength - nCommonR, nCommonFR = nCommonF + nCommonR;
        aLength !== nCommonFR && bLength !== nCommonFR && findSubsequences(
          0,
          aStart,
          aEnd,
          bStart,
          bEnd,
          !1,
          [
            {
              foundSubsequence,
              isCommon
            }
          ],
          [NOT_YET_SET],
          [NOT_YET_SET],
          {
            aCommonFollowing: NOT_YET_SET,
            aCommonPreceding: NOT_YET_SET,
            aEndPreceding: NOT_YET_SET,
            aStartFollowing: NOT_YET_SET,
            bCommonFollowing: NOT_YET_SET,
            bCommonPreceding: NOT_YET_SET,
            bEndPreceding: NOT_YET_SET,
            bStartFollowing: NOT_YET_SET,
            nChangeFollowing: NOT_YET_SET,
            nChangePreceding: NOT_YET_SET,
            nCommonFollowing: NOT_YET_SET,
            nCommonPreceding: NOT_YET_SET
          }
        ), nCommonR !== 0 && foundSubsequence(nCommonR, aEnd, bEnd);
      }
    }
    return __name(diffSequence, "diffSequence"), build;
  }
  __name(requireBuild, "requireBuild");
  var buildExports = requireBuild(), diffSequences = getDefaultExportFromCjs2(buildExports);
  function formatTrailingSpaces(line, trailingSpaceFormatter) {
    return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
  }
  __name(formatTrailingSpaces, "formatTrailingSpaces");
  function printDiffLine(line, isFirstOrLast, color2, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
    return line.length !== 0 ? color2(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color2(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color2(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
  }
  __name(printDiffLine, "printDiffLine");
  function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  __name(printDeleteLine, "printDeleteLine");
  function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  __name(printInsertLine, "printInsertLine");
  function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
    return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
  }
  __name(printCommonLine, "printCommonLine");
  function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
    return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
  }
  __name(createPatchMark, "createPatchMark");
  function joinAlignedDiffsNoExpand(diffs, options) {
    let iLength = diffs.length, nContextLines = options.contextLines, nContextLines2 = nContextLines + nContextLines, jLength = iLength, hasExcessAtStartOrEnd = !1, nExcessesBetweenChanges = 0, i3 = 0;
    for (; i3 !== iLength; ) {
      let iStart = i3;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_EQUAL; )
        i3 += 1;
      if (iStart !== i3)
        if (iStart === 0)
          i3 > nContextLines && (jLength -= i3 - nContextLines, hasExcessAtStartOrEnd = !0);
        else if (i3 === iLength) {
          let n2 = i3 - iStart;
          n2 > nContextLines && (jLength -= n2 - nContextLines, hasExcessAtStartOrEnd = !0);
        } else {
          let n2 = i3 - iStart;
          n2 > nContextLines2 && (jLength -= n2 - nContextLines2, nExcessesBetweenChanges += 1);
        }
      for (; i3 !== iLength && diffs[i3][0] !== DIFF_EQUAL; )
        i3 += 1;
    }
    let hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
    nExcessesBetweenChanges !== 0 ? jLength += nExcessesBetweenChanges + 1 : hasExcessAtStartOrEnd && (jLength += 1);
    let jLast = jLength - 1, lines = [], jPatchMark = 0;
    hasPatch && lines.push("");
    let aStart = 0, bStart = 0, aEnd = 0, bEnd = 0, pushCommonLine = __name((line) => {
      let j2 = lines.length;
      lines.push(printCommonLine(line, j2 === 0 || j2 === jLast, options)), aEnd += 1, bEnd += 1;
    }, "pushCommonLine"), pushDeleteLine = __name((line) => {
      let j2 = lines.length;
      lines.push(printDeleteLine(line, j2 === 0 || j2 === jLast, options)), aEnd += 1;
    }, "pushDeleteLine"), pushInsertLine = __name((line) => {
      let j2 = lines.length;
      lines.push(printInsertLine(line, j2 === 0 || j2 === jLast, options)), bEnd += 1;
    }, "pushInsertLine");
    for (i3 = 0; i3 !== iLength; ) {
      let iStart = i3;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_EQUAL; )
        i3 += 1;
      if (iStart !== i3)
        if (iStart === 0) {
          i3 > nContextLines && (iStart = i3 - nContextLines, aStart = iStart, bStart = iStart, aEnd = aStart, bEnd = bStart);
          for (let iCommon = iStart; iCommon !== i3; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else if (i3 === iLength) {
          let iEnd = i3 - iStart > nContextLines ? iStart + nContextLines : i3;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else {
          let nCommon = i3 - iStart;
          if (nCommon > nContextLines2) {
            let iEnd = iStart + nContextLines;
            for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
            lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options), jPatchMark = lines.length, lines.push("");
            let nOmit = nCommon - nContextLines2;
            aStart = aEnd + nOmit, bStart = bEnd + nOmit, aEnd = aStart, bEnd = bStart;
            for (let iCommon = i3 - nContextLines; iCommon !== i3; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
          } else
            for (let iCommon = iStart; iCommon !== i3; iCommon += 1)
              pushCommonLine(diffs[iCommon][1]);
        }
      for (; i3 !== iLength && diffs[i3][0] === DIFF_DELETE; )
        pushDeleteLine(diffs[i3][1]), i3 += 1;
      for (; i3 !== iLength && diffs[i3][0] === DIFF_INSERT; )
        pushInsertLine(diffs[i3][1]), i3 += 1;
    }
    return hasPatch && (lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options)), lines.join(`
`);
  }
  __name(joinAlignedDiffsNoExpand, "joinAlignedDiffsNoExpand");
  function joinAlignedDiffsExpand(diffs, options) {
    return diffs.map((diff2, i3, diffs2) => {
      let line = diff2[1], isFirstOrLast = i3 === 0 || i3 === diffs2.length - 1;
      switch (diff2[0]) {
        case DIFF_DELETE:
          return printDeleteLine(line, isFirstOrLast, options);
        case DIFF_INSERT:
          return printInsertLine(line, isFirstOrLast, options);
        default:
          return printCommonLine(line, isFirstOrLast, options);
      }
    }).join(`
`);
  }
  __name(joinAlignedDiffsExpand, "joinAlignedDiffsExpand");
  var noColor = __name((string) => string, "noColor"), DIFF_CONTEXT_DEFAULT = 5, DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
  function getDefaultOptions() {
    return {
      aAnnotation: "Expected",
      aColor: s.green,
      aIndicator: "-",
      bAnnotation: "Received",
      bColor: s.red,
      bIndicator: "+",
      changeColor: s.inverse,
      changeLineTrailingSpaceColor: noColor,
      commonColor: s.dim,
      commonIndicator: " ",
      commonLineTrailingSpaceColor: noColor,
      compareKeys: void 0,
      contextLines: DIFF_CONTEXT_DEFAULT,
      emptyFirstOrLastLinePlaceholder: "",
      expand: !1,
      includeChangeCounts: !1,
      omitAnnotationLines: !1,
      patchColor: s.yellow,
      printBasicPrototype: !1,
      truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
      truncateAnnotation: "... Diff result is truncated",
      truncateAnnotationColor: noColor
    };
  }
  __name(getDefaultOptions, "getDefaultOptions");
  function getCompareKeys(compareKeys) {
    return compareKeys && typeof compareKeys == "function" ? compareKeys : void 0;
  }
  __name(getCompareKeys, "getCompareKeys");
  function getContextLines(contextLines) {
    return typeof contextLines == "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
  }
  __name(getContextLines, "getContextLines");
  function normalizeDiffOptions(options = {}) {
    return {
      ...getDefaultOptions(),
      ...options,
      compareKeys: getCompareKeys(options.compareKeys),
      contextLines: getContextLines(options.contextLines)
    };
  }
  __name(normalizeDiffOptions, "normalizeDiffOptions");
  function isEmptyString(lines) {
    return lines.length === 1 && lines[0].length === 0;
  }
  __name(isEmptyString, "isEmptyString");
  function countChanges(diffs) {
    let a22 = 0, b3 = 0;
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          a22 += 1;
          break;
        case DIFF_INSERT:
          b3 += 1;
          break;
      }
    }), {
      a: a22,
      b: b3
    };
  }
  __name(countChanges, "countChanges");
  function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
    if (omitAnnotationLines)
      return "";
    let aRest = "", bRest = "";
    if (includeChangeCounts) {
      let aCount = String(changeCounts.a), bCount = String(changeCounts.b), baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length, aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff)), bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff)), baCountLengthDiff = bCount.length - aCount.length, aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff)), bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
      aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`, bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
    }
    let a22 = `${aIndicator} ${aAnnotation}${aRest}`, b3 = `${bIndicator} ${bAnnotation}${bRest}`;
    return `${aColor(a22)}
${bColor(b3)}

`;
  }
  __name(printAnnotation, "printAnnotation");
  function printDiffLines(diffs, truncated, options) {
    return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`
${options.truncateAnnotation}`) : "");
  }
  __name(printDiffLines, "printDiffLines");
  function diffLinesUnified(aLines, bLines, options) {
    let normalizedOptions = normalizeDiffOptions(options), [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
    return printDiffLines(diffs, truncated, normalizedOptions);
  }
  __name(diffLinesUnified, "diffLinesUnified");
  function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
    if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare) && (aLinesDisplay = [], aLinesCompare = []), isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare) && (bLinesDisplay = [], bLinesCompare = []), aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length)
      return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
    let [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options), aIndex = 0, bIndex = 0;
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          diff2[1] = aLinesDisplay[aIndex], aIndex += 1;
          break;
        case DIFF_INSERT:
          diff2[1] = bLinesDisplay[bIndex], bIndex += 1;
          break;
        default:
          diff2[1] = bLinesDisplay[bIndex], aIndex += 1, bIndex += 1;
      }
    }), printDiffLines(diffs, truncated, normalizeDiffOptions(options));
  }
  __name(diffLinesUnified2, "diffLinesUnified2");
  function diffLinesRaw(aLines, bLines, options) {
    let truncate2 = options?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = truncate2 ? Math.min(aLines.length, truncateThreshold) : aLines.length, bLength = truncate2 ? Math.min(bLines.length, truncateThreshold) : bLines.length, truncated = aLength !== aLines.length || bLength !== bLines.length, isCommon = __name((aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], "isCommon"), diffs = [], aIndex = 0, bIndex = 0, foundSubsequence = __name((nCommon, aCommon, bCommon) => {
      for (; aIndex !== aCommon; aIndex += 1)
        diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
      for (; bIndex !== bCommon; bIndex += 1)
        diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
      for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1)
        diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
    }, "foundSubsequence");
    for (diffSequences(aLength, bLength, isCommon, foundSubsequence); aIndex !== aLength; aIndex += 1)
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    for (; bIndex !== bLength; bIndex += 1)
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    return [diffs, truncated];
  }
  __name(diffLinesRaw, "diffLinesRaw");
  function getType3(value2) {
    if (value2 === void 0)
      return "undefined";
    if (value2 === null)
      return "null";
    if (Array.isArray(value2))
      return "array";
    if (typeof value2 == "boolean")
      return "boolean";
    if (typeof value2 == "function")
      return "function";
    if (typeof value2 == "number")
      return "number";
    if (typeof value2 == "string")
      return "string";
    if (typeof value2 == "bigint")
      return "bigint";
    if (typeof value2 == "object") {
      if (value2 != null) {
        if (value2.constructor === RegExp)
          return "regexp";
        if (value2.constructor === Map)
          return "map";
        if (value2.constructor === Set)
          return "set";
        if (value2.constructor === Date)
          return "date";
      }
      return "object";
    } else if (typeof value2 == "symbol")
      return "symbol";
    throw new Error(`value of unknown type: ${value2}`);
  }
  __name(getType3, "getType");
  function getNewLineSymbol(string) {
    return string.includes(`\r
`) ? `\r
` : `
`;
  }
  __name(getNewLineSymbol, "getNewLineSymbol");
  function diffStrings(a22, b3, options) {
    let truncate2 = options?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = a22.length, bLength = b3.length;
    if (truncate2) {
      let aMultipleLines = a22.includes(`
`), bMultipleLines = b3.includes(`
`), aNewLineSymbol = getNewLineSymbol(a22), bNewLineSymbol = getNewLineSymbol(b3), _a = aMultipleLines ? `${a22.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a22, _b = bMultipleLines ? `${b3.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b3;
      aLength = _a.length, bLength = _b.length;
    }
    let truncated = aLength !== a22.length || bLength !== b3.length, isCommon = __name((aIndex2, bIndex2) => a22[aIndex2] === b3[bIndex2], "isCommon"), aIndex = 0, bIndex = 0, diffs = [], foundSubsequence = __name((nCommon, aCommon, bCommon) => {
      aIndex !== aCommon && diffs.push(new Diff(DIFF_DELETE, a22.slice(aIndex, aCommon))), bIndex !== bCommon && diffs.push(new Diff(DIFF_INSERT, b3.slice(bIndex, bCommon))), aIndex = aCommon + nCommon, bIndex = bCommon + nCommon, diffs.push(new Diff(DIFF_EQUAL, b3.slice(bCommon, bIndex)));
    }, "foundSubsequence");
    return diffSequences(aLength, bLength, isCommon, foundSubsequence), aIndex !== aLength && diffs.push(new Diff(DIFF_DELETE, a22.slice(aIndex))), bIndex !== bLength && diffs.push(new Diff(DIFF_INSERT, b3.slice(bIndex))), [diffs, truncated];
  }
  __name(diffStrings, "diffStrings");
  function concatenateRelevantDiffs(op, diffs, changeColor) {
    return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
  }
  __name(concatenateRelevantDiffs, "concatenateRelevantDiffs");
  var _ChangeBuffer = class {
    op;
    line;
    lines;
    changeColor;
    constructor(op, changeColor) {
      this.op = op, this.line = [], this.lines = [], this.changeColor = changeColor;
    }
    pushSubstring(substring) {
      this.pushDiff(new Diff(this.op, substring));
    }
    pushLine() {
      this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1])), this.line.length = 0;
    }
    isLineEmpty() {
      return this.line.length === 0;
    }
    // Minor input to buffer.
    pushDiff(diff2) {
      this.line.push(diff2);
    }
    // Main input to buffer.
    align(diff2) {
      let string = diff2[1];
      if (string.includes(`
`)) {
        let substrings = string.split(`
`), iLast = substrings.length - 1;
        substrings.forEach((substring, i3) => {
          i3 < iLast ? (this.pushSubstring(substring), this.pushLine()) : substring.length !== 0 && this.pushSubstring(substring);
        });
      } else
        this.pushDiff(diff2);
    }
    // Output from buffer.
    moveLinesTo(lines) {
      this.isLineEmpty() || this.pushLine(), lines.push(...this.lines), this.lines.length = 0;
    }
  };
  __name(_ChangeBuffer, "ChangeBuffer");
  var ChangeBuffer = _ChangeBuffer, _CommonBuffer = class {
    deleteBuffer;
    insertBuffer;
    lines;
    constructor(deleteBuffer, insertBuffer) {
      this.deleteBuffer = deleteBuffer, this.insertBuffer = insertBuffer, this.lines = [];
    }
    pushDiffCommonLine(diff2) {
      this.lines.push(diff2);
    }
    pushDiffChangeLines(diff2) {
      let isDiffEmpty = diff2[1].length === 0;
      (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(diff2), (!isDiffEmpty || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(diff2);
    }
    flushChangeLines() {
      this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
    }
    // Input to buffer.
    align(diff2) {
      let op = diff2[0], string = diff2[1];
      if (string.includes(`
`)) {
        let substrings = string.split(`
`), iLast = substrings.length - 1;
        substrings.forEach((substring, i3) => {
          if (i3 === 0) {
            let subdiff = new Diff(op, substring);
            this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(subdiff)) : (this.pushDiffChangeLines(subdiff), this.flushChangeLines());
          } else i3 < iLast ? this.pushDiffCommonLine(new Diff(op, substring)) : substring.length !== 0 && this.pushDiffChangeLines(new Diff(op, substring));
        });
      } else
        this.pushDiffChangeLines(diff2);
    }
    // Output from buffer.
    getLines() {
      return this.flushChangeLines(), this.lines;
    }
  };
  __name(_CommonBuffer, "CommonBuffer");
  var CommonBuffer = _CommonBuffer;
  function getAlignedDiffs(diffs, changeColor) {
    let deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor), insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor), commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
    return diffs.forEach((diff2) => {
      switch (diff2[0]) {
        case DIFF_DELETE:
          deleteBuffer.align(diff2);
          break;
        case DIFF_INSERT:
          insertBuffer.align(diff2);
          break;
        default:
          commonBuffer.align(diff2);
      }
    }), commonBuffer.getLines();
  }
  __name(getAlignedDiffs, "getAlignedDiffs");
  function hasCommonDiff(diffs, isMultiline) {
    if (isMultiline) {
      let iLast = diffs.length - 1;
      return diffs.some((diff2, i3) => diff2[0] === DIFF_EQUAL && (i3 !== iLast || diff2[1] !== `
`));
    }
    return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
  }
  __name(hasCommonDiff, "hasCommonDiff");
  function diffStringsUnified(a22, b3, options) {
    if (a22 !== b3 && a22.length !== 0 && b3.length !== 0) {
      let isMultiline = a22.includes(`
`) || b3.includes(`
`), [diffs, truncated] = diffStringsRaw(isMultiline ? `${a22}
` : a22, isMultiline ? `${b3}
` : b3, !0, options);
      if (hasCommonDiff(diffs, isMultiline)) {
        let optionsNormalized = normalizeDiffOptions(options), lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
        return printDiffLines(lines, truncated, optionsNormalized);
      }
    }
    return diffLinesUnified(a22.split(`
`), b3.split(`
`), options);
  }
  __name(diffStringsUnified, "diffStringsUnified");
  function diffStringsRaw(a22, b3, cleanup, options) {
    let [diffs, truncated] = diffStrings(a22, b3, options);
    return cleanup && diff_cleanupSemantic(diffs), [diffs, truncated];
  }
  __name(diffStringsRaw, "diffStringsRaw");
  function getCommonMessage(message, options) {
    let { commonColor } = normalizeDiffOptions(options);
    return commonColor(message);
  }
  __name(getCommonMessage, "getCommonMessage");
  var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins, PLUGINS2 = [
    ReactTestComponent2,
    ReactElement2,
    DOMElement2,
    DOMCollection2,
    Immutable2,
    AsymmetricMatcher2,
    plugins.Error
  ], FORMAT_OPTIONS = {
    maxDepth: 20,
    plugins: PLUGINS2
  }, FALLBACK_FORMAT_OPTIONS = {
    callToJSON: !1,
    maxDepth: 8,
    plugins: PLUGINS2
  };
  function diff(a22, b3, options) {
    if (Object.is(a22, b3))
      return "";
    let aType = getType3(a22), expectedType = aType, omitDifference = !1;
    if (aType === "object" && typeof a22.asymmetricMatch == "function") {
      if (a22.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof a22.getExpectedType != "function")
        return;
      expectedType = a22.getExpectedType(), omitDifference = expectedType === "string";
    }
    if (expectedType !== getType3(b3)) {
      let truncate2 = function(s22) {
        return s22.length <= MAX_LENGTH ? s22 : `${s22.slice(0, MAX_LENGTH)}...`;
      };
      __name(truncate2, "truncate");
      let { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options), formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options), aDisplay = format2(a22, formatOptions), bDisplay = format2(b3, formatOptions), MAX_LENGTH = 1e5;
      aDisplay = truncate2(aDisplay), bDisplay = truncate2(bDisplay);
      let aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`, bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
      return `${aDiff}

${bDiff}`;
    }
    if (!omitDifference)
      switch (aType) {
        case "string":
          return diffLinesUnified(a22.split(`
`), b3.split(`
`), options);
        case "boolean":
        case "number":
          return comparePrimitive(a22, b3, options);
        case "map":
          return compareObjects(sortMap(a22), sortMap(b3), options);
        case "set":
          return compareObjects(sortSet(a22), sortSet(b3), options);
        default:
          return compareObjects(a22, b3, options);
      }
  }
  __name(diff, "diff");
  function comparePrimitive(a22, b3, options) {
    let aFormat = format2(a22, FORMAT_OPTIONS), bFormat = format2(b3, FORMAT_OPTIONS);
    return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split(`
`), bFormat.split(`
`), options);
  }
  __name(comparePrimitive, "comparePrimitive");
  function sortMap(map2) {
    return new Map(Array.from(map2.entries()).sort());
  }
  __name(sortMap, "sortMap");
  function sortSet(set) {
    return new Set(Array.from(set.values()).sort());
  }
  __name(sortSet, "sortSet");
  function compareObjects(a22, b3, options) {
    let difference, hasThrown = !1;
    try {
      let formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
      difference = getObjectsDifference(a22, b3, formatOptions, options);
    } catch {
      hasThrown = !0;
    }
    let noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
    if (difference === void 0 || difference === noDiffMessage) {
      let formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
      difference = getObjectsDifference(a22, b3, formatOptions, options), difference !== noDiffMessage && !hasThrown && (difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}

${difference}`);
    }
    return difference;
  }
  __name(compareObjects, "compareObjects");
  function getFormatOptions(formatOptions, options) {
    let { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
    return {
      ...formatOptions,
      compareKeys,
      printBasicPrototype,
      maxDepth: maxDepth ?? formatOptions.maxDepth
    };
  }
  __name(getFormatOptions, "getFormatOptions");
  function getObjectsDifference(a22, b3, formatOptions, options) {
    let formatOptionsZeroIndent = {
      ...formatOptions,
      indent: 0
    }, aCompare = format2(a22, formatOptionsZeroIndent), bCompare = format2(b3, formatOptionsZeroIndent);
    if (aCompare === bCompare)
      return getCommonMessage(NO_DIFF_MESSAGE, options);
    {
      let aDisplay = format2(a22, formatOptions), bDisplay = format2(b3, formatOptions);
      return diffLinesUnified2(aDisplay.split(`
`), bDisplay.split(`
`), aCompare.split(`
`), bCompare.split(`
`), options);
    }
  }
  __name(getObjectsDifference, "getObjectsDifference");
  var MAX_DIFF_STRING_LENGTH = 2e4;
  function isAsymmetricMatcher(data) {
    return getType2(data) === "Object" && typeof data.asymmetricMatch == "function";
  }
  __name(isAsymmetricMatcher, "isAsymmetricMatcher");
  function isReplaceable(obj1, obj2) {
    let obj1Type = getType2(obj1), obj2Type = getType2(obj2);
    return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
  }
  __name(isReplaceable, "isReplaceable");
  function printDiffOrStringify(received, expected, options) {
    let { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
    if (typeof expected == "string" && typeof received == "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
      if (expected.includes(`
`) || received.includes(`
`))
        return diffStringsUnified(expected, received, options);
      let [diffs] = diffStringsRaw(expected, received, !0), hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL), printLabel = getLabelPrinter(aAnnotation, bAnnotation), expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2)), receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
      return `${expectedLine}
${receivedLine}`;
    }
    let clonedExpected = deepClone(expected, { forceWritable: !0 }), clonedReceived = deepClone(received, { forceWritable: !0 }), { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
    return diff(replacedExpected, replacedActual, options);
  }
  __name(printDiffOrStringify, "printDiffOrStringify");
  function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
    return actual instanceof Error && expected instanceof Error && typeof actual.cause < "u" && typeof expected.cause > "u" ? (delete actual.cause, {
      replacedActual: actual,
      replacedExpected: expected
    }) : isReplaceable(actual, expected) ? actualReplaced.has(actual) || expectedReplaced.has(expected) ? {
      replacedActual: actual,
      replacedExpected: expected
    } : (actualReplaced.add(actual), expectedReplaced.add(expected), getOwnProperties(expected).forEach((key) => {
      let expectedValue = expected[key], actualValue = actual[key];
      if (isAsymmetricMatcher(expectedValue))
        expectedValue.asymmetricMatch(actualValue) && (actual[key] = expectedValue);
      else if (isAsymmetricMatcher(actualValue))
        actualValue.asymmetricMatch(expectedValue) && (expected[key] = actualValue);
      else if (isReplaceable(actualValue, expectedValue)) {
        let replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
        actual[key] = replaced.replacedActual, expected[key] = replaced.replacedExpected;
      }
    }), {
      replacedActual: actual,
      replacedExpected: expected
    }) : {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  __name(replaceAsymmetricMatcher, "replaceAsymmetricMatcher");
  function getLabelPrinter(...strings) {
    let maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);
    return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
  }
  __name(getLabelPrinter, "getLabelPrinter");
  var SPACE_SYMBOL = "\xB7";
  function replaceTrailingSpaces(text) {
    return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
  }
  __name(replaceTrailingSpaces, "replaceTrailingSpaces");
  function printReceived(object2) {
    return s.red(replaceTrailingSpaces(stringify2(object2)));
  }
  __name(printReceived, "printReceived");
  function printExpected(value2) {
    return s.green(replaceTrailingSpaces(stringify2(value2)));
  }
  __name(printExpected, "printExpected");
  function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
    return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? s.inverse(diff2[1]) : diff2[1] : ""), "");
  }
  __name(getCommonAndChangedSubstrings, "getCommonAndChangedSubstrings");
  var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@", IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
  function isImmutable(v3) {
    return v3 && (v3[IS_COLLECTION_SYMBOL] || v3[IS_RECORD_SYMBOL]);
  }
  __name(isImmutable, "isImmutable");
  var OBJECT_PROTO = Object.getPrototypeOf({});
  function getUnserializableMessage(err) {
    return err instanceof Error ? `<unserializable>: ${err.message}` : typeof err == "string" ? `<unserializable>: ${err}` : "<unserializable>";
  }
  __name(getUnserializableMessage, "getUnserializableMessage");
  function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
    if (!val || typeof val == "string")
      return val;
    if (val instanceof Error && "toJSON" in val && typeof val.toJSON == "function") {
      let jsonValue = val.toJSON();
      return jsonValue && jsonValue !== val && typeof jsonValue == "object" && (typeof val.message == "string" && safe(() => jsonValue.message ?? (jsonValue.message = val.message)), typeof val.stack == "string" && safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack)), typeof val.name == "string" && safe(() => jsonValue.name ?? (jsonValue.name = val.name)), val.cause != null && safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)))), serializeValue(jsonValue, seen);
    }
    if (typeof val == "function")
      return `Function<${val.name || "anonymous"}>`;
    if (typeof val == "symbol")
      return val.toString();
    if (typeof val != "object")
      return val;
    if (typeof Buffer < "u" && val instanceof Buffer)
      return `<Buffer(${val.length}) ...>`;
    if (typeof Uint8Array < "u" && val instanceof Uint8Array)
      return `<Uint8Array(${val.length}) ...>`;
    if (isImmutable(val))
      return serializeValue(val.toJSON(), seen);
    if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction")
      return "Promise";
    if (typeof Element < "u" && val instanceof Element)
      return val.tagName;
    if (typeof val.asymmetricMatch == "function")
      return `${val.toString()} ${format22(val.sample)}`;
    if (typeof val.toJSON == "function")
      return serializeValue(val.toJSON(), seen);
    if (seen.has(val))
      return seen.get(val);
    if (Array.isArray(val)) {
      let clone2 = new Array(val.length);
      return seen.set(val, clone2), val.forEach((e, i3) => {
        try {
          clone2[i3] = serializeValue(e, seen);
        } catch (err) {
          clone2[i3] = getUnserializableMessage(err);
        }
      }), clone2;
    } else {
      let clone2 = /* @__PURE__ */ Object.create(null);
      seen.set(val, clone2);
      let obj = val;
      for (; obj && obj !== OBJECT_PROTO; )
        Object.getOwnPropertyNames(obj).forEach((key) => {
          if (!(key in clone2))
            try {
              clone2[key] = serializeValue(val[key], seen);
            } catch (err) {
              delete clone2[key], clone2[key] = getUnserializableMessage(err);
            }
        }), obj = Object.getPrototypeOf(obj);
      return clone2;
    }
  }
  __name(serializeValue, "serializeValue");
  function safe(fn2) {
    try {
      return fn2();
    } catch {
    }
  }
  __name(safe, "safe");
  function normalizeErrorMessage(message) {
    return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
  }
  __name(normalizeErrorMessage, "normalizeErrorMessage");
  function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
    if (!_err || typeof _err != "object")
      return { message: String(_err) };
    let err = _err;
    (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) && (err.diff = printDiffOrStringify(err.actual, err.expected, {
      ...diffOptions,
      ...err.diffOptions
    })), "expected" in err && typeof err.expected != "string" && (err.expected = stringify2(err.expected, 10)), "actual" in err && typeof err.actual != "string" && (err.actual = stringify2(err.actual, 10));
    try {
      typeof err.message == "string" && (err.message = normalizeErrorMessage(err.message));
    } catch {
    }
    try {
      !seen.has(err) && typeof err.cause == "object" && (seen.add(err), err.cause = processError(err.cause, diffOptions, seen));
    } catch {
    }
    try {
      return serializeValue(err);
    } catch (e) {
      return serializeValue(new Error(`Failed to fully serialize error: ${e?.message}
Inner error message: ${err?.message}`));
    }
  }
  __name(processError, "processError");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/instrumenter/index.js
  init_chunk_MM7DTO55();
  var addons3 = globalThis.__STORYBOOK_ADDONS_PREVIEW, alreadyCompletedException = new Error(
    "This function ran after the play function completed. Did you forget to `await` it?"
  ), isObject3 = __name((o2) => Object.prototype.toString.call(o2) === "[object Object]", "isObject"), isModule = __name((o2) => Object.prototype.toString.call(o2) === "[object Module]", "isModule"), isInstrumentable = __name((o2) => {
    if (!isObject3(o2) && !isModule(o2))
      return !1;
    if (o2.constructor === void 0)
      return !0;
    let proto = o2.constructor.prototype;
    return !!isObject3(proto);
  }, "isInstrumentable"), construct = __name((obj) => {
    try {
      return new obj.constructor();
    } catch {
      return {};
    }
  }, "construct"), getInitialState = __name(() => ({
    renderPhase: "preparing",
    isDebugging: !1,
    isPlaying: !1,
    isLocked: !1,
    cursor: 0,
    calls: [],
    shadowCalls: [],
    callRefsByResult: /* @__PURE__ */ new Map(),
    chainedCallIds: /* @__PURE__ */ new Set(),
    ancestors: [],
    playUntil: void 0,
    resolvers: {},
    syncTimeout: void 0
  }), "getInitialState"), getRetainedState = __name((state3, isDebugging = !1) => {
    let calls = (isDebugging ? state3.shadowCalls : state3.calls).filter((call) => call.retain);
    if (!calls.length)
      return;
    let callRefsByResult = new Map(
      Array.from(state3.callRefsByResult.entries()).filter(([, ref]) => ref.retain)
    );
    return { cursor: calls.length, calls, callRefsByResult };
  }, "getRetainedState"), _Instrumenter = class {
    constructor() {
      this.detached = !1, this.initialized = !1, this.state = {}, this.loadParentWindowState = __name(() => {
        try {
          this.state = scope.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
        } catch {
          this.detached = !0;
        }
      }, "loadParentWindowState"), this.updateParentWindowState = __name(() => {
        try {
          scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
        } catch {
          this.detached = !0;
        }
      }, "updateParentWindowState"), this.loadParentWindowState();
      let resetState = __name(({
        storyId,
        renderPhase,
        isPlaying = !0,
        isDebugging = !1
      }) => {
        let state3 = this.getState(storyId);
        this.setState(storyId, {
          ...getInitialState(),
          ...getRetainedState(state3, isDebugging),
          renderPhase: renderPhase || state3.renderPhase,
          shadowCalls: isDebugging ? state3.shadowCalls : [],
          chainedCallIds: isDebugging ? state3.chainedCallIds : /* @__PURE__ */ new Set(),
          playUntil: isDebugging ? state3.playUntil : void 0,
          isPlaying,
          isDebugging
        }), this.sync(storyId);
      }, "resetState"), start = __name((channel) => ({ storyId, playUntil }) => {
        this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({
          calls: [],
          shadowCalls: calls.map((call) => ({
            ...call,
            status: "waiting"
            /* WAITING */
          })),
          isDebugging: !0
        }));
        let log = this.getLog(storyId);
        this.setState(storyId, ({ shadowCalls }) => {
          if (playUntil || !log.length)
            return { playUntil };
          let firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);
          return {
            playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id
          };
        }), channel.emit(FORCE_REMOUNT, { storyId, isDebugging: !0 });
      }, "start"), back = __name((channel) => ({ storyId }) => {
        let log = this.getLog(storyId).filter((call) => !call.ancestors?.length), last = log.reduceRight((res, item, index2) => res >= 0 || item.status === "waiting" ? res : index2, -1);
        start(channel)({ storyId, playUntil: log[last - 1]?.callId });
      }, "back"), goto = __name((channel) => ({ storyId, callId }) => {
        let { calls, shadowCalls, resolvers } = this.getState(storyId), call = calls.find(({ id: id2 }) => id2 === callId), shadowCall = shadowCalls.find(({ id: id2 }) => id2 === callId);
        if (!call && shadowCall && Object.values(resolvers).length > 0) {
          let nextId = this.getLog(storyId).find(
            (c3) => c3.status === "waiting"
            /* WAITING */
          )?.callId;
          shadowCall.id !== nextId && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());
        } else
          start(channel)({ storyId, playUntil: callId });
      }, "goto"), next = __name((channel) => ({ storyId }) => {
        let { resolvers } = this.getState(storyId);
        if (Object.values(resolvers).length > 0)
          Object.values(resolvers).forEach((resolve) => resolve());
        else {
          let nextId = this.getLog(storyId).find(
            (c3) => c3.status === "waiting"
            /* WAITING */
          )?.callId;
          nextId ? start(channel)({ storyId, playUntil: nextId }) : end({ storyId });
        }
      }, "next"), end = __name(({ storyId }) => {
        this.setState(storyId, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());
      }, "end"), renderPhaseChanged = __name(({
        storyId,
        newPhase
      }) => {
        let { isDebugging } = this.getState(storyId);
        if (newPhase === "preparing" && isDebugging)
          return resetState({ storyId, renderPhase: newPhase, isDebugging });
        if (newPhase === "playing")
          return resetState({ storyId, renderPhase: newPhase, isDebugging });
        newPhase === "played" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !1,
          isPlaying: !1,
          isDebugging: !1
        }) : newPhase === "errored" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !1,
          isPlaying: !1
        }) : newPhase === "aborted" ? this.setState(storyId, {
          renderPhase: newPhase,
          isLocked: !0,
          isPlaying: !1
        }) : this.setState(storyId, {
          renderPhase: newPhase
        }), this.sync(storyId);
      }, "renderPhaseChanged");
      addons3 && addons3.ready().then(() => {
        this.channel = addons3.getChannel(), this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged), this.channel.on(SET_CURRENT_STORY, () => {
          this.initialized ? this.cleanup() : this.initialized = !0;
        }), this.channel.on(EVENTS3.START, start(this.channel)), this.channel.on(EVENTS3.BACK, back(this.channel)), this.channel.on(EVENTS3.GOTO, goto(this.channel)), this.channel.on(EVENTS3.NEXT, next(this.channel)), this.channel.on(EVENTS3.END, end);
      });
    }
    getState(storyId) {
      return this.state[storyId] || getInitialState();
    }
    setState(storyId, update) {
      if (storyId) {
        let state3 = this.getState(storyId), patch = typeof update == "function" ? update(state3) : update;
        this.state = { ...this.state, [storyId]: { ...state3, ...patch } }, this.updateParentWindowState();
      }
    }
    cleanup() {
      this.state = Object.entries(this.state).reduce(
        (acc, [storyId, state3]) => {
          let retainedState = getRetainedState(state3);
          return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;
        },
        {}
      );
      let payload = { controlStates: {
        detached: this.detached,
        start: !1,
        back: !1,
        goto: !1,
        next: !1,
        end: !1
      }, logItems: [] };
      this.channel?.emit(EVENTS3.SYNC, payload), this.updateParentWindowState();
    }
    getLog(storyId) {
      let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];
      calls.forEach((call, index2) => {
        merged[index2] = call;
      });
      let seen = /* @__PURE__ */ new Set();
      return merged.reduceRight((acc, call) => (call.args.forEach((arg) => {
        arg?.__callId__ && seen.add(arg.__callId__);
      }), call.path.forEach((node) => {
        node.__callId__ && seen.add(node.__callId__);
      }), (call.interceptable || call.exception) && !seen.has(call.id) && (acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors }), seen.add(call.id)), acc), []);
    }
    // Traverses the object structure to recursively patch all function properties.
    // Returns the original object, or a new object with the same constructor,
    // depending on whether it should mutate.
    instrument(obj, options, depth = 0) {
      if (!isInstrumentable(obj))
        return obj;
      let { mutate = !1, path = [] } = options, keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);
      return depth += 1, keys.reduce(
        (acc, key) => {
          let descriptor = getPropertyDescriptor(obj, key);
          if (typeof descriptor?.get == "function") {
            if (descriptor.configurable) {
              let getter = __name(() => descriptor?.get?.bind(obj)?.(), "getter");
              Object.defineProperty(acc, key, {
                get: __name(() => this.instrument(getter(), { ...options, path: path.concat(key) }, depth), "get")
              });
            }
            return acc;
          }
          let value2 = obj[key];
          return typeof value2 != "function" ? (acc[key] = this.instrument(value2, { ...options, path: path.concat(key) }, depth), acc) : "__originalFn__" in value2 && typeof value2.__originalFn__ == "function" ? (acc[key] = value2, acc) : (acc[key] = (...args) => this.track(key, value2, obj, args, options), acc[key].__originalFn__ = value2, Object.defineProperty(acc[key], "name", { value: key, writable: !1 }), Object.keys(value2).length > 0 && Object.assign(
            acc[key],
            this.instrument({ ...value2 }, { ...options, path: path.concat(key) }, depth)
          ), acc);
        },
        mutate ? obj : construct(obj)
      );
    }
    // Monkey patch an object method to record calls.
    // Returns a function that invokes the original function, records the invocation ("call") and
    // returns the original result.
    track(method, fn2, object2, args, options) {
      let storyId = args?.[0]?.__storyId__ || scope.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor, ancestors } = this.getState(storyId);
      this.setState(storyId, { cursor: cursor + 1 });
      let id2 = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = !1, retain = !1 } = options, interceptable = typeof intercept == "function" ? intercept(method, path) : intercept, call = { id: id2, cursor, storyId, ancestors, path, method, args, interceptable, retain }, result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn2, object2, call, options);
      return this.instrument(result, { ...options, mutate: !0, path: [{ __callId__: call.id }] });
    }
    intercept(fn2, object2, call, options) {
      let { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId), isChainedUpon = chainedCallIds.has(call.id);
      return !isDebugging || isChainedUpon || playUntil ? (playUntil === call.id && this.setState(call.storyId, { playUntil: void 0 }), this.invoke(fn2, object2, call, options)) : new Promise((resolve) => {
        this.setState(call.storyId, ({ resolvers }) => ({
          isLocked: !1,
          resolvers: { ...resolvers, [call.id]: resolve }
        }));
      }).then(() => (this.setState(call.storyId, (state3) => {
        let { [call.id]: _3, ...resolvers } = state3.resolvers;
        return { isLocked: !0, resolvers };
      }), this.invoke(fn2, object2, call, options)));
    }
    invoke(fn2, object2, call, options) {
      let { callRefsByResult, renderPhase } = this.getState(call.storyId), maximumDepth = 25, serializeValues = __name((value2, depth, seen) => {
        if (seen.includes(value2))
          return "[Circular]";
        if (seen = [...seen, value2], depth > maximumDepth)
          return "...";
        if (callRefsByResult.has(value2))
          return callRefsByResult.get(value2);
        if (value2 instanceof Array)
          return value2.map((it) => serializeValues(it, ++depth, seen));
        if (value2 instanceof Date)
          return { __date__: { value: value2.toISOString() } };
        if (value2 instanceof Error) {
          let { name, message, stack } = value2;
          return { __error__: { name, message, stack } };
        }
        if (value2 instanceof RegExp) {
          let { flags, source } = value2;
          return { __regexp__: { flags, source } };
        }
        if (value2 instanceof scope.window?.HTMLElement) {
          let { prefix: prefix2, localName, id: id2, classList, innerText } = value2, classNames = Array.from(classList);
          return { __element__: { prefix: prefix2, localName, id: id2, classNames, innerText } };
        }
        return typeof value2 == "function" ? {
          __function__: { name: "getMockName" in value2 ? value2.getMockName() : value2.name }
        } : typeof value2 == "symbol" ? { __symbol__: { description: value2.description } } : typeof value2 == "object" && value2?.constructor?.name && value2?.constructor?.name !== "Object" ? { __class__: { name: value2.constructor.name } } : Object.prototype.toString.call(value2) === "[object Object]" ? Object.fromEntries(
          Object.entries(value2).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])
        ) : value2;
      }, "serializeValues"), info = {
        ...call,
        args: call.args.map((arg) => serializeValues(arg, 0, []))
      };
      call.path.forEach((ref) => {
        ref?.__callId__ && this.setState(call.storyId, ({ chainedCallIds }) => ({
          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))
        }));
      });
      let handleException = __name((e) => {
        if (e instanceof Error) {
          let { name, message, stack, callId = call.id } = e, {
            showDiff = void 0,
            diff: diff2 = void 0,
            actual = void 0,
            expected = void 0
          } = e.name === "AssertionError" ? processError(e) : e, exception = { name, message, stack, callId, showDiff, diff: diff2, actual, expected };
          if (this.update({ ...info, status: "error", exception }), this.setState(call.storyId, (state3) => ({
            callRefsByResult: new Map([
              ...Array.from(state3.callRefsByResult.entries()),
              [e, { __callId__: call.id, retain: call.retain }]
            ])
          })), call.ancestors?.length)
            throw Object.prototype.hasOwnProperty.call(e, "callId") || Object.defineProperty(e, "callId", { value: call.id }), e;
        }
        throw e;
      }, "handleException");
      try {
        if (renderPhase === "played" && !call.retain)
          throw alreadyCompletedException;
        let finalArgs = (options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args).map((arg) => typeof arg != "function" || isClass(arg) || Object.keys(arg).length ? arg : (...args) => {
          let { cursor, ancestors } = this.getState(call.storyId);
          this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });
          let restore = __name(() => this.setState(call.storyId, { cursor, ancestors }), "restore"), willRestore = !1;
          try {
            let res = arg(...args);
            return res instanceof Promise ? (willRestore = !0, res.finally(restore)) : res;
          } finally {
            willRestore || restore();
          }
        }), result = fn2.apply(object2, finalArgs);
        return result && ["object", "function", "symbol"].includes(typeof result) && this.setState(call.storyId, (state3) => ({
          callRefsByResult: new Map([
            ...Array.from(state3.callRefsByResult.entries()),
            [result, { __callId__: call.id, retain: call.retain }]
          ])
        })), this.update({
          ...info,
          status: result instanceof Promise ? "active" : "done"
          /* DONE */
        }), result instanceof Promise ? result.then((value2) => (this.update({
          ...info,
          status: "done"
          /* DONE */
        }), value2), handleException) : result;
      } catch (e) {
        return handleException(e);
      }
    }
    // Sends the call info to the manager and synchronizes the log.
    update(call) {
      this.channel?.emit(EVENTS3.CALL, call), this.setState(call.storyId, ({ calls }) => {
        let callsById = calls.concat(call).reduce((a3, c3) => Object.assign(a3, { [c3.id]: c3 }), {});
        return {
          // Calls are sorted to ensure parent calls always come before calls in their callback.
          calls: Object.values(callsById).sort(
            (a3, b3) => a3.id.localeCompare(b3.id, void 0, { numeric: !0 })
          )
        };
      }), this.sync(call.storyId);
    }
    // Builds a log of interceptable calls and control states and sends it to the manager.
    // Uses a 0ms debounce because this might get called many times in one tick.
    sync(storyId) {
      let synchronize = __name(() => {
        let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find(
          (item) => item.status === "waiting"
          /* WAITING */
        )?.callId, hasActive = logItems.some(
          (item) => item.status === "active"
          /* ACTIVE */
        );
        if (this.detached || isLocked || hasActive || logItems.length === 0) {
          let payload2 = { controlStates: {
            detached: this.detached,
            start: !1,
            back: !1,
            goto: !1,
            next: !1,
            end: !1
          }, logItems };
          this.channel?.emit(EVENTS3.SYNC, payload2);
          return;
        }
        let hasPrevious = logItems.some(
          (item) => item.status === "done" || item.status === "error"
          /* ERROR */
        ), payload = { controlStates: {
          detached: this.detached,
          start: hasPrevious,
          back: hasPrevious,
          goto: !0,
          next: isPlaying,
          end: isPlaying
        }, logItems, pausedAt };
        this.channel?.emit(EVENTS3.SYNC, payload);
      }, "synchronize");
      this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));
    }
  };
  __name(_Instrumenter, "Instrumenter");
  var Instrumenter = _Instrumenter;
  function instrument(obj, options = {}) {
    try {
      let forceInstrument = !1, skipInstrument = !1;
      return scope.window?.location?.search?.includes("instrument=true") ? forceInstrument = !0 : scope.window?.location?.search?.includes("instrument=false") && (skipInstrument = !0), scope.window?.parent === scope.window && !forceInstrument || skipInstrument ? obj : (scope.window && !scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), (scope.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(obj, options));
    } catch (e) {
      return once.warn(e), obj;
    }
  }
  __name(instrument, "instrument");
  function getPropertyDescriptor(obj, propName) {
    let target = obj;
    for (; target != null; ) {
      let descriptor = Object.getOwnPropertyDescriptor(target, propName);
      if (descriptor)
        return descriptor;
      target = Object.getPrototypeOf(target);
    }
  }
  __name(getPropertyDescriptor, "getPropertyDescriptor");
  function isClass(obj) {
    if (typeof obj != "function")
      return !1;
    let descriptor = Object.getOwnPropertyDescriptor(obj, "prototype");
    return descriptor ? !descriptor.writable : !1;
  }
  __name(isClass, "isClass");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/csf/index.js
  var require_tiny_isequal = __commonJS({
    "../node_modules/@ngard/tiny-isequal/index.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: !0 }), exports.isEqual = /* @__PURE__ */ (function() {
        var e = Object.prototype.toString, r2 = Object.getPrototypeOf, t = Object.getOwnPropertySymbols ? function(e2) {
          return Object.keys(e2).concat(Object.getOwnPropertySymbols(e2));
        } : Object.keys;
        return function(n2, a3) {
          return __name(function n22(a22, c3, u3) {
            var i3, s4, l2, o2 = e.call(a22), f4 = e.call(c3);
            if (a22 === c3) return !0;
            if (a22 == null || c3 == null) return !1;
            if (u3.indexOf(a22) > -1 && u3.indexOf(c3) > -1) return !0;
            if (u3.push(a22, c3), o2 != f4 || (i3 = t(a22), s4 = t(c3), i3.length != s4.length || i3.some(function(e2) {
              return !n22(a22[e2], c3[e2], u3);
            }))) return !1;
            switch (o2.slice(8, -1)) {
              case "Symbol":
                return a22.valueOf() == c3.valueOf();
              case "Date":
              case "Number":
                return +a22 == +c3 || +a22 != +a22 && +c3 != +c3;
              case "RegExp":
              case "Function":
              case "String":
              case "Boolean":
                return "" + a22 == "" + c3;
              case "Set":
              case "Map":
                i3 = a22.entries(), s4 = c3.entries();
                do
                  if (!n22((l2 = i3.next()).value, s4.next().value, u3)) return !1;
                while (!l2.done);
                return !0;
              case "ArrayBuffer":
                a22 = new Uint8Array(a22), c3 = new Uint8Array(c3);
              case "DataView":
                a22 = new Uint8Array(a22.buffer), c3 = new Uint8Array(c3.buffer);
              case "Float32Array":
              case "Float64Array":
              case "Int8Array":
              case "Int16Array":
              case "Int32Array":
              case "Uint8Array":
              case "Uint16Array":
              case "Uint32Array":
              case "Uint8ClampedArray":
              case "Arguments":
              case "Array":
                if (a22.length != c3.length) return !1;
                for (l2 = 0; l2 < a22.length; l2++) if ((l2 in a22 || l2 in c3) && (l2 in a22 != l2 in c3 || !n22(a22[l2], c3[l2], u3))) return !1;
                return !0;
              case "Object":
                return n22(r2(a22), r2(c3), u3);
              default:
                return !1;
            }
          }, "n")(n2, a3, []);
        };
      })();
    }
  });
  function toStartCaseStr(str2) {
    return str2.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (str22, $1, $22, $3) => `${$1} ${$22}${$3}`).replace(/([a-z])([A-Z])/g, (str22, $1, $22) => `${$1} ${$22}`).replace(/([a-z])([0-9])/gi, (str22, $1, $22) => `${$1} ${$22}`).replace(/([0-9])([a-z])/gi, (str22, $1, $22) => `${$1} ${$22}`).replace(/(\s|^)(\w)/g, (str22, $1, $22) => `${$1}${$22.toUpperCase()}`).replace(/ +/g, " ").trim();
  }
  __name(toStartCaseStr, "toStartCaseStr");
  var import_tiny_isequal = __toESM(require_tiny_isequal(), 1), count = __name((vals) => vals.map((v3) => typeof v3 < "u").filter(Boolean).length, "count"), testValue = __name((cond, value2) => {
    let { exists, eq: eq2, neq, truthy } = cond;
    if (count([exists, eq2, neq, truthy]) > 1)
      throw new Error(`Invalid conditional test ${JSON.stringify({ exists, eq: eq2, neq })}`);
    if (typeof eq2 < "u")
      return (0, import_tiny_isequal.isEqual)(value2, eq2);
    if (typeof neq < "u")
      return !(0, import_tiny_isequal.isEqual)(value2, neq);
    if (typeof exists < "u") {
      let valueExists = typeof value2 < "u";
      return exists ? valueExists : !valueExists;
    }
    return (typeof truthy > "u" ? !0 : truthy) ? !!value2 : !value2;
  }, "testValue"), includeConditionalArg = __name((argType, args, globals) => {
    if (!argType.if)
      return !0;
    let { arg, global: global5 } = argType.if;
    if (count([arg, global5]) !== 1)
      throw new Error(`Invalid conditional value ${JSON.stringify({ arg, global: global5 })}`);
    let value2 = arg ? args[arg] : globals[global5];
    return testValue(argType.if, value2);
  }, "includeConditionalArg"), addArgs_exports = {};
  __export2(addArgs_exports, {
    argsEnhancers: () => argsEnhancers
  });
  var isInInitialArgs = __name((name, initialArgs) => typeof initialArgs[name] > "u" && !(name in initialArgs), "isInInitialArgs"), inferActionsFromArgTypesRegex = __name((context) => {
    let {
      initialArgs,
      argTypes,
      id: id2,
      parameters: { actions: actions2 }
    } = context;
    if (!actions2 || actions2.disable || !actions2.argTypesRegex || !argTypes)
      return {};
    let argTypesRegex = new RegExp(actions2.argTypesRegex);
    return Object.entries(argTypes).filter(
      ([name]) => !!argTypesRegex.test(name)
    ).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(name, { implicit: !0, id: id2 })), acc), {});
  }, "inferActionsFromArgTypesRegex"), addActionsFromArgTypes = __name((context) => {
    let {
      initialArgs,
      argTypes,
      parameters: { actions: actions2 }
    } = context;
    return actions2?.disable || !argTypes ? {} : Object.entries(argTypes).filter(([name, argType]) => !!argType.action).reduce((acc, [name, argType]) => (isInInitialArgs(name, initialArgs) && (acc[name] = action(typeof argType.action == "string" ? argType.action : name)), acc), {});
  }, "addActionsFromArgTypes"), argsEnhancers = [
    addActionsFromArgTypes,
    inferActionsFromArgTypesRegex
  ], loaders_exports = {};
  __export2(loaders_exports, {
    loaders: () => loaders
  });
  var subscribed = !1, logActionsWhenMockCalled = __name((context) => {
    let { parameters: parameters2 } = context;
    parameters2?.actions?.disable || subscribed || (onMockCall((mock, args) => {
      let name = mock.getMockName();
      name !== "spy" && name !== "vi.fn()" && (!/^next\/.*::/.test(name) || [
        "next/router::useRouter()",
        "next/navigation::useRouter()",
        "next/navigation::redirect",
        "next/cache::",
        "next/headers::cookies().set",
        "next/headers::cookies().delete",
        "next/headers::headers().set",
        "next/headers::headers().delete"
      ].some((prefix2) => name.startsWith(prefix2))) && action(name)(args);
    }), subscribed = !0);
  }, "logActionsWhenMockCalled"), loaders = [logActionsWhenMockCalled], preview_default = __name(() => ({
    ...addArgs_exports,
    ...loaders_exports
  }), "default"), { document: document22 } = globalThis, isReduceMotionEnabled = __name(() => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : !1, "isReduceMotionEnabled"), clearStyles = __name((selector) => {
    (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle);
  }, "clearStyles"), clearStyle = __name((selector) => {
    if (!document22)
      return;
    let element = document22.getElementById(selector);
    element && element.parentElement && element.parentElement.removeChild(element);
  }, "clearStyle"), addGridStyle = __name((selector, css2) => {
    if (!document22)
      return;
    let existingStyle = document22.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = document22.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2, document22.head.appendChild(style);
    }
  }, "addGridStyle"), addBackgroundStyle = __name((selector, css2, storyId) => {
    if (!document22)
      return;
    let existingStyle = document22.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = document22.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2;
      let gridStyleSelector = `addon-backgrounds-grid${storyId ? `-docs-${storyId}` : ""}`, existingGridStyle = document22.getElementById(gridStyleSelector);
      existingGridStyle ? existingGridStyle.parentElement?.insertBefore(style, existingGridStyle) : document22.head.appendChild(style);
    }
  }, "addBackgroundStyle"), defaultGrid = {
    cellSize: 100,
    cellAmount: 10,
    opacity: 0.8
  }, BG_SELECTOR_BASE = "addon-backgrounds", GRID_SELECTOR_BASE = "addon-backgrounds-grid", transitionStyle = isReduceMotionEnabled() ? "" : "transition: background-color 0.3s;", withBackgroundAndGrid = __name((StoryFn, context) => {
    let { globals = {}, parameters: parameters2 = {}, viewMode, id: id2 } = context, {
      options = DEFAULT_BACKGROUNDS,
      disable,
      grid = defaultGrid
    } = parameters2[PARAM_KEY] || {}, data = globals[PARAM_KEY] || {}, backgroundName = typeof data == "string" ? data : data?.value, item = backgroundName ? options[backgroundName] : void 0, value2 = typeof item == "string" ? item : item?.value || "transparent", showGrid = typeof data == "string" ? !1 : data.grid || !1, shownBackground = !!item && !disable, backgroundSelector = viewMode === "docs" ? `#anchor--${id2} .docs-story` : ".sb-show-main", gridSelector = viewMode === "docs" ? `#anchor--${id2} .docs-story` : ".sb-show-main", isLayoutPadded = parameters2.layout === void 0 || parameters2.layout === "padded", defaultOffset = viewMode === "docs" ? 20 : isLayoutPadded ? 16 : 0, { cellAmount, cellSize, opacity, offsetX = defaultOffset, offsetY = defaultOffset } = grid, backgroundSelectorId = viewMode === "docs" ? `${BG_SELECTOR_BASE}-docs-${id2}` : `${BG_SELECTOR_BASE}-color`, backgroundTarget = viewMode === "docs" ? id2 : null;
    useEffect2(() => {
      let backgroundStyles = `
    ${backgroundSelector} {
      background: ${value2} !important;
      ${transitionStyle}
      }`;
      if (!shownBackground) {
        clearStyles(backgroundSelectorId);
        return;
      }
      addBackgroundStyle(backgroundSelectorId, backgroundStyles, backgroundTarget);
    }, [backgroundSelector, backgroundSelectorId, backgroundTarget, shownBackground, value2]);
    let gridSelectorId = viewMode === "docs" ? `${GRID_SELECTOR_BASE}-docs-${id2}` : `${GRID_SELECTOR_BASE}`;
    return useEffect2(() => {
      if (!showGrid) {
        clearStyles(gridSelectorId);
        return;
      }
      let gridSize = [
        `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
        `${cellSize * cellAmount}px ${cellSize * cellAmount}px`,
        `${cellSize}px ${cellSize}px`,
        `${cellSize}px ${cellSize}px`
      ].join(", "), gridStyles = `
        ${gridSelector} {
          background-size: ${gridSize} !important;
          background-position: ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px, ${offsetX}px ${offsetY}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${opacity / 2}) 1px, transparent 1px) !important;
        }
      `;
      addGridStyle(gridSelectorId, gridStyles);
    }, [cellAmount, cellSize, gridSelector, gridSelectorId, showGrid, offsetX, offsetY, opacity]), StoryFn();
  }, "withBackgroundAndGrid"), decorators = globalThis.FEATURES?.backgrounds ? [withBackgroundAndGrid] : [], parameters = {
    [PARAM_KEY]: {
      grid: {
        cellSize: 20,
        opacity: 0.5,
        cellAmount: 5
      },
      disable: !1
    }
  }, initialGlobals = {
    [PARAM_KEY]: { value: void 0, grid: !1 }
  }, preview_default2 = __name(() => ({
    decorators,
    parameters,
    initialGlobals
  }), "default"), { step } = instrument(
    {
      // It seems like the label is unused, but the instrumenter has access to it
      // The context will be bounded later in StoryRender, so that the user can write just:
      // await step("label", (context) => {
      //   // labeled step
      // });
      step: __name(async (label, play, context) => play(context), "step")
    },
    { intercept: !0 }
  ), preview_default3 = __name(() => ({
    parameters: {
      throwPlayFunctionExceptions: !1
    },
    runStep: step
  }), "default"), iconPaths = {
    chevronLeft: [
      "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
    ],
    chevronRight: [
      "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
    ],
    info: [
      "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
      "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
    ],
    shareAlt: [
      "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
      "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
    ]
  }, svgElements = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), createElement2 = __name((type, props = {}, children) => {
    let element = svgElements.includes(type) ? document.createElementNS("http://www.w3.org/2000/svg", type) : document.createElement(type);
    return Object.entries(props).forEach(([key, val]) => {
      /[A-Z]/.test(key) ? (key === "onClick" && (element.addEventListener("click", val), element.addEventListener("keydown", (e) => {
        (e.key === "Enter" || e.key === " ") && (e.preventDefault(), val());
      })), key === "onMouseEnter" && element.addEventListener("mouseenter", val), key === "onMouseLeave" && element.addEventListener("mouseleave", val)) : element.setAttribute(key, val);
    }), children?.forEach((child) => {
      if (!(child == null || child === !1))
        try {
          element.appendChild(child);
        } catch {
          element.appendChild(document.createTextNode(String(child)));
        }
    }), element;
  }, "createElement"), createIcon = __name((name) => iconPaths[name] && createElement2(
    "svg",
    { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
    iconPaths[name].map(
      (d3) => createElement2("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: d3
      })
    )
  ), "createIcon"), normalizeOptions = __name((options) => {
    if ("elements" in options) {
      let { elements, color: color2, style } = options;
      return {
        id: void 0,
        priority: 0,
        selectors: elements,
        styles: {
          outline: `2px ${style} ${color2}`,
          outlineOffset: "2px",
          boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
        },
        menu: void 0
      };
    }
    let { menu, ...rest } = options;
    return {
      id: void 0,
      priority: 0,
      styles: {
        outline: "2px dashed #029cfd"
      },
      ...rest,
      menu: Array.isArray(menu) ? menu.every(Array.isArray) ? menu : [menu] : void 0
    };
  }, "normalizeOptions"), isFunction = __name((obj) => obj instanceof Function, "isFunction"), state = /* @__PURE__ */ new Map(), listeners = /* @__PURE__ */ new Map(), teardowns = /* @__PURE__ */ new Map(), useStore = __name((initialValue) => {
    let key = Symbol();
    listeners.set(key, []), state.set(key, initialValue);
    let get = __name(() => state.get(key), "get"), set = __name((update) => {
      let current = state.get(key), next = isFunction(update) ? update(current) : update;
      next !== current && (state.set(key, next), listeners.get(key)?.forEach((listener) => {
        teardowns.get(listener)?.(), teardowns.set(listener, listener(next));
      }));
    }, "set"), subscribe = __name((listener) => (listeners.get(key)?.push(listener), () => {
      let list = listeners.get(key);
      list && listeners.set(
        key,
        list.filter((l2) => l2 !== listener)
      );
    }), "subscribe"), teardown = __name(() => {
      listeners.get(key)?.forEach((listener) => {
        teardowns.get(listener)?.(), teardowns.delete(listener);
      }), listeners.delete(key), state.delete(key);
    }, "teardown");
    return { get, set, subscribe, teardown };
  }, "useStore"), mapElements = __name((highlights) => {
    let root = document.getElementById("storybook-root"), map2 = /* @__PURE__ */ new Map();
    for (let highlight2 of highlights) {
      let { priority = 0 } = highlight2;
      for (let selector of highlight2.selectors) {
        let elements = [
          ...document.querySelectorAll(
            // Elements matching the selector, excluding storybook elements and their descendants.
            // Necessary to find portaled elements (e.g. children of `body`).
            `:is(${selector}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
          ),
          // Elements matching the selector inside the storybook root, as these were excluded above.
          ...root?.querySelectorAll(selector) || []
        ];
        for (let element of elements) {
          let existing = map2.get(element);
          (!existing || existing.priority <= priority) && map2.set(element, {
            ...highlight2,
            priority,
            selectors: Array.from(new Set((existing?.selectors || []).concat(selector)))
          });
        }
      }
    }
    return map2;
  }, "mapElements"), mapBoxes = __name((elements) => Array.from(elements.entries()).map(([element, { selectors, styles: styles2, hoverStyles, focusStyles, menu }]) => {
    let { top, left, width, height } = element.getBoundingClientRect(), { position } = getComputedStyle(element);
    return {
      element,
      selectors,
      styles: styles2,
      hoverStyles,
      focusStyles,
      menu,
      top: position === "fixed" ? top : top + window.scrollY,
      left: position === "fixed" ? left : left + window.scrollX,
      width,
      height
    };
  }).sort((a3, b3) => b3.width * b3.height - a3.width * a3.height), "mapBoxes"), isOverMenu = __name((menuElement, coordinates) => {
    let menu = menuElement.getBoundingClientRect(), { x: x3, y: y3 } = coordinates;
    return menu?.top && menu?.left && x3 >= menu.left && x3 <= menu.left + menu.width && y3 >= menu.top && y3 <= menu.top + menu.height;
  }, "isOverMenu"), isTargeted = __name((box, boxElement, coordinates) => {
    if (!boxElement || !coordinates)
      return !1;
    let { left, top, width, height } = box;
    height < MIN_TOUCH_AREA_SIZE && (top = top - Math.round((MIN_TOUCH_AREA_SIZE - height) / 2), height = MIN_TOUCH_AREA_SIZE), width < MIN_TOUCH_AREA_SIZE && (left = left - Math.round((MIN_TOUCH_AREA_SIZE - width) / 2), width = MIN_TOUCH_AREA_SIZE), boxElement.style.position === "fixed" && (left += window.scrollX, top += window.scrollY);
    let { x: x3, y: y3 } = coordinates;
    return x3 >= left && x3 <= left + width && y3 >= top && y3 <= top + height;
  }, "isTargeted"), keepInViewport = __name((element, targetCoordinates, options = {}) => {
    let { x: x3, y: y3 } = targetCoordinates, { margin = 5, topOffset = 0, centered = !1 } = options, { scrollX, scrollY, innerHeight: windowHeight, innerWidth: windowWidth } = window, top = Math.min(
      element.style.position === "fixed" ? y3 - scrollY : y3,
      windowHeight - element.clientHeight - margin - topOffset + scrollY
    ), leftOffset = centered ? element.clientWidth / 2 : 0, left = element.style.position === "fixed" ? Math.max(Math.min(x3 - scrollX, windowWidth - leftOffset - margin), leftOffset + margin) : Math.max(
      Math.min(x3, windowWidth - leftOffset - margin + scrollX),
      leftOffset + margin + scrollX
    );
    Object.assign(element.style, {
      ...left !== x3 && { left: `${left}px` },
      ...top !== y3 && { top: `${top}px` }
    });
  }, "keepInViewport"), showPopover = __name((element) => {
    window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.showPopover();
  }, "showPopover"), hidePopover = __name((element) => {
    window.HTMLElement.prototype.hasOwnProperty("showPopover") && element.hidePopover();
  }, "hidePopover"), getEventDetails = __name((target) => ({
    top: target.top,
    left: target.left,
    width: target.width,
    height: target.height,
    selectors: target.selectors,
    element: {
      attributes: Object.fromEntries(
        Array.from(target.element.attributes).map((attr) => [attr.name, attr.value])
      ),
      localName: target.element.localName,
      tagName: target.element.tagName,
      outerHTML: target.element.outerHTML
    }
  }), "getEventDetails"), menuId = "storybook-highlights-menu", rootId = "storybook-highlights-root", storybookRootId = "storybook-root", useHighlights = __name((channel) => {
    if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
      return;
    globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
    let { document: document32 } = globalThis, highlights = useStore([]), elements = useStore(/* @__PURE__ */ new Map()), boxes = useStore([]), clickCoords = useStore(), hoverCoords = useStore(), targets = useStore([]), hovered = useStore([]), focused = useStore(), selected = useStore(), root = document32.getElementById(rootId);
    highlights.subscribe(() => {
      root || (root = createElement2("div", { id: rootId }), document32.body.appendChild(root));
    }), highlights.subscribe((value2) => {
      let storybookRoot = document32.getElementById(storybookRootId);
      if (!storybookRoot)
        return;
      elements.set(mapElements(value2));
      let observer = new MutationObserver(() => elements.set(mapElements(value2)));
      return observer.observe(storybookRoot, { subtree: !0, childList: !0 }), () => {
        observer.disconnect();
      };
    }), elements.subscribe((value2) => {
      let updateBoxes = __name(() => requestAnimationFrame(() => boxes.set(mapBoxes(value2))), "updateBoxes"), observer = new ResizeObserver(updateBoxes);
      observer.observe(document32.body), Array.from(value2.keys()).forEach((element) => observer.observe(element));
      let scrollers = Array.from(document32.body.querySelectorAll("*")).filter((el) => {
        let { overflow, overflowX, overflowY } = window.getComputedStyle(el);
        return ["auto", "scroll"].some((o2) => [overflow, overflowX, overflowY].includes(o2));
      });
      return scrollers.forEach((element) => element.addEventListener("scroll", updateBoxes)), () => {
        observer.disconnect(), scrollers.forEach((element) => element.removeEventListener("scroll", updateBoxes));
      };
    }), elements.subscribe((value2) => {
      let sticky = Array.from(value2.keys()).filter(({ style }) => style.position === "sticky"), updateBoxes = __name(() => requestAnimationFrame(() => {
        boxes.set(
          (current) => current.map((box) => {
            if (sticky.includes(box.element)) {
              let { top, left } = box.element.getBoundingClientRect();
              return { ...box, top: top + window.scrollY, left: left + window.scrollX };
            }
            return box;
          })
        );
      }), "updateBoxes");
      return document32.addEventListener("scroll", updateBoxes), () => document32.removeEventListener("scroll", updateBoxes);
    }), elements.subscribe((value2) => {
      targets.set((t) => t.filter(({ element }) => value2.has(element)));
    }), targets.subscribe((value2) => {
      value2.length ? (selected.set((s4) => value2.some((t) => t.element === s4?.element) ? s4 : void 0), focused.set((s4) => value2.some((t) => t.element === s4?.element) ? s4 : void 0)) : (selected.set(void 0), focused.set(void 0), clickCoords.set(void 0));
    });
    let styleElementByHighlight = new Map(/* @__PURE__ */ new Map());
    highlights.subscribe((value2) => {
      value2.forEach(({ keyframes: keyframes2 }) => {
        if (keyframes2) {
          let style = styleElementByHighlight.get(keyframes2);
          style || (style = document32.createElement("style"), style.setAttribute("data-highlight", "keyframes"), styleElementByHighlight.set(keyframes2, style), document32.head.appendChild(style)), style.innerHTML = keyframes2;
        }
      }), styleElementByHighlight.forEach((style, keyframes2) => {
        value2.some((v3) => v3.keyframes === keyframes2) || (style.remove(), styleElementByHighlight.delete(keyframes2));
      });
    });
    let boxElementByTargetElement = new Map(/* @__PURE__ */ new Map());
    boxes.subscribe((value2) => {
      value2.forEach((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        if (root && !boxElement) {
          let props = {
            popover: "manual",
            "data-highlight-dimensions": `w${box.width.toFixed(0)}h${box.height.toFixed(0)}`,
            "data-highlight-coordinates": `x${box.left.toFixed(0)}y${box.top.toFixed(0)}`
          };
          boxElement = root.appendChild(
            createElement2("div", props, [createElement2("div")])
          ), boxElementByTargetElement.set(box.element, boxElement);
        }
      }), boxElementByTargetElement.forEach((box, element) => {
        value2.some(({ element: e }) => e === element) || (box.remove(), boxElementByTargetElement.delete(element));
      });
    }), boxes.subscribe((value2) => {
      let targetable = value2.filter((box) => box.menu);
      if (!targetable.length)
        return;
      let onClick = __name((event) => {
        requestAnimationFrame(() => {
          let menu = document32.getElementById(menuId), coords = { x: event.pageX, y: event.pageY };
          if (menu && !isOverMenu(menu, coords)) {
            let results = targetable.filter((box) => {
              let boxElement = boxElementByTargetElement.get(box.element);
              return isTargeted(box, boxElement, coords);
            });
            clickCoords.set(results.length ? coords : void 0), targets.set(results);
          }
        });
      }, "onClick");
      return document32.addEventListener("click", onClick), () => document32.removeEventListener("click", onClick);
    });
    let updateHovered = __name(() => {
      let menu = document32.getElementById(menuId), coords = hoverCoords.get();
      !coords || menu && isOverMenu(menu, coords) || hovered.set((current) => {
        let update = boxes.get().filter((box) => {
          let boxElement = boxElementByTargetElement.get(box.element);
          return isTargeted(box, boxElement, coords);
        }), existing = current.filter((box) => update.includes(box)), additions = update.filter((box) => !current.includes(box)), hasRemovals = current.length - existing.length;
        return additions.length || hasRemovals ? [...existing, ...additions] : current;
      });
    }, "updateHovered");
    hoverCoords.subscribe(updateHovered), boxes.subscribe(updateHovered);
    let updateBoxStyles = __name(() => {
      let selectedElement = selected.get(), targetElements = selectedElement ? [selectedElement] : targets.get(), focusedElement = targetElements.length === 1 ? targetElements[0] : focused.get(), isMenuOpen = clickCoords.get() !== void 0;
      boxes.get().forEach((box) => {
        let boxElement = boxElementByTargetElement.get(box.element);
        if (boxElement) {
          let isFocused = focusedElement === box, isHovered = isMenuOpen ? focusedElement ? isFocused : targetElements.includes(box) : hovered.get()?.includes(box);
          Object.assign(boxElement.style, {
            animation: "none",
            background: "transparent",
            border: "none",
            boxSizing: "border-box",
            outline: "none",
            outlineOffset: "0px",
            ...box.styles,
            ...isHovered ? box.hoverStyles : {},
            ...isFocused ? box.focusStyles : {},
            position: getComputedStyle(box.element).position === "fixed" ? "fixed" : "absolute",
            zIndex: MAX_Z_INDEX - 10,
            top: `${box.top}px`,
            left: `${box.left}px`,
            width: `${box.width}px`,
            height: `${box.height}px`,
            margin: 0,
            padding: 0,
            cursor: box.menu && isHovered ? "pointer" : "default",
            pointerEvents: box.menu ? "auto" : "none",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            overflow: "visible"
          }), Object.assign(boxElement.children[0].style, {
            width: "100%",
            height: "100%",
            minHeight: `${MIN_TOUCH_AREA_SIZE}px`,
            minWidth: `${MIN_TOUCH_AREA_SIZE}px`,
            boxSizing: "content-box",
            padding: boxElement.style.outlineWidth || "0px"
          }), showPopover(boxElement);
        }
      });
    }, "updateBoxStyles");
    boxes.subscribe(updateBoxStyles), targets.subscribe(updateBoxStyles), hovered.subscribe(updateBoxStyles), focused.subscribe(updateBoxStyles), selected.subscribe(updateBoxStyles);
    let renderMenu = __name(() => {
      if (!root)
        return;
      let menu = document32.getElementById(menuId);
      if (menu)
        menu.innerHTML = "";
      else {
        let props = { id: menuId, popover: "manual" };
        menu = root.appendChild(createElement2("div", props)), root.appendChild(
          createElement2("style", {}, [
            `
            #${menuId} {
              position: absolute;
              z-index: ${MAX_Z_INDEX};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${menuId} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${menuId} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${menuId} li {
              padding: 0 4px;
              margin: 0;
            }
            #${menuId} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${menuId} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${menuId} button:focus-visible {
              outline-color: #029CFD;
            }
            #${menuId} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${menuId} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${menuId} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${menuId} li > button:hover svg, #${menuId} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${menuId} .element-list li svg {
              display: none;
            }
            #${menuId} li.selectable svg, #${menuId} li.selected svg {
              display: block;
            }
            #${menuId} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${menuId} .menu-items, #${menuId} .menu-items li {
              padding: 0;
            }
            #${menuId} .menu-item {
              display: flex;
            }
            #${menuId} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
          ])
        );
      }
      let selectedElement = selected.get(), elementList = selectedElement ? [selectedElement] : targets.get();
      if (elementList.length && (menu.style.position = getComputedStyle(elementList[0].element).position === "fixed" ? "fixed" : "absolute", menu.appendChild(
        createElement2(
          "ul",
          { class: "element-list" },
          elementList.map((target) => {
            let selectable = elementList.length > 1 && !!target.menu?.some(
              (group) => group.some(
                (item) => !item.selectors || item.selectors.some((s4) => target.selectors.includes(s4))
              )
            ), props = selectable ? {
              class: "selectable",
              onClick: __name(() => selected.set(target), "onClick"),
              onMouseEnter: __name(() => focused.set(target), "onMouseEnter"),
              onMouseLeave: __name(() => focused.set(void 0), "onMouseLeave")
            } : selectedElement ? { class: "selected", onClick: __name(() => selected.set(void 0), "onClick") } : {}, asButton = selectable || selectedElement;
            return createElement2("li", props, [
              createElement2(asButton ? "button" : "div", asButton ? { type: "button" } : {}, [
                selectedElement ? createIcon("chevronLeft") : null,
                createElement2("code", {}, [target.element.outerHTML]),
                selectable ? createIcon("chevronRight") : null
              ])
            ]);
          })
        )
      )), selected.get() || targets.get().length === 1) {
        let target = selected.get() || targets.get()[0], menuGroups = target.menu?.filter(
          (group) => group.some(
            (item) => !item.selectors || item.selectors.some((s4) => target.selectors.includes(s4))
          )
        );
        menuGroups?.length && menu.appendChild(
          createElement2(
            "ul",
            { class: "menu-list" },
            menuGroups.map(
              (menuItems) => createElement2("li", {}, [
                createElement2(
                  "ul",
                  { class: "menu-items" },
                  menuItems.map(
                    ({ id: id2, title, description, iconLeft, iconRight, clickEvent: event }) => {
                      let onClick = event && (() => channel.emit(event, id2, getEventDetails(target)));
                      return createElement2("li", {}, [
                        createElement2(
                          onClick ? "button" : "div",
                          onClick ? { class: "menu-item", type: "button", onClick } : { class: "menu-item" },
                          [
                            iconLeft ? createIcon(iconLeft) : null,
                            createElement2("div", { class: "menu-item-content" }, [
                              createElement2(description ? "strong" : "span", {}, [title]),
                              description && createElement2("span", {}, [description])
                            ]),
                            iconRight ? createIcon(iconRight) : null
                          ]
                        )
                      ]);
                    }
                  )
                )
              ])
            )
          )
        );
      }
      let coords = clickCoords.get();
      coords ? (Object.assign(menu.style, {
        display: "block",
        left: `${menu.style.position === "fixed" ? coords.x - window.scrollX : coords.x}px`,
        top: `${menu.style.position === "fixed" ? coords.y - window.scrollY : coords.y}px`
      }), showPopover(menu), requestAnimationFrame(() => keepInViewport(menu, coords, { topOffset: 15, centered: !0 }))) : (hidePopover(menu), Object.assign(menu.style, { display: "none" }));
    }, "renderMenu");
    targets.subscribe(renderMenu), selected.subscribe(renderMenu);
    let addHighlight = __name((highlight2) => {
      let info = normalizeOptions(highlight2);
      highlights.set((value2) => {
        let others = info.id ? value2.filter((h4) => h4.id !== info.id) : value2;
        return info.selectors?.length ? [...others, info] : others;
      });
    }, "addHighlight"), removeHighlight = __name((id2) => {
      id2 && highlights.set((value2) => value2.filter((h4) => h4.id !== id2));
    }, "removeHighlight"), resetState = __name(() => {
      highlights.set([]), elements.set(/* @__PURE__ */ new Map()), boxes.set([]), clickCoords.set(void 0), hoverCoords.set(void 0), targets.set([]), hovered.set([]), focused.set(void 0), selected.set(void 0);
    }, "resetState"), removeTimeout, scrollIntoView = __name((target, options) => {
      let id2 = "scrollIntoView-highlight";
      clearTimeout(removeTimeout), removeHighlight(id2);
      let element = document32.querySelector(target);
      if (!element) {
        console.warn(`Cannot scroll into view: ${target} not found`);
        return;
      }
      element.scrollIntoView({ behavior: "smooth", block: "center", ...options });
      let keyframeName = `kf-${Math.random().toString(36).substring(2, 15)}`;
      highlights.set((value2) => [
        ...value2,
        {
          id: id2,
          priority: 1e3,
          selectors: [target],
          styles: {
            outline: "2px solid #1EA7FD",
            outlineOffset: "-1px",
            animation: `${keyframeName} 3s linear forwards`
          },
          keyframes: `@keyframes ${keyframeName} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
        }
      ]), removeTimeout = setTimeout(() => removeHighlight(id2), 3500);
    }, "scrollIntoView"), onMouseMove = __name((event) => {
      requestAnimationFrame(() => hoverCoords.set({ x: event.pageX, y: event.pageY }));
    }, "onMouseMove");
    document32.body.addEventListener("mousemove", onMouseMove), channel.on(HIGHLIGHT, addHighlight), channel.on(REMOVE_HIGHLIGHT, removeHighlight), channel.on(RESET_HIGHLIGHT, resetState), channel.on(SCROLL_INTO_VIEW, scrollIntoView), channel.on(STORY_RENDER_PHASE_CHANGED, ({ newPhase }) => {
      newPhase === "loading" && resetState();
    });
  }, "useHighlights");
  globalThis?.FEATURES?.highlight && addons2?.ready && addons2.ready().then(useHighlights);
  var preview_default4 = __name(() => ({}), "default");
  function getDocumentWidthAndHeight() {
    let container = scope.document.documentElement, height = Math.max(container.scrollHeight, container.offsetHeight);
    return { width: Math.max(container.scrollWidth, container.offsetWidth), height };
  }
  __name(getDocumentWidthAndHeight, "getDocumentWidthAndHeight");
  function createCanvas() {
    let canvas = scope.document.createElement("canvas");
    canvas.id = "storybook-addon-measure";
    let context = canvas.getContext("2d");
    invariant(context != null);
    let { width, height } = getDocumentWidthAndHeight();
    return setCanvasWidthAndHeight(canvas, context, { width, height }), canvas.style.position = "absolute", canvas.style.left = "0", canvas.style.top = "0", canvas.style.zIndex = "2147483647", canvas.style.pointerEvents = "none", scope.document.body.appendChild(canvas), { canvas, context, width, height };
  }
  __name(createCanvas, "createCanvas");
  function setCanvasWidthAndHeight(canvas, context, { width, height }) {
    canvas.style.width = `${width}px`, canvas.style.height = `${height}px`;
    let scale = scope.window.devicePixelRatio;
    canvas.width = Math.floor(width * scale), canvas.height = Math.floor(height * scale), context.scale(scale, scale);
  }
  __name(setCanvasWidthAndHeight, "setCanvasWidthAndHeight");
  var state2 = {};
  function init() {
    state2.canvas || (state2 = createCanvas());
  }
  __name(init, "init");
  function clear() {
    state2.context && state2.context.clearRect(0, 0, state2.width ?? 0, state2.height ?? 0);
  }
  __name(clear, "clear");
  function draw(callback) {
    clear(), callback(state2.context);
  }
  __name(draw, "draw");
  function rescale() {
    invariant(state2.canvas, "Canvas should exist in the state."), invariant(state2.context, "Context should exist in the state."), setCanvasWidthAndHeight(state2.canvas, state2.context, { width: 0, height: 0 });
    let { width, height } = getDocumentWidthAndHeight();
    setCanvasWidthAndHeight(state2.canvas, state2.context, { width, height }), state2.width = width, state2.height = height;
  }
  __name(rescale, "rescale");
  function destroy() {
    state2.canvas && (clear(), state2.canvas.parentNode?.removeChild(state2.canvas), state2 = {});
  }
  __name(destroy, "destroy");
  var colors = {
    margin: "#f6b26b",
    border: "#ffe599",
    padding: "#93c47d",
    content: "#6fa8dc",
    text: "#232020"
  }, labelPadding = 6;
  function roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: r2 }) {
    x3 = x3 - w3 / 2, y3 = y3 - h4 / 2, w3 < 2 * r2 && (r2 = w3 / 2), h4 < 2 * r2 && (r2 = h4 / 2), context.beginPath(), context.moveTo(x3 + r2, y3), context.arcTo(x3 + w3, y3, x3 + w3, y3 + h4, r2), context.arcTo(x3 + w3, y3 + h4, x3, y3 + h4, r2), context.arcTo(x3, y3 + h4, x3, y3, r2), context.arcTo(x3, y3, x3 + w3, y3, r2), context.closePath();
  }
  __name(roundedRect, "roundedRect");
  function positionCoordinate(position, { padding, border, width, height, top, left }) {
    let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom, x3 = left + border.left + padding.left, y3 = top + border.top + padding.top;
    return position === "top" ? x3 += contentWidth / 2 : position === "right" ? (x3 += contentWidth, y3 += contentHeight / 2) : position === "bottom" ? (x3 += contentWidth / 2, y3 += contentHeight) : position === "left" ? y3 += contentHeight / 2 : position === "center" && (x3 += contentWidth / 2, y3 += contentHeight / 2), { x: x3, y: y3 };
  }
  __name(positionCoordinate, "positionCoordinate");
  function offset(type, position, { margin, border, padding }, labelPaddingSize, external) {
    let shift = __name((dir) => 0, "shift"), offsetX = 0, offsetY = 0, locationMultiplier = external ? 1 : 0.5, labelPaddingShift = external ? labelPaddingSize * 2 : 0;
    return type === "padding" ? shift = __name((dir) => padding[dir] * locationMultiplier + labelPaddingShift, "shift") : type === "border" ? shift = __name((dir) => padding[dir] + border[dir] * locationMultiplier + labelPaddingShift, "shift") : type === "margin" && (shift = __name((dir) => padding[dir] + border[dir] + margin[dir] * locationMultiplier + labelPaddingShift, "shift")), position === "top" ? offsetY = -shift("top") : position === "right" ? offsetX = shift("right") : position === "bottom" ? offsetY = shift("bottom") : position === "left" && (offsetX = -shift("left")), { offsetX, offsetY };
  }
  __name(offset, "offset");
  function collide(a3, b3) {
    return Math.abs(a3.x - b3.x) < Math.abs(a3.w + b3.w) / 2 && Math.abs(a3.y - b3.y) < Math.abs(a3.h + b3.h) / 2;
  }
  __name(collide, "collide");
  function overlapAdjustment(position, currentRect, prevRect) {
    return position === "top" ? currentRect.y = prevRect.y - prevRect.h - labelPadding : position === "right" ? currentRect.x = prevRect.x + prevRect.w / 2 + labelPadding + currentRect.w / 2 : position === "bottom" ? currentRect.y = prevRect.y + prevRect.h + labelPadding : position === "left" && (currentRect.x = prevRect.x - prevRect.w / 2 - labelPadding - currentRect.w / 2), { x: currentRect.x, y: currentRect.y };
  }
  __name(overlapAdjustment, "overlapAdjustment");
  function textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text) {
    return roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x3, y3), roundedRect(context, { x: x3, y: y3, w: w3, h: h4, r: 3 }), context.fillStyle = `${colors[type]}dd`, context.fill(), context.strokeStyle = colors[type], context.stroke(), context.fillStyle = colors.text, context.fillText(text, x3, y3), { x: x3, y: y3, w: w3, h: h4 };
  }
  __name(textWithRect, "textWithRect");
  function configureText(context, text) {
    context.font = "600 12px monospace", context.textBaseline = "middle", context.textAlign = "center";
    let metrics = context.measureText(text), actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent, w3 = metrics.width + labelPadding * 2, h4 = actualHeight + labelPadding * 2;
    return { w: w3, h: h4 };
  }
  __name(configureText, "configureText");
  function drawLabel(context, measurements, { type, position = "center", text }, prevRect, external = !1) {
    let { x: x3, y: y3 } = positionCoordinate(position, measurements), { offsetX, offsetY } = offset(type, position, measurements, labelPadding + 1, external);
    x3 += offsetX, y3 += offsetY;
    let { w: w3, h: h4 } = configureText(context, text);
    if (prevRect && collide({ x: x3, y: y3, w: w3, h: h4 }, prevRect)) {
      let adjusted = overlapAdjustment(position, { x: x3, y: y3, w: w3, h: h4 }, prevRect);
      x3 = adjusted.x, y3 = adjusted.y;
    }
    return textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text);
  }
  __name(drawLabel, "drawLabel");
  function floatingOffset(alignment, { w: w3, h: h4 }) {
    let deltaW = w3 * 0.5 + labelPadding, deltaH = h4 * 0.5 + labelPadding;
    return {
      offsetX: (alignment.x === "left" ? -1 : 1) * deltaW,
      offsetY: (alignment.y === "top" ? -1 : 1) * deltaH
    };
  }
  __name(floatingOffset, "floatingOffset");
  function drawFloatingLabel(context, measurements, { type, text }) {
    let { floatingAlignment: floatingAlignment2, extremities } = measurements, x3 = extremities[floatingAlignment2.x], y3 = extremities[floatingAlignment2.y], { w: w3, h: h4 } = configureText(context, text), { offsetX, offsetY } = floatingOffset(floatingAlignment2, {
      w: w3,
      h: h4
    });
    return x3 += offsetX, y3 += offsetY, textWithRect(context, type, { x: x3, y: y3, w: w3, h: h4 }, text);
  }
  __name(drawFloatingLabel, "drawFloatingLabel");
  function drawStack(context, measurements, stack, external) {
    let rects = [];
    stack.forEach((l2, idx) => {
      let rect = external && l2.position === "center" ? drawFloatingLabel(context, measurements, l2) : drawLabel(context, measurements, l2, rects[idx - 1], external);
      rects[idx] = rect;
    });
  }
  __name(drawStack, "drawStack");
  function labelStacks(context, measurements, labels, externalLabels) {
    let stacks = labels.reduce((acc, l2) => (Object.prototype.hasOwnProperty.call(acc, l2.position) || (acc[l2.position] = []), acc[l2.position]?.push(l2), acc), {});
    stacks.top && drawStack(context, measurements, stacks.top, externalLabels), stacks.right && drawStack(context, measurements, stacks.right, externalLabels), stacks.bottom && drawStack(context, measurements, stacks.bottom, externalLabels), stacks.left && drawStack(context, measurements, stacks.left, externalLabels), stacks.center && drawStack(context, measurements, stacks.center, externalLabels);
  }
  __name(labelStacks, "labelStacks");
  var colors2 = {
    margin: "#f6b26ba8",
    border: "#ffe599a8",
    padding: "#93c47d8c",
    content: "#6fa8dca8"
  }, SMALL_NODE_SIZE = 30;
  function pxToNumber(px) {
    return parseInt(px.replace("px", ""), 10);
  }
  __name(pxToNumber, "pxToNumber");
  function round(value2) {
    return Number.isInteger(value2) ? value2 : value2.toFixed(2);
  }
  __name(round, "round");
  function filterZeroValues(labels) {
    return labels.filter((l2) => l2.text !== 0 && l2.text !== "0");
  }
  __name(filterZeroValues, "filterZeroValues");
  function floatingAlignment(extremities) {
    let windowExtremities = {
      top: scope.window.scrollY,
      bottom: scope.window.scrollY + scope.window.innerHeight,
      left: scope.window.scrollX,
      right: scope.window.scrollX + scope.window.innerWidth
    }, distances = {
      top: Math.abs(windowExtremities.top - extremities.top),
      bottom: Math.abs(windowExtremities.bottom - extremities.bottom),
      left: Math.abs(windowExtremities.left - extremities.left),
      right: Math.abs(windowExtremities.right - extremities.right)
    };
    return {
      x: distances.left > distances.right ? "left" : "right",
      y: distances.top > distances.bottom ? "top" : "bottom"
    };
  }
  __name(floatingAlignment, "floatingAlignment");
  function measureElement(element) {
    let style = scope.getComputedStyle(element), { top, left, right, bottom, width, height } = element.getBoundingClientRect(), {
      marginTop,
      marginBottom,
      marginLeft,
      marginRight,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight,
      borderBottomWidth,
      borderTopWidth,
      borderLeftWidth,
      borderRightWidth
    } = style;
    top = top + scope.window.scrollY, left = left + scope.window.scrollX, bottom = bottom + scope.window.scrollY, right = right + scope.window.scrollX;
    let margin = {
      top: pxToNumber(marginTop),
      bottom: pxToNumber(marginBottom),
      left: pxToNumber(marginLeft),
      right: pxToNumber(marginRight)
    }, padding = {
      top: pxToNumber(paddingTop),
      bottom: pxToNumber(paddingBottom),
      left: pxToNumber(paddingLeft),
      right: pxToNumber(paddingRight)
    }, border = {
      top: pxToNumber(borderTopWidth),
      bottom: pxToNumber(borderBottomWidth),
      left: pxToNumber(borderLeftWidth),
      right: pxToNumber(borderRightWidth)
    }, extremities = {
      top: top - margin.top,
      bottom: bottom + margin.bottom,
      left: left - margin.left,
      right: right + margin.right
    };
    return {
      margin,
      padding,
      border,
      top,
      left,
      bottom,
      right,
      width,
      height,
      extremities,
      floatingAlignment: floatingAlignment(extremities)
    };
  }
  __name(measureElement, "measureElement");
  function drawMargin(context, { margin, width, height, top, left, bottom, right }) {
    let marginHeight = height + margin.bottom + margin.top;
    context.fillStyle = colors2.margin, context.fillRect(left, top - margin.top, width, margin.top), context.fillRect(right, top - margin.top, margin.right, marginHeight), context.fillRect(left, bottom, width, margin.bottom), context.fillRect(left - margin.left, top - margin.top, margin.left, marginHeight);
    let marginLabels = [
      {
        type: "margin",
        text: round(margin.top),
        position: "top"
      },
      {
        type: "margin",
        text: round(margin.right),
        position: "right"
      },
      {
        type: "margin",
        text: round(margin.bottom),
        position: "bottom"
      },
      {
        type: "margin",
        text: round(margin.left),
        position: "left"
      }
    ];
    return filterZeroValues(marginLabels);
  }
  __name(drawMargin, "drawMargin");
  function drawPadding(context, { padding, border, width, height, top, left, bottom, right }) {
    let paddingWidth = width - border.left - border.right, paddingHeight = height - padding.top - padding.bottom - border.top - border.bottom;
    context.fillStyle = colors2.padding, context.fillRect(left + border.left, top + border.top, paddingWidth, padding.top), context.fillRect(
      right - padding.right - border.right,
      top + padding.top + border.top,
      padding.right,
      paddingHeight
    ), context.fillRect(
      left + border.left,
      bottom - padding.bottom - border.bottom,
      paddingWidth,
      padding.bottom
    ), context.fillRect(left + border.left, top + padding.top + border.top, padding.left, paddingHeight);
    let paddingLabels = [
      {
        type: "padding",
        text: padding.top,
        position: "top"
      },
      {
        type: "padding",
        text: padding.right,
        position: "right"
      },
      {
        type: "padding",
        text: padding.bottom,
        position: "bottom"
      },
      {
        type: "padding",
        text: padding.left,
        position: "left"
      }
    ];
    return filterZeroValues(paddingLabels);
  }
  __name(drawPadding, "drawPadding");
  function drawBorder(context, { border, width, height, top, left, bottom, right }) {
    let borderHeight = height - border.top - border.bottom;
    context.fillStyle = colors2.border, context.fillRect(left, top, width, border.top), context.fillRect(left, bottom - border.bottom, width, border.bottom), context.fillRect(left, top + border.top, border.left, borderHeight), context.fillRect(right - border.right, top + border.top, border.right, borderHeight);
    let borderLabels = [
      {
        type: "border",
        text: border.top,
        position: "top"
      },
      {
        type: "border",
        text: border.right,
        position: "right"
      },
      {
        type: "border",
        text: border.bottom,
        position: "bottom"
      },
      {
        type: "border",
        text: border.left,
        position: "left"
      }
    ];
    return filterZeroValues(borderLabels);
  }
  __name(drawBorder, "drawBorder");
  function drawContent(context, { padding, border, width, height, top, left }) {
    let contentWidth = width - border.left - border.right - padding.left - padding.right, contentHeight = height - padding.top - padding.bottom - border.top - border.bottom;
    return context.fillStyle = colors2.content, context.fillRect(
      left + border.left + padding.left,
      top + border.top + padding.top,
      contentWidth,
      contentHeight
    ), [
      {
        type: "content",
        position: "center",
        text: `${round(contentWidth)} x ${round(contentHeight)}`
      }
    ];
  }
  __name(drawContent, "drawContent");
  function drawBoxModel(element) {
    return (context) => {
      if (element && context) {
        let measurements = measureElement(element), marginLabels = drawMargin(context, measurements), paddingLabels = drawPadding(context, measurements), borderLabels = drawBorder(context, measurements), contentLabels = drawContent(context, measurements), externalLabels = measurements.width <= SMALL_NODE_SIZE * 3 || measurements.height <= SMALL_NODE_SIZE;
        labelStacks(
          context,
          measurements,
          [...contentLabels, ...paddingLabels, ...borderLabels, ...marginLabels],
          externalLabels
        );
      }
    };
  }
  __name(drawBoxModel, "drawBoxModel");
  function drawSelectedElement(element) {
    draw(drawBoxModel(element));
  }
  __name(drawSelectedElement, "drawSelectedElement");
  var deepElementFromPoint = __name((x3, y3) => {
    let element = scope.document.elementFromPoint(x3, y3), crawlShadows = __name((node) => {
      if (node && node.shadowRoot) {
        let nestedElement = node.shadowRoot.elementFromPoint(x3, y3);
        return node.isEqualNode(nestedElement) ? node : nestedElement.shadowRoot ? crawlShadows(nestedElement) : nestedElement;
      }
      return node;
    }, "crawlShadows");
    return crawlShadows(element) || element;
  }, "deepElementFromPoint"), nodeAtPointerRef, pointer = { x: 0, y: 0 };
  function findAndDrawElement(x3, y3) {
    nodeAtPointerRef = deepElementFromPoint(x3, y3), drawSelectedElement(nodeAtPointerRef);
  }
  __name(findAndDrawElement, "findAndDrawElement");
  var withMeasure = __name((StoryFn, context) => {
    let { measureEnabled } = context.globals || {};
    return useEffect2(() => {
      if (typeof globalThis.document > "u")
        return;
      let onPointerMove = __name((event) => {
        window.requestAnimationFrame(() => {
          event.stopPropagation(), pointer.x = event.clientX, pointer.y = event.clientY;
        });
      }, "onPointerMove");
      return globalThis.document.addEventListener("pointermove", onPointerMove), () => {
        globalThis.document.removeEventListener("pointermove", onPointerMove);
      };
    }, []), useEffect2(() => {
      let onPointerOver = __name((event) => {
        window.requestAnimationFrame(() => {
          event.stopPropagation(), findAndDrawElement(event.clientX, event.clientY);
        });
      }, "onPointerOver"), onResize = __name(() => {
        window.requestAnimationFrame(() => {
          rescale();
        });
      }, "onResize");
      return context.viewMode === "story" && measureEnabled && (globalThis.document.addEventListener("pointerover", onPointerOver), init(), globalThis.window.addEventListener("resize", onResize), findAndDrawElement(pointer.x, pointer.y)), () => {
        globalThis.window.removeEventListener("resize", onResize), destroy();
      };
    }, [measureEnabled, context.viewMode]), StoryFn();
  }, "withMeasure"), decorators2 = globalThis.FEATURES?.measure ? [withMeasure] : [], initialGlobals2 = {
    [PARAM_KEY2]: !1
  }, preview_default5 = __name(() => ({
    decorators: decorators2,
    initialGlobals: initialGlobals2
  }), "default"), clearStyles2 = __name((selector) => {
    (Array.isArray(selector) ? selector : [selector]).forEach(clearStyle2);
  }, "clearStyles"), clearStyle2 = __name((input) => {
    let selector = typeof input == "string" ? input : input.join(""), element = scope.document.getElementById(selector);
    element && element.parentElement && element.parentElement.removeChild(element);
  }, "clearStyle"), addOutlineStyles = __name((selector, css2) => {
    let existingStyle = scope.document.getElementById(selector);
    if (existingStyle)
      existingStyle.innerHTML !== css2 && (existingStyle.innerHTML = css2);
    else {
      let style = scope.document.createElement("style");
      style.setAttribute("id", selector), style.innerHTML = css2, scope.document.head.appendChild(style);
    }
  }, "addOutlineStyles");
  function outlineCSS(selector) {
    return dedent`
    ${selector} body {
      outline: 1px solid #2980b9 !important;
    }

    ${selector} article {
      outline: 1px solid #3498db !important;
    }

    ${selector} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${selector} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${selector} section {
      outline: 1px solid #66b8da !important;
    }

    ${selector} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${selector} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${selector} h1 {
      outline: 1px solid #162544 !important;
    }

    ${selector} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${selector} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${selector} h4 {
      outline: 1px solid #449baf !important;
    }

    ${selector} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${selector} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${selector} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${selector} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${selector} div {
      outline: 1px solid #036cdb !important;
    }

    ${selector} p {
      outline: 1px solid #ac050b !important;
    }

    ${selector} hr {
      outline: 1px solid #ff063f !important;
    }

    ${selector} pre {
      outline: 1px solid #850440 !important;
    }

    ${selector} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${selector} ol {
      outline: 1px solid #ff050c !important;
    }

    ${selector} ul {
      outline: 1px solid #d90416 !important;
    }

    ${selector} li {
      outline: 1px solid #d90416 !important;
    }

    ${selector} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${selector} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${selector} dd {
      outline: 1px solid #e80174 !important;
    }

    ${selector} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${selector} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${selector} table {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} thead {
      outline: 1px solid #98daca !important;
    }

    ${selector} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${selector} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${selector} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${selector} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${selector} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${selector} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${selector} button {
      outline: 1px solid #da8301 !important;
    }

    ${selector} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${selector} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${selector} form {
      outline: 1px solid #d23600 !important;
    }

    ${selector} input {
      outline: 1px solid #fca600 !important;
    }

    ${selector} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${selector} label {
      outline: 1px solid #ee8900 !important;
    }

    ${selector} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${selector} meter {
      outline: 1px solid #e8630c !important;
    }

    ${selector} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${selector} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${selector} output {
      outline: 1px solid #ff9619 !important;
    }

    ${selector} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${selector} select {
      outline: 1px solid #e26e0f !important;
    }

    ${selector} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${selector} details {
      outline: 1px solid #33848f !important;
    }

    ${selector} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${selector} command {
      outline: 1px solid #438da1 !important;
    }

    ${selector} menu {
      outline: 1px solid #449da6 !important;
    }

    ${selector} del {
      outline: 1px solid #bf0000 !important;
    }

    ${selector} ins {
      outline: 1px solid #400000 !important;
    }

    ${selector} img {
      outline: 1px solid #22746b !important;
    }

    ${selector} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${selector} embed {
      outline: 1px solid #98daca !important;
    }

    ${selector} object {
      outline: 1px solid #00cc99 !important;
    }

    ${selector} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${selector} video {
      outline: 1px solid #6ee866 !important;
    }

    ${selector} audio {
      outline: 1px solid #027353 !important;
    }

    ${selector} source {
      outline: 1px solid #012426 !important;
    }

    ${selector} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${selector} track {
      outline: 1px solid #59a600 !important;
    }

    ${selector} map {
      outline: 1px solid #7be500 !important;
    }

    ${selector} area {
      outline: 1px solid #305900 !important;
    }

    ${selector} a {
      outline: 1px solid #ff62ab !important;
    }

    ${selector} em {
      outline: 1px solid #800b41 !important;
    }

    ${selector} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${selector} i {
      outline: 1px solid #803156 !important;
    }

    ${selector} b {
      outline: 1px solid #cc1169 !important;
    }

    ${selector} u {
      outline: 1px solid #ff0430 !important;
    }

    ${selector} s {
      outline: 1px solid #f805e3 !important;
    }

    ${selector} small {
      outline: 1px solid #d107b2 !important;
    }

    ${selector} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${selector} q {
      outline: 1px solid #240018 !important;
    }

    ${selector} cite {
      outline: 1px solid #64003c !important;
    }

    ${selector} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${selector} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${selector} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${selector} time {
      outline: 1px solid #d6606d !important;
    }

    ${selector} code {
      outline: 1px solid #e04251 !important;
    }

    ${selector} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${selector} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${selector} var {
      outline: 1px solid #d90047 !important;
    }

    ${selector} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${selector} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${selector} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${selector} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${selector} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${selector} rp {
      outline: 1px solid #803e49 !important;
    }

    ${selector} span {
      outline: 1px solid #cc2643 !important;
    }

    ${selector} br {
      outline: 1px solid #db687d !important;
    }

    ${selector} wbr {
      outline: 1px solid #db175b !important;
    }`;
  }
  __name(outlineCSS, "outlineCSS");
  var withOutline = __name((StoryFn, context) => {
    let globals = context.globals || {}, isActive = [!0, "true"].includes(globals[PARAM_KEY3]), isInDocs = context.viewMode === "docs", outlineStyles = useMemo2(() => outlineCSS(isInDocs ? '[data-story-block="true"]' : ".sb-show-main"), [context]);
    return useEffect2(() => {
      let selectorId = isInDocs ? `addon-outline-docs-${context.id}` : "addon-outline";
      return isActive ? addOutlineStyles(selectorId, outlineStyles) : clearStyles2(selectorId), () => {
        clearStyles2(selectorId);
      };
    }, [isActive, outlineStyles, context]), StoryFn();
  }, "withOutline"), decorators3 = globalThis.FEATURES?.outline ? [withOutline] : [], initialGlobals3 = {
    [PARAM_KEY3]: !1
  }, preview_default6 = __name(() => ({ decorators: decorators3, initialGlobals: initialGlobals3 }), "default"), resetAllMocksLoader = __name(({ parameters: parameters2 }) => {
    parameters2?.test?.mockReset === !0 ? resetAllMocks() : parameters2?.test?.clearMocks === !0 ? clearAllMocks() : parameters2?.test?.restoreMocks !== !1 && restoreAllMocks();
  }, "resetAllMocksLoader"), traverseArgs = __name((value2, depth = 0, key) => {
    if (depth > 5 || value2 == null)
      return value2;
    if (isMockFunction(value2))
      return key && value2.mockName(key), value2;
    if (typeof value2 == "function" && "isAction" in value2 && value2.isAction && !("implicit" in value2 && value2.implicit)) {
      let mock = fn(value2);
      return key && mock.mockName(key), mock;
    }
    if (Array.isArray(value2)) {
      depth++;
      for (let i3 = 0; i3 < value2.length; i3++)
        Object.getOwnPropertyDescriptor(value2, i3)?.writable && (value2[i3] = traverseArgs(value2[i3], depth));
      return value2;
    }
    if (typeof value2 == "object" && value2.constructor === Object) {
      depth++;
      for (let [k3, v3] of Object.entries(value2))
        Object.getOwnPropertyDescriptor(value2, k3)?.writable && (value2[k3] = traverseArgs(v3, depth, k3));
      return value2;
    }
    return value2;
  }, "traverseArgs"), nameSpiesAndWrapActionsInSpies = __name(({ initialArgs }) => {
    traverseArgs(initialArgs);
  }, "nameSpiesAndWrapActionsInSpies"), patchedFocus = !1, enhanceContext = __name(async (context) => {
    globalThis.HTMLElement && context.canvasElement instanceof globalThis.HTMLElement && (context.canvas = within(context.canvasElement));
    let clipboard = globalThis.window?.navigator?.clipboard;
    if (clipboard && (context.userEvent = instrument(
      { userEvent: uninstrumentedUserEvent.setup() },
      {
        intercept: !0,
        getKeys: __name((obj) => Object.keys(obj).filter((key) => key !== "eventWrapper"), "getKeys")
      }
    ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
      get: __name(() => clipboard, "get"),
      configurable: !0
    }), !patchedFocus)) {
      let originalFocus = HTMLElement.prototype.focus, currentFocus = HTMLElement.prototype.focus, focusingElements = /* @__PURE__ */ new Set();
      Object.defineProperties(HTMLElement.prototype, {
        focus: {
          configurable: !0,
          set: __name((newFocus) => {
            currentFocus = newFocus;
          }, "set"),
          get() {
            return focusingElements.has(this) ? originalFocus : (focusingElements.add(this), setTimeout(() => focusingElements.delete(this), 0), currentFocus);
          }
        }
      }), patchedFocus = !0;
    }
  }, "enhanceContext"), preview_default7 = __name(() => ({
    loaders: [resetAllMocksLoader, nameSpiesAndWrapActionsInSpies, enhanceContext]
  }), "default"), initialGlobals4 = {
    [PARAM_KEY5]: { value: void 0, isRotated: !1 }
  }, preview_default8 = __name(() => ({
    initialGlobals: initialGlobals4
  }), "default");
  function getCoreAnnotations() {
    return [
      // @ts-expect-error CJS fallback
      (preview_default5.default ?? preview_default5)(),
      // @ts-expect-error CJS fallback
      (preview_default2.default ?? preview_default2)(),
      // @ts-expect-error CJS fallback
      (preview_default4.default ?? preview_default4)(),
      // @ts-expect-error CJS fallback
      (preview_default6.default ?? preview_default6)(),
      // @ts-expect-error CJS fallback
      (preview_default8.default ?? preview_default8)(),
      // @ts-expect-error CJS fallback
      (preview_default.default ?? preview_default)(),
      // @ts-expect-error CJS fallback
      (preview_default3.default ?? preview_default3)(),
      // @ts-expect-error CJS fallback
      (preview_default7.default ?? preview_default7)()
    ];
  }
  __name(getCoreAnnotations, "getCoreAnnotations");
  function definePreview(input) {
    let composed, preview = {
      _tag: "Preview",
      input,
      get composed() {
        if (composed)
          return composed;
        let { addons: addons22, ...rest } = input;
        return composed = normalizeProjectAnnotations(
          composeConfigs([...getCoreAnnotations(), ...addons22 ?? [], rest])
        ), composed;
      },
      meta(meta) {
        return defineMeta(meta, this);
      }
    };
    return globalThis.globalProjectAnnotations = preview.composed, preview;
  }
  __name(definePreview, "definePreview");
  function definePreviewAddon9(preview) {
    return preview;
  }
  __name(definePreviewAddon9, "definePreviewAddon");
  function isPreview(input) {
    return input != null && typeof input == "object" && "_tag" in input && input?._tag === "Preview";
  }
  __name(isPreview, "isPreview");
  function isMeta(input) {
    return input != null && typeof input == "object" && "_tag" in input && input?._tag === "Meta";
  }
  __name(isMeta, "isMeta");
  function defineMeta(input, preview) {
    return {
      _tag: "Meta",
      input,
      preview,
      // @ts-expect-error hard
      story(story = {}) {
        return defineStory(typeof story == "function" ? { render: story } : story, this);
      }
    };
  }
  __name(defineMeta, "defineMeta");
  function isStory(input) {
    return input != null && typeof input == "object" && "_tag" in input && input?._tag === "Story";
  }
  __name(isStory, "isStory");
  function defineStory(input, meta) {
    let composed, compose = __name(() => (composed || (composed = composeStory(
      input,
      meta.input,
      void 0,
      meta.preview.composed
    )), composed), "compose"), __children = [];
    return {
      _tag: "Story",
      input,
      meta,
      // @ts-expect-error this is a private property used only once in renderers/react/src/preview
      __compose: compose,
      __children,
      get composed() {
        let composed2 = compose(), { args, argTypes, parameters: parameters2, id: id2, tags, globals, storyName: name } = composed2;
        return { args, argTypes, parameters: parameters2, id: id2, tags, name, globals };
      },
      get play() {
        return input.play ?? meta.input?.play ?? (async () => {
        });
      },
      async run(context) {
        await compose().run(context);
      },
      test(name, overridesOrTestFn, testFn) {
        let annotations = typeof overridesOrTestFn != "function" ? overridesOrTestFn : {}, testFunction = typeof overridesOrTestFn != "function" ? testFn : overridesOrTestFn, play = mountDestructured(this.play) || mountDestructured(testFunction) ? async ({ context }) => {
          await this.play?.(context), await testFunction(context);
        } : async (context) => {
          await this.play?.(context), await testFunction(context);
        }, test2 = this.extend({
          ...annotations,
          name,
          tags: ["test-fn", "!autodocs", ...annotations.tags ?? []],
          play
        });
        return __children.push(test2), test2;
      },
      extend(input2) {
        return defineStory(
          {
            ...this.input,
            ...input2,
            args: { ...this.input.args || {}, ...input2.args },
            argTypes: combineParameters2(this.input.argTypes, input2.argTypes),
            afterEach: [
              ...normalizeArrays(this.input?.afterEach ?? []),
              ...normalizeArrays(input2.afterEach ?? [])
            ],
            beforeEach: [
              ...normalizeArrays(this.input?.beforeEach ?? []),
              ...normalizeArrays(input2.beforeEach ?? [])
            ],
            decorators: [
              ...normalizeArrays(this.input?.decorators ?? []),
              ...normalizeArrays(input2.decorators ?? [])
            ],
            globals: { ...this.input.globals, ...input2.globals },
            loaders: [
              ...normalizeArrays(this.input?.loaders ?? []),
              ...normalizeArrays(input2.loaders ?? [])
            ],
            parameters: combineParameters2(this.input.parameters, input2.parameters),
            tags: combineTags2(...this.input.tags ?? [], ...input2.tags ?? [])
          },
          this.meta
        );
      }
    };
  }
  __name(defineStory, "defineStory");
  function getStoryChildren(story) {
    return "__children" in story ? story.__children : [];
  }
  __name(getStoryChildren, "getStoryChildren");
  var sanitize = __name((string) => string.toLowerCase().replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), "sanitize"), sanitizeSafe = __name((string, part) => {
    let sanitized = sanitize(string);
    if (sanitized === "")
      throw new Error(`Invalid ${part} '${string}', must include alphanumeric characters`);
    return sanitized;
  }, "sanitizeSafe"), toId = __name((kind, name) => `${sanitizeSafe(kind, "kind")}${name ? `--${sanitizeSafe(name, "name")}` : ""}`, "toId"), toTestId = __name((parentId, testName2) => `${parentId}:${sanitizeSafe(testName2, "test")}`, "toTestId"), storyNameFromExport = __name((key) => toStartCaseStr(key), "storyNameFromExport");
  function matches2(storyKey, arrayOrRegex) {
    return Array.isArray(arrayOrRegex) ? arrayOrRegex.includes(storyKey) : storyKey.match(arrayOrRegex);
  }
  __name(matches2, "matches");
  function isExportStory(key, { includeStories, excludeStories }) {
    return (
      // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
      key !== "__esModule" && (!includeStories || matches2(key, includeStories)) && (!excludeStories || !matches2(key, excludeStories))
    );
  }
  __name(isExportStory, "isExportStory");
  var parseKind = __name((kind, { rootSeparator, groupSeparator }) => {
    let [root, remainder] = kind.split(rootSeparator, 2), groups = (remainder || kind).split(groupSeparator).filter((i3) => !!i3);
    return {
      root: remainder ? root : null,
      groups
    };
  }, "parseKind"), combineTags2 = __name((...tags) => {
    let result = tags.reduce((acc, tag) => (tag.startsWith("!") ? acc.delete(tag.slice(1)) : acc.add(tag), acc), /* @__PURE__ */ new Set());
    return Array.from(result);
  }, "combineTags");

  // node_modules/.pnpm/storybook@10.0.6_@testing-library+dom@10.4.1_prettier@3.6.2_react-dom@19.2.0_react@19.2_edaef623135231eb2e7e65c5d41e99de/node_modules/storybook/dist/core-server/presets/common-manager.js
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_theming();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_theming();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_react();
  init_theming();
  init_react();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_theming();
  init_react();
  init_components();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_react();
  init_react();
  init_components();
  init_icons();
  init_theming();
  init_react();
  init_components();
  init_icons();
  init_theming();
  var Wrapper2 = styled.div(withReset, ({ theme: theme3 }) => ({
    backgroundColor: theme3.base === "light" ? "rgba(0,0,0,.01)" : "rgba(255,255,255,.01)",
    borderRadius: theme3.appBorderRadius,
    border: `1px dashed ${theme3.appBorderColor}`,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: 20,
    margin: "25px 0 40px",
    color: curriedTransparentize$1(0.3, theme3.color.defaultText),
    fontSize: theme3.typography.size.s2
  })), EmptyBlock = __name((props) => react_default.createElement(Wrapper2, { ...props, className: "docblock-emptyblock sb-unstyled" }), "EmptyBlock"), StyledSyntaxHighlighter = styled(
    SyntaxHighlighter
  )(({ theme: theme3 }) => ({
    // DocBlocks-specific styling and overrides
    fontSize: `${theme3.typography.size.s2 - 1}px`,
    lineHeight: "19px",
    margin: "25px 0 40px",
    borderRadius: theme3.appBorderRadius,
    boxShadow: theme3.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0",
    "pre.prismjs": {
      padding: 20,
      background: "inherit"
    }
  })), SourceSkeletonWrapper = styled.div(({ theme: theme3 }) => ({
    background: theme3.background.content,
    borderRadius: theme3.appBorderRadius,
    border: `1px solid ${theme3.appBorderColor}`,
    boxShadow: theme3.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0",
    margin: "25px 0 40px",
    padding: "20px 20px 20px 22px"
  })), SourceSkeletonPlaceholder = styled.div(({ theme: theme3 }) => ({
    animation: `${theme3.animation.glow} 1.5s ease-in-out infinite`,
    background: theme3.appBorderColor,
    height: 17,
    marginTop: 1,
    width: "60%",
    [`&:first-child${ignoreSsrWarning}`]: {
      margin: 0
    }
  })), SourceSkeleton = __name(() => react_default.createElement(SourceSkeletonWrapper, null, react_default.createElement(SourceSkeletonPlaceholder, null), react_default.createElement(SourceSkeletonPlaceholder, { style: { width: "80%" } }), react_default.createElement(SourceSkeletonPlaceholder, { style: { width: "30%" } }), react_default.createElement(SourceSkeletonPlaceholder, { style: { width: "80%" } })), "SourceSkeleton"), Source = __name(({
    isLoading,
    error,
    language,
    code,
    dark,
    format: format3 = !0,
    ...rest
  }) => {
    let { typography: typography4 } = useTheme();
    if (isLoading)
      return react_default.createElement(SourceSkeleton, null);
    if (error)
      return react_default.createElement(EmptyBlock, null, error);
    let syntaxHighlighter = react_default.createElement(
      StyledSyntaxHighlighter,
      {
        bordered: !0,
        copyable: !0,
        format: format3,
        language: language ?? "jsx",
        className: "docblock-source sb-unstyled",
        ...rest
      },
      code
    );
    if (typeof dark > "u")
      return syntaxHighlighter;
    let overrideTheme = dark ? themes.dark : themes.light;
    return react_default.createElement(
      ThemeProvider,
      {
        theme: convert({
          ...overrideTheme,
          fontCode: typography4.fonts.mono,
          fontBase: typography4.fonts.base
        })
      },
      syntaxHighlighter
    );
  }, "Source"), toGlobalSelector = __name((element) => `& :where(${element}:not(.sb-anchor, .sb-unstyled, .sb-unstyled ${element}))`, "toGlobalSelector"), breakpoint = 600, Title = styled.h1(withReset, ({ theme: theme3 }) => ({
    color: theme3.color.defaultText,
    fontSize: theme3.typography.size.m3,
    fontWeight: theme3.typography.weight.bold,
    lineHeight: "32px",
    [`@media (min-width: ${breakpoint}px)`]: {
      fontSize: theme3.typography.size.l1,
      lineHeight: "36px",
      marginBottom: "16px"
    }
  })), Subtitle = styled.h2(withReset, ({ theme: theme3 }) => ({
    fontWeight: theme3.typography.weight.regular,
    fontSize: theme3.typography.size.s3,
    lineHeight: "20px",
    borderBottom: "none",
    marginBottom: 15,
    [`@media (min-width: ${breakpoint}px)`]: {
      fontSize: theme3.typography.size.m1,
      lineHeight: "28px",
      marginBottom: 24
    },
    color: curriedTransparentize$1(0.25, theme3.color.defaultText)
  })), DocsContent = styled.div(({ theme: theme3 }) => {
    let reset = {
      fontFamily: theme3.typography.fonts.base,
      fontSize: theme3.typography.size.s3,
      margin: 0,
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
      WebkitOverflowScrolling: "touch"
    }, headers = {
      margin: "20px 0 8px",
      padding: 0,
      cursor: "text",
      position: "relative",
      color: theme3.color.defaultText,
      "&:first-of-type": {
        marginTop: 0,
        paddingTop: 0
      },
      "&:hover a.anchor": {
        textDecoration: "none"
      },
      "& code": {
        fontSize: "inherit"
      }
    }, code = {
      lineHeight: 1,
      margin: "0 2px",
      padding: "3px 5px",
      whiteSpace: "nowrap",
      borderRadius: 3,
      fontSize: theme3.typography.size.s2 - 1,
      border: theme3.base === "light" ? `1px solid ${theme3.color.mediumlight}` : `1px solid ${theme3.color.darker}`,
      color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
      backgroundColor: theme3.base === "light" ? theme3.color.lighter : theme3.color.border
    };
    return {
      maxWidth: 1e3,
      width: "100%",
      minWidth: 0,
      [toGlobalSelector("a")]: {
        ...reset,
        fontSize: "inherit",
        lineHeight: "24px",
        color: theme3.color.secondary,
        textDecoration: "none",
        "&.absent": {
          color: "#cc0000"
        },
        "&.anchor": {
          display: "block",
          paddingLeft: 30,
          marginLeft: -30,
          cursor: "pointer",
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0
        }
      },
      [toGlobalSelector("blockquote")]: {
        ...reset,
        margin: "16px 0",
        borderLeft: `4px solid ${theme3.color.medium}`,
        padding: "0 15px",
        color: theme3.color.dark,
        "& > :first-of-type": {
          marginTop: 0
        },
        "& > :last-child": {
          marginBottom: 0
        }
      },
      [toGlobalSelector("div")]: reset,
      [toGlobalSelector("dl")]: {
        ...reset,
        margin: "16px 0",
        padding: 0,
        "& dt": {
          fontSize: "14px",
          fontWeight: "bold",
          fontStyle: "italic",
          padding: 0,
          margin: "16px 0 4px"
        },
        "& dt:first-of-type": {
          padding: 0
        },
        "& dt > :first-of-type": {
          marginTop: 0
        },
        "& dt > :last-child": {
          marginBottom: 0
        },
        "& dd": {
          margin: "0 0 16px",
          padding: "0 15px"
        },
        "& dd > :first-of-type": {
          marginTop: 0
        },
        "& dd > :last-child": {
          marginBottom: 0
        }
      },
      [toGlobalSelector("h1")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.l1}px`,
        fontWeight: theme3.typography.weight.bold
      },
      [toGlobalSelector("h2")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.m2}px`,
        paddingBottom: 4,
        borderBottom: `1px solid ${theme3.appBorderColor}`
      },
      [toGlobalSelector("h3")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.m1}px`,
        fontWeight: theme3.typography.weight.bold
      },
      [toGlobalSelector("h4")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.s3}px`
      },
      [toGlobalSelector("h5")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.s2}px`
      },
      [toGlobalSelector("h6")]: {
        ...reset,
        ...headers,
        fontSize: `${theme3.typography.size.s2}px`,
        color: theme3.color.dark
      },
      [toGlobalSelector("hr")]: {
        border: "0 none",
        borderTop: `1px solid ${theme3.appBorderColor}`,
        height: 4,
        padding: 0
      },
      [toGlobalSelector("img")]: {
        maxWidth: "100%"
      },
      [toGlobalSelector("li")]: {
        ...reset,
        fontSize: theme3.typography.size.s2,
        color: theme3.color.defaultText,
        lineHeight: "24px",
        "& + li": {
          marginTop: ".25em"
        },
        "& ul, & ol": {
          marginTop: ".25em",
          marginBottom: 0
        },
        "& code": code
      },
      [toGlobalSelector("ol")]: {
        ...reset,
        margin: "16px 0",
        paddingLeft: 30,
        "& :first-of-type": {
          marginTop: 0
        },
        "& :last-child": {
          marginBottom: 0
        }
      },
      [toGlobalSelector("p")]: {
        ...reset,
        margin: "16px 0",
        fontSize: theme3.typography.size.s2,
        lineHeight: "24px",
        color: theme3.color.defaultText,
        "& code": code
      },
      [toGlobalSelector("pre")]: {
        ...reset,
        // reset
        fontFamily: theme3.typography.fonts.mono,
        WebkitFontSmoothing: "antialiased",
        MozOsxFontSmoothing: "grayscale",
        lineHeight: "18px",
        padding: "11px 1rem",
        whiteSpace: "pre-wrap",
        color: "inherit",
        borderRadius: 3,
        margin: "1rem 0",
        "&:not(.prismjs)": {
          background: "transparent",
          border: "none",
          borderRadius: 0,
          padding: 0,
          margin: 0
        },
        "& pre, &.prismjs": {
          padding: 15,
          margin: 0,
          whiteSpace: "pre-wrap",
          color: "inherit",
          fontSize: "13px",
          lineHeight: "19px",
          code: {
            color: "inherit",
            fontSize: "inherit"
          }
        },
        "& code": {
          whiteSpace: "pre"
        },
        "& code, & tt": {
          border: "none"
        }
      },
      [toGlobalSelector("span")]: {
        ...reset,
        "&.frame": {
          display: "block",
          overflow: "hidden",
          "& > span": {
            border: `1px solid ${theme3.color.medium}`,
            display: "block",
            float: "left",
            overflow: "hidden",
            margin: "13px 0 0",
            padding: 7,
            width: "auto"
          },
          "& span img": {
            display: "block",
            float: "left"
          },
          "& span span": {
            clear: "both",
            color: theme3.color.darkest,
            display: "block",
            padding: "5px 0 0"
          }
        },
        "&.align-center": {
          display: "block",
          overflow: "hidden",
          clear: "both",
          "& > span": {
            display: "block",
            overflow: "hidden",
            margin: "13px auto 0",
            textAlign: "center"
          },
          "& span img": {
            margin: "0 auto",
            textAlign: "center"
          }
        },
        "&.align-right": {
          display: "block",
          overflow: "hidden",
          clear: "both",
          "& > span": {
            display: "block",
            overflow: "hidden",
            margin: "13px 0 0",
            textAlign: "right"
          },
          "& span img": {
            margin: 0,
            textAlign: "right"
          }
        },
        "&.float-left": {
          display: "block",
          marginRight: 13,
          overflow: "hidden",
          float: "left",
          "& span": {
            margin: "13px 0 0"
          }
        },
        "&.float-right": {
          display: "block",
          marginLeft: 13,
          overflow: "hidden",
          float: "right",
          "& > span": {
            display: "block",
            overflow: "hidden",
            margin: "13px auto 0",
            textAlign: "right"
          }
        }
      },
      [toGlobalSelector("table")]: {
        ...reset,
        margin: "16px 0",
        fontSize: theme3.typography.size.s2,
        lineHeight: "24px",
        padding: 0,
        borderCollapse: "collapse",
        "& tr": {
          borderTop: `1px solid ${theme3.appBorderColor}`,
          backgroundColor: theme3.appContentBg,
          margin: 0,
          padding: 0
        },
        "& tr:nth-of-type(2n)": {
          backgroundColor: theme3.base === "dark" ? theme3.color.darker : theme3.color.lighter
        },
        "& tr th": {
          fontWeight: "bold",
          color: theme3.color.defaultText,
          border: `1px solid ${theme3.appBorderColor}`,
          margin: 0,
          padding: "6px 13px"
        },
        "& tr td": {
          border: `1px solid ${theme3.appBorderColor}`,
          color: theme3.color.defaultText,
          margin: 0,
          padding: "6px 13px"
        },
        "& tr th :first-of-type, & tr td :first-of-type": {
          marginTop: 0
        },
        "& tr th :last-child, & tr td :last-child": {
          marginBottom: 0
        }
      },
      [toGlobalSelector("ul")]: {
        ...reset,
        margin: "16px 0",
        paddingLeft: 30,
        "& :first-of-type": {
          marginTop: 0
        },
        "& :last-child": {
          marginBottom: 0
        },
        listStyle: "disc"
      }
    };
  }), DocsWrapper = styled.div(({ theme: theme3 }) => ({
    background: theme3.background.content,
    display: "flex",
    flexDirection: "row-reverse",
    justifyContent: "center",
    padding: "4rem 20px",
    minHeight: "100vh",
    boxSizing: "border-box",
    gap: "3rem",
    [`@media (min-width: ${breakpoint}px)`]: {}
  }));
  globalThis && globalThis.__DOCS_CONTEXT__ === void 0 && (globalThis.__DOCS_CONTEXT__ = createContext(null), globalThis.__DOCS_CONTEXT__.displayName = "DocsContext");
  var DocsContext2 = globalThis ? globalThis.__DOCS_CONTEXT__ : createContext(null), getStoryId = __name((props, context) => {
    let { of, meta } = props;
    if ("of" in props && of === void 0)
      throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
    return meta && context.referenceMeta(meta, !1), context.resolveOf(of || "story", ["story"]).story.id;
  }, "getStoryId"), getBlockBackgroundStyle = __name((theme3) => ({
    borderRadius: theme3.appBorderRadius,
    background: theme3.background.content,
    boxShadow: theme3.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0",
    border: `1px solid ${theme3.appBorderColor}`
  }), "getBlockBackgroundStyle"), { window: globalWindow2 } = globalThis, ZoomContext = createContext({
    scale: 1
  }), { PREVIEW_URL } = globalThis, ErrorMessage = styled.strong(({ theme: theme3 }) => ({
    color: theme3.color.orange
  })), Bar2 = styled(FlexBar)({
    position: "absolute",
    left: 0,
    right: 0,
    top: 0,
    transition: "transform .2s linear"
  }), Wrapper22 = styled.div({
    display: "flex",
    alignItems: "center",
    gap: 4
  }), IconPlaceholder = styled.div(({ theme: theme3 }) => ({
    width: 14,
    height: 14,
    borderRadius: 2,
    margin: "0 7px",
    backgroundColor: theme3.appBorderColor,
    animation: `${theme3.animation.glow} 1.5s ease-in-out infinite`
  })), Toolbar = __name(({
    isLoading,
    storyId,
    baseUrl,
    zoom,
    resetZoom,
    ...rest
  }) => react_default.createElement(Bar2, { ...rest }, react_default.createElement(Wrapper22, { key: "left" }, isLoading ? [1, 2, 3].map((key) => react_default.createElement(IconPlaceholder, { key })) : react_default.createElement(react_default.Fragment, null, react_default.createElement(
    IconButton,
    {
      key: "zoomin",
      onClick: (e2) => {
        e2.preventDefault(), zoom(0.8);
      },
      title: "Zoom in"
    },
    react_default.createElement(ZoomIcon, null)
  ), react_default.createElement(
    IconButton,
    {
      key: "zoomout",
      onClick: (e2) => {
        e2.preventDefault(), zoom(1.25);
      },
      title: "Zoom out"
    },
    react_default.createElement(ZoomOutIcon, null)
  ), react_default.createElement(
    IconButton,
    {
      key: "zoomreset",
      onClick: (e2) => {
        e2.preventDefault(), resetZoom();
      },
      title: "Reset zoom"
    },
    react_default.createElement(ZoomResetIcon, null)
  ))), isLoading ? react_default.createElement(Wrapper22, { key: "right" }, react_default.createElement(IconPlaceholder, null)) : baseUrl && storyId && react_default.createElement(Wrapper22, { key: "right" }, react_default.createElement(IconButton, { key: "opener", asChild: !0 }, react_default.createElement(
    "a",
    {
      href: getStoryHref(baseUrl, storyId),
      target: "_blank",
      rel: "noopener noreferrer",
      "aria-label": "Open canvas in new tab"
    },
    react_default.createElement(ShareAltIcon, null)
  )))), "Toolbar"), ChildrenContainer = styled.div(
    ({ isColumn, columns, layout }) => ({
      display: isColumn || !columns ? "block" : "flex",
      position: "relative",
      flexWrap: "wrap",
      overflow: "auto",
      flexDirection: isColumn ? "column" : "row",
      "& .innerZoomElementWrapper > *": isColumn ? {
        width: layout !== "fullscreen" ? "calc(100% - 20px)" : "100%",
        display: "block"
      } : {
        maxWidth: layout !== "fullscreen" ? "calc(100% - 20px)" : "100%",
        display: "inline-block"
      }
    }),
    ({ layout = "padded", inline }) => layout === "centered" || layout === "padded" ? {
      padding: inline ? "32px 22px" : "0px",
      "& .innerZoomElementWrapper > *": {
        width: "auto",
        border: "8px solid transparent!important"
      }
    } : {},
    ({ layout = "padded", inline }) => layout === "centered" && inline ? {
      display: "flex",
      justifyContent: "center",
      justifyItems: "center",
      alignContent: "center",
      alignItems: "center"
    } : {},
    ({ columns }) => columns && columns > 1 ? { ".innerZoomElementWrapper > *": { minWidth: `calc(100% / ${columns} - 20px)` } } : {}
  ), StyledSource = styled(Source)(({ theme: theme3 }) => ({
    margin: 0,
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    borderBottomLeftRadius: theme3.appBorderRadius,
    borderBottomRightRadius: theme3.appBorderRadius,
    border: "none",
    background: theme3.base === "light" ? "rgba(0, 0, 0, 0.85)" : curriedDarken$1(0.05, theme3.background.content),
    color: theme3.color.lightest,
    button: {
      background: theme3.base === "light" ? "rgba(0, 0, 0, 0.85)" : curriedDarken$1(0.05, theme3.background.content)
    }
  })), PreviewContainer = styled.div(
    ({ theme: theme3, withSource, isExpanded }) => ({
      position: "relative",
      overflow: "hidden",
      margin: "25px 0 40px",
      ...getBlockBackgroundStyle(theme3),
      borderBottomLeftRadius: withSource && isExpanded && 0,
      borderBottomRightRadius: withSource && isExpanded && 0,
      borderBottomWidth: isExpanded && 0,
      "h3 + &": {
        marginTop: "16px"
      }
    }),
    ({ withToolbar }) => withToolbar && { paddingTop: 40 }
  ), getSource = __name((withSource, expanded, setExpanded) => {
    switch (!0) {
      case !!(withSource && withSource.error):
        return {
          source: null,
          actionItem: {
            title: "No code available",
            className: "docblock-code-toggle docblock-code-toggle--disabled",
            disabled: !0,
            onClick: __name(() => setExpanded(!1), "onClick")
          }
        };
      case expanded:
        return {
          source: react_default.createElement(StyledSource, { ...withSource, dark: !0 }),
          actionItem: {
            title: "Hide code",
            className: "docblock-code-toggle docblock-code-toggle--expanded",
            onClick: __name(() => setExpanded(!1), "onClick")
          }
        };
      default:
        return {
          source: react_default.createElement(StyledSource, { ...withSource, dark: !0 }),
          actionItem: {
            title: "Show code",
            className: "docblock-code-toggle",
            onClick: __name(() => setExpanded(!0), "onClick")
          }
        };
    }
  }, "getSource");
  function getChildProps(children) {
    if (Children.count(children) === 1) {
      let elt = children;
      if (elt.props)
        return elt.props;
    }
    return null;
  }
  __name(getChildProps, "getChildProps");
  var PositionedToolbar = styled(Toolbar)({
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: 40
  }), Relative = styled.div({
    overflow: "hidden",
    position: "relative"
  }), Preview2 = __name(({
    isLoading,
    isColumn,
    columns,
    children,
    withSource,
    withToolbar = !1,
    isExpanded = !1,
    additionalActions,
    className,
    layout = "padded",
    inline = !1,
    ...props
  }) => {
    let [expanded, setExpanded] = useState(isExpanded), { source, actionItem } = getSource(withSource, expanded, setExpanded), [scale, setScale] = useState(1), previewClasses = [className].concat(["sbdocs", "sbdocs-preview", "sb-unstyled"]), defaultActionItems = withSource ? [actionItem] : [], [additionalActionItems, setAdditionalActionItems] = useState(
      additionalActions ? [...additionalActions] : []
    ), actionItems = [...defaultActionItems, ...additionalActionItems], { window: globalWindow3 } = globalThis, context = useContext(DocsContext2), copyToClipboard = useCallback(async (text) => {
      let { createCopyToClipboardFunction: createCopyToClipboardFunction2 } = await Promise.resolve().then(() => (init_components(), components_exports));
      createCopyToClipboardFunction2();
    }, []), onCopyCapture = __name((e2) => {
      let selection = globalWindow3.getSelection();
      selection && selection.type === "Range" || (e2.preventDefault(), additionalActionItems.filter((item) => item.title === "Copied").length === 0 && copyToClipboard(source?.props.code ?? "").then(() => {
        setAdditionalActionItems([
          ...additionalActionItems,
          {
            title: "Copied",
            onClick: __name(() => {
            }, "onClick")
          }
        ]), globalWindow3.setTimeout(
          () => setAdditionalActionItems(
            additionalActionItems.filter((item) => item.title !== "Copied")
          ),
          1500
        );
      }));
    }, "onCopyCapture"), childProps = getChildProps(children);
    return react_default.createElement(
      PreviewContainer,
      {
        withSource,
        withToolbar,
        ...props,
        className: previewClasses.join(" ")
      },
      withToolbar && react_default.createElement(
        PositionedToolbar,
        {
          isLoading,
          border: !0,
          zoom: (z22) => setScale(scale * z22),
          resetZoom: () => setScale(1),
          storyId: !isLoading && childProps ? getStoryId(childProps, context) : void 0,
          baseUrl: "./iframe.html"
        }
      ),
      react_default.createElement(ZoomContext.Provider, { value: { scale } }, react_default.createElement(Relative, { className: "docs-story", onCopyCapture: withSource && onCopyCapture }, react_default.createElement(
        ChildrenContainer,
        {
          isColumn: isColumn || !Array.isArray(children),
          columns,
          layout,
          inline
        },
        react_default.createElement(Zoom.Element, { centered: layout === "centered", scale: inline ? scale : 1 }, Array.isArray(children) ? children.map((child, i22) => react_default.createElement("div", { key: i22 }, child)) : react_default.createElement("div", null, children))
      ), react_default.createElement(ActionBar, { actionItems }))),
      withSource && expanded && source
    );
  }, "Preview"), StyledPreview = styled(Preview2)(() => ({
    ".docs-story": {
      paddingTop: 32,
      paddingBottom: 40
    }
  })), Label = styled.div(({ theme: theme3 }) => ({
    marginRight: 30,
    fontSize: `${theme3.typography.size.s1}px`,
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText)
  })), Sample = styled.div({
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  }), TypeSpecimen = styled.div({
    display: "flex",
    flexDirection: "row",
    alignItems: "baseline",
    "&:not(:last-child)": { marginBottom: "1rem" }
  }), Wrapper3 = styled.div(withReset, ({ theme: theme3 }) => ({
    ...getBlockBackgroundStyle(theme3),
    margin: "25px 0 40px",
    padding: "30px 20px"
  })), ItemTitle = styled.div(({ theme: theme3 }) => ({
    fontWeight: theme3.typography.weight.bold,
    color: theme3.color.defaultText
  })), ItemSubtitle = styled.div(({ theme: theme3 }) => ({
    color: theme3.base === "light" ? curriedTransparentize$1(0.2, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText)
  })), ItemDescription = styled.div({
    flex: "0 0 30%",
    lineHeight: "20px",
    marginTop: 5
  }), SwatchLabel = styled.div(({ theme: theme3 }) => ({
    flex: 1,
    textAlign: "center",
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1,
    lineHeight: 1,
    overflow: "hidden",
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText),
    "> div": {
      display: "inline-block",
      overflow: "hidden",
      maxWidth: "100%",
      textOverflow: "ellipsis"
    },
    span: {
      display: "block",
      marginTop: 2
    }
  })), SwatchLabels = styled.div({
    display: "flex",
    flexDirection: "row"
  }), Swatch2 = styled.div(({ background: background2 }) => ({
    position: "relative",
    flex: 1,
    "&::before": {
      position: "absolute",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      background: background2,
      content: '""'
    }
  })), SwatchColors = styled.div(({ theme: theme3 }) => ({
    ...getBlockBackgroundStyle(theme3),
    display: "flex",
    flexDirection: "row",
    height: 50,
    marginBottom: 5,
    overflow: "hidden",
    backgroundColor: "white",
    backgroundImage: "repeating-linear-gradient(-45deg, #ccc, #ccc 1px, #fff 1px, #fff 16px)",
    backgroundClip: "padding-box"
  })), SwatchSpecimen = styled.div({
    display: "flex",
    flexDirection: "column",
    flex: 1,
    position: "relative",
    marginBottom: 30
  }), Swatches2 = styled.div({
    flex: 1,
    display: "flex",
    flexDirection: "row"
  }), Item = styled.div({
    display: "flex",
    alignItems: "flex-start"
  }), ListName = styled.div({
    flex: "0 0 30%"
  }), ListSwatches = styled.div({
    flex: 1
  }), ListHeading = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    paddingBottom: 20,
    fontWeight: theme3.typography.weight.bold,
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText)
  })), List = styled.div(({ theme: theme3 }) => ({
    fontSize: theme3.typography.size.s2,
    lineHeight: "20px",
    display: "flex",
    flexDirection: "column"
  })), ItemLabel = styled.div(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.base,
    fontSize: theme3.typography.size.s1,
    color: theme3.color.defaultText,
    marginLeft: 10,
    lineHeight: 1.2,
    display: "-webkit-box",
    overflow: "hidden",
    wordBreak: "break-word",
    textOverflow: "ellipsis",
    WebkitLineClamp: 2,
    WebkitBoxOrient: "vertical"
  })), ItemSpecimen = styled.div(({ theme: theme3 }) => ({
    ...getBlockBackgroundStyle(theme3),
    overflow: "hidden",
    height: 40,
    width: 40,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flex: "none",
    "> img, > svg": {
      width: 20,
      height: 20
    }
  })), Item2 = styled.div({
    display: "inline-flex",
    flexDirection: "row",
    alignItems: "center",
    width: "100%"
  }), List2 = styled.div({
    display: "grid",
    gridTemplateColumns: "repeat(auto-fill, minmax(140px, 1fr))",
    gridGap: "8px 16px",
    gridAutoFlow: "row dense",
    gridAutoRows: 50
  }), Aside = styled.aside(() => ({
    width: "10rem",
    "@media (max-width: 768px)": {
      display: "none"
    }
  })), Nav = styled.nav(({ theme: theme3 }) => ({
    position: "fixed",
    bottom: 0,
    top: 0,
    width: "10rem",
    paddingTop: "4rem",
    paddingBottom: "2rem",
    overflowY: "auto",
    fontFamily: theme3.typography.fonts.base,
    fontSize: theme3.typography.size.s2,
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
    WebkitOverflowScrolling: "touch",
    "& *": {
      boxSizing: "border-box"
    },
    "& > .toc-wrapper > .toc-list": {
      paddingLeft: 0,
      borderLeft: `solid 2px ${theme3.color.mediumlight}`,
      ".toc-list": {
        paddingLeft: 0,
        borderLeft: `solid 2px ${theme3.color.mediumlight}`,
        ".toc-list": {
          paddingLeft: 0,
          borderLeft: `solid 2px ${theme3.color.mediumlight}`
        }
      }
    },
    "& .toc-list-item": {
      position: "relative",
      listStyleType: "none",
      marginLeft: 20,
      paddingTop: 3,
      paddingBottom: 3
    },
    "& .toc-list-item::before": {
      content: '""',
      position: "absolute",
      height: "100%",
      top: 0,
      left: 0,
      transform: "translateX(calc(-2px - 20px))",
      borderLeft: `solid 2px ${theme3.color.mediumdark}`,
      opacity: 0,
      transition: "opacity 0.2s"
    },
    "& .toc-list-item.is-active-li::before": {
      opacity: 1
    },
    "& .toc-list-item > a": {
      color: theme3.color.defaultText,
      textDecoration: "none"
    },
    "& .toc-list-item.is-active-li > a": {
      fontWeight: 600,
      color: theme3.color.secondary,
      textDecoration: "none"
    }
  })), Heading = styled.p(({ theme: theme3 }) => ({
    fontWeight: 600,
    fontSize: "0.875em",
    color: theme3.textColor,
    textTransform: "uppercase",
    marginBottom: 10
  }));
  function n() {
    return n = Object.assign ? Object.assign.bind() : function(e2) {
      for (var n2 = 1; n2 < arguments.length; n2++) {
        var r2 = arguments[n2];
        for (var t in r2) Object.prototype.hasOwnProperty.call(r2, t) && (e2[t] = r2[t]);
      }
      return e2;
    }, n.apply(this, arguments);
  }
  __name(n, "n");
  var r = ["children", "options"], o = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e2, n2) => (e2[n2.toLowerCase()] = n2, e2), { class: "className", for: "htmlFor" }), a2 = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "\xA0", quot: "\u201C" }, c2 = ["style", "script", "pre"], i2 = ["src", "href", "data", "formAction", "srcDoc", "action"], u2 = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, l = /mailto:/i, s3 = /\n{2,}$/, f3 = /^(\s*>[\s\S]*?)(?=\n\n|$)/, _2 = /^ *> ?/gm, d2 = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, p3 = /^ {2,}\n/, y2 = /^(?:( *[-*_])){3,} *(?:\n *)+\n/, h3 = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, g2 = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, m2 = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, k2 = /^(?:\n *)*\n/, x2 = /\r\n?/g, v2 = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, q2 = /^\[\^([^\]]+)]/, $2 = /\f/g, b2 = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, S2 = /^\s*?\[(x|\s)\]/, z2 = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, E2 = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, A2 = /^([^\n]+)\n *(=|-){3,} *\n/, R2 = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i, B2 = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, L2 = /^<!--[\s\S]*?(?:-->)/, O = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, j = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, C3 = /^\{.*\}$/, I2 = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, T2 = /^<([^ >]+@[^ >]+)>/, M = /^<([^ >]+:\/[^ >]+)>/, w2 = /-([a-z])?/gi, D2 = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, F2 = /^[^\n]+(?:  \n|\n{2,})/, P3 = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, Z2 = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, N2 = /^\[([^\]]*)\] ?\[([^\]]*)\]/, G = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, U2 = /\t/g, V2 = /(^ *\||\| *$)/g, H7 = /^ *:-+: *$/, Q2 = /^ *:-+ *$/, W2 = /^ *-+: *$/, J2 = __name((e2) => `(?=[\\s\\S]+?\\1${e2 ? "\\1" : ""})`, "J"), K2 = "((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|\\\\\\1|[\\s\\S])+?)", X2 = RegExp(`^([*_])\\1${J2(1)}${K2}\\1\\1(?!\\1)`), Y2 = RegExp(`^([*_])${J2(0)}${K2}\\1(?!\\1)`), ee2 = RegExp(`^(==)${J2(0)}${K2}\\1`), ne = RegExp(`^(~~)${J2(0)}${K2}\\1`), re2 = /^(:[a-zA-Z0-9-_]+:)/, te = /^\\([^0-9A-Za-z\s])/, oe = /\\([^0-9A-Za-z\s])/g, ae = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/, ce = /^\n+/, ie = /^([ \t]*)/, ue2 = /(?:^|\n)( *)$/, le2 = "(?:\\d+\\.)", se = "(?:[*+-])";
  function fe(e2) {
    return "( *)(" + (e2 === 1 ? le2 : se) + ") +";
  }
  __name(fe, "fe");
  var _e = fe(1), de = fe(2);
  function pe(e2) {
    return RegExp("^" + (e2 === 1 ? _e : de));
  }
  __name(pe, "pe");
  var ye = pe(1), he = pe(2);
  function ge(e2) {
    return RegExp("^" + (e2 === 1 ? _e : de) + "[^\\n]*(?:\\n(?!\\1" + (e2 === 1 ? le2 : se) + " )[^\\n]*)*(\\n|$)", "gm");
  }
  __name(ge, "ge");
  var me = ge(1), ke = ge(2);
  function xe(e2) {
    let n2 = e2 === 1 ? le2 : se;
    return RegExp("^( *)(" + n2 + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + n2 + " (?!" + n2 + " ))\\n*|\\s*\\n*$)");
  }
  __name(xe, "xe");
  var ve = xe(1), qe = xe(2);
  function $e(e2, n2) {
    let r2 = n2 === 1, t = r2 ? ve : qe, o2 = r2 ? me : ke, a22 = r2 ? ye : he;
    return { t: __name((e3) => a22.test(e3), "t"), o: Ce(function(e3, n3) {
      let r3 = ue2.exec(n3.prevCapture);
      return r3 && (n3.list || !n3.inline && !n3.simple) ? t.exec(e3 = r3[1] + e3) : null;
    }), i: 1, u(e3, n3, t2) {
      let c22 = r2 ? +e3[2] : void 0, i22 = e3[0].replace(s3, `
`).match(o2), u22 = !1;
      return { items: i22.map(function(e4, r3) {
        let o3 = a22.exec(e4)[0].length, c3 = RegExp("^ {1," + o3 + "}", "gm"), l2 = e4.replace(c3, "").replace(a22, ""), s22 = r3 === i22.length - 1, f22 = l2.indexOf(`

`) !== -1 || s22 && u22;
        u22 = f22;
        let _22 = t2.inline, d22 = t2.list, p22;
        t2.list = !0, f22 ? (t2.inline = !1, p22 = ze(l2) + `

`) : (t2.inline = !0, p22 = ze(l2));
        let y22 = n3(p22, t2);
        return t2.inline = _22, t2.list = d22, y22;
      }), ordered: r2, start: c22 };
    }, l: __name((n3, r3, t2) => e2(n3.ordered ? "ol" : "ul", { key: t2.key, start: n3.type === "20" ? n3.start : void 0 }, n3.items.map(function(n4, o3) {
      return e2("li", { key: o3 }, r3(n4, t2));
    })), "l") };
  }
  __name($e, "$e");
  var be = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), Se = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
  function ze(e2) {
    let n2 = e2.length;
    for (; n2 > 0 && e2[n2 - 1] <= " "; ) n2--;
    return e2.slice(0, n2);
  }
  __name(ze, "ze");
  function Ee2(e2, n2) {
    return e2.startsWith(n2);
  }
  __name(Ee2, "Ee");
  function Ae(e2, n2, r2) {
    if (Array.isArray(r2)) {
      for (let n3 = 0; n3 < r2.length; n3++) if (Ee2(e2, r2[n3])) return !0;
      return !1;
    }
    return r2(e2, n2);
  }
  __name(Ae, "Ae");
  function Re(e2) {
    return e2.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
  }
  __name(Re, "Re");
  function Be(e2) {
    return W2.test(e2) ? "right" : H7.test(e2) ? "center" : Q2.test(e2) ? "left" : null;
  }
  __name(Be, "Be");
  function Le(e2, n2, r2, t) {
    let o2 = r2.inTable;
    r2.inTable = !0;
    let a22 = [[]], c22 = "";
    function i22() {
      if (!c22) return;
      let e3 = a22[a22.length - 1];
      e3.push.apply(e3, n2(c22, r2)), c22 = "";
    }
    return __name(i22, "i"), e2.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((e3, n3, r3) => {
      e3.trim() === "|" && (i22(), t) ? n3 !== 0 && n3 !== r3.length - 1 && a22.push([]) : c22 += e3;
    }), i22(), r2.inTable = o2, a22;
  }
  __name(Le, "Le");
  function Oe(e2, n2, r2) {
    r2.inline = !0;
    let t = e2[2] ? e2[2].replace(V2, "").split("|").map(Be) : [], o2 = e2[3] ? (function(e3, n3, r3) {
      return e3.trim().split(`
`).map(function(e4) {
        return Le(e4, n3, r3, !0);
      });
    })(e2[3], n2, r2) : [], a22 = Le(e2[1], n2, r2, !!o2.length);
    return r2.inline = !1, o2.length ? { align: t, cells: o2, header: a22, type: "25" } : { children: a22, type: "21" };
  }
  __name(Oe, "Oe");
  function je(e2, n2) {
    return e2.align[n2] == null ? {} : { textAlign: e2.align[n2] };
  }
  __name(je, "je");
  function Ce(e2) {
    return e2.inline = 1, e2;
  }
  __name(Ce, "Ce");
  function Ie(e2) {
    return Ce(function(n2, r2) {
      return r2.inline ? e2.exec(n2) : null;
    });
  }
  __name(Ie, "Ie");
  function Te(e2) {
    return Ce(function(n2, r2) {
      return r2.inline || r2.simple ? e2.exec(n2) : null;
    });
  }
  __name(Te, "Te");
  function Me(e2) {
    return function(n2, r2) {
      return r2.inline || r2.simple ? null : e2.exec(n2);
    };
  }
  __name(Me, "Me");
  function we(e2) {
    return Ce(function(n2) {
      return e2.exec(n2);
    });
  }
  __name(we, "we");
  var De = /(javascript|vbscript|data(?!:image)):/i;
  function Fe(e2) {
    try {
      let n2 = decodeURIComponent(e2).replace(/[^A-Za-z0-9/:]/g, "");
      if (De.test(n2)) return null;
    } catch {
      return null;
    }
    return e2;
  }
  __name(Fe, "Fe");
  function Pe(e2) {
    return e2 && e2.replace(oe, "$1");
  }
  __name(Pe, "Pe");
  function Ze(e2, n2, r2) {
    let t = r2.inline || !1, o2 = r2.simple || !1;
    r2.inline = !0, r2.simple = !0;
    let a22 = e2(n2, r2);
    return r2.inline = t, r2.simple = o2, a22;
  }
  __name(Ze, "Ze");
  function Ne(e2, n2, r2) {
    let t = r2.inline || !1, o2 = r2.simple || !1;
    r2.inline = !1, r2.simple = !0;
    let a22 = e2(n2, r2);
    return r2.inline = t, r2.simple = o2, a22;
  }
  __name(Ne, "Ne");
  function Ge(e2, n2, r2) {
    let t = r2.inline || !1;
    r2.inline = !1;
    let o2 = e2(n2, r2);
    return r2.inline = t, o2;
  }
  __name(Ge, "Ge");
  var Ue = __name((e2, n2, r2) => ({ children: Ze(n2, e2[2], r2) }), "Ue");
  function Ve() {
    return {};
  }
  __name(Ve, "Ve");
  function He2() {
    return null;
  }
  __name(He2, "He");
  function Qe(...e2) {
    return e2.filter(Boolean).join(" ");
  }
  __name(Qe, "Qe");
  function We(e2, n2, r2) {
    let t = e2, o2 = n2.split(".");
    for (; o2.length && (t = t[o2[0]], t !== void 0); ) o2.shift();
    return t || r2;
  }
  __name(We, "We");
  function Je(r2 = "", t = {}) {
    t.overrides = t.overrides || {}, t.namedCodesToUnicode = t.namedCodesToUnicode ? n({}, a2, t.namedCodesToUnicode) : a2;
    let s22 = t.slugify || Re, V22 = t.sanitizer || Fe, H22 = t.createElement || createElement, Q22 = [f3, h3, g2, t.enforceAtxHeadings ? E2 : z2, A2, D2, ve, qe], W22 = [...Q22, F2, R2, L2, j];
    function J22(e2, r3, ...o2) {
      let a22 = We(t.overrides, e2 + ".props", {});
      return H22((function(e3, n2) {
        let r4 = We(n2, e3);
        return r4 ? typeof r4 == "function" || typeof r4 == "object" && "render" in r4 ? r4 : We(n2, e3 + ".component", e3) : e3;
      })(e2, t.overrides), n({}, r3, a22, { className: Qe(r3?.className, a22.className) || void 0 }), ...o2);
    }
    __name(J22, "J");
    function K22(e2) {
      e2 = e2.replace(b2, "");
      let n2 = !1;
      t.forceInline ? n2 = !0 : t.forceBlock || (n2 = G.test(e2) === !1);
      let r3 = _e2(fe2(n2 ? e2 : ze(e2).replace(ce, "") + `

`, { inline: n2 }));
      for (; typeof r3[r3.length - 1] == "string" && !r3[r3.length - 1].trim(); ) r3.pop();
      if (t.wrapper === null) return r3;
      let o2 = t.wrapper || (n2 ? "span" : "div"), a22;
      if (r3.length > 1 || t.forceWrapper) a22 = r3;
      else {
        if (r3.length === 1) return a22 = r3[0], typeof a22 == "string" ? J22("span", { key: "outer" }, a22) : a22;
        a22 = null;
      }
      return H22(o2, { key: "outer" }, a22);
    }
    __name(K22, "K");
    function oe2(e2, n2) {
      if (!n2 || !n2.trim()) return null;
      let r3 = n2.match(u2);
      return r3 ? r3.reduce(function(n3, r4) {
        let t2 = r4.indexOf("=");
        if (t2 !== -1) {
          let a22 = (function(e3) {
            return e3.indexOf("-") !== -1 && e3.match(O) === null && (e3 = e3.replace(w2, function(e4, n4) {
              return n4.toUpperCase();
            })), e3;
          })(r4.slice(0, t2)).trim(), c22 = (function(e3) {
            let n4 = e3[0];
            return (n4 === '"' || n4 === "'") && e3.length >= 2 && e3[e3.length - 1] === n4 ? e3.slice(1, -1) : e3;
          })(r4.slice(t2 + 1).trim()), u22 = o[a22] || a22;
          if (u22 === "ref") return n3;
          let l2 = n3[u22] = (function(e3, n4, r5, t3) {
            return n4 === "style" ? (function(e4) {
              let n5 = [], r6 = "", t4 = !1, o2 = !1, a3 = "";
              if (!e4) return n5;
              for (let c4 = 0; c4 < e4.length; c4++) {
                let i22 = e4[c4];
                if (i22 !== '"' && i22 !== "'" || t4 || (o2 ? i22 === a3 && (o2 = !1, a3 = "") : (o2 = !0, a3 = i22)), i22 === "(" && r6.endsWith("url") ? t4 = !0 : i22 === ")" && t4 && (t4 = !1), i22 !== ";" || o2 || t4) r6 += i22;
                else {
                  let e5 = r6.trim();
                  if (e5) {
                    let r7 = e5.indexOf(":");
                    if (r7 > 0) {
                      let t5 = e5.slice(0, r7).trim(), o3 = e5.slice(r7 + 1).trim();
                      n5.push([t5, o3]);
                    }
                  }
                  r6 = "";
                }
              }
              let c3 = r6.trim();
              if (c3) {
                let e5 = c3.indexOf(":");
                if (e5 > 0) {
                  let r7 = c3.slice(0, e5).trim(), t5 = c3.slice(e5 + 1).trim();
                  n5.push([r7, t5]);
                }
              }
              return n5;
            })(r5).reduce(function(n5, [r6, o2]) {
              return n5[r6.replace(/(-[a-z])/g, (e4) => e4[1].toUpperCase())] = t3(o2, e3, r6), n5;
            }, {}) : i2.indexOf(n4) !== -1 ? t3(Pe(r5), e3, n4) : (r5.match(C3) && (r5 = Pe(r5.slice(1, r5.length - 1))), r5 === "true" || r5 !== "false" && r5);
          })(e2, a22, c22, V22);
          typeof l2 == "string" && (R2.test(l2) || j.test(l2)) && (n3[u22] = K22(l2.trim()));
        } else r4 !== "style" && (n3[o[r4] || r4] = !0);
        return n3;
      }, {}) : null;
    }
    __name(oe2, "oe");
    let ue22 = [], le22 = {}, se2 = { 0: { t: [">"], o: Me(f3), i: 1, u(e2, n2, r3) {
      let [, t2, o2] = e2[0].replace(_2, "").match(d2);
      return { alert: t2, children: n2(o2, r3) };
    }, l(e2, n2, r3) {
      let t2 = { key: r3.key };
      return e2.alert && (t2.className = "markdown-alert-" + s22(e2.alert.toLowerCase(), Re), e2.children.unshift({ attrs: {}, children: [{ type: "27", text: e2.alert }], noInnerParse: !0, type: "11", tag: "header" })), J22("blockquote", t2, n2(e2.children, r3));
    } }, 1: { o: we(p3), i: 1, u: Ve, l: __name((e2, n2, r3) => J22("br", { key: r3.key }), "l") }, 2: { t: __name((e2) => {
      let n2 = e2[0];
      return n2 === "-" || n2 === "*" || n2 === "_";
    }, "t"), o: Me(y2), i: 1, u: Ve, l: __name((e2, n2, r3) => J22("hr", { key: r3.key }), "l") }, 3: { t: ["    "], o: Me(g2), i: 0, u: __name((e2) => ({ lang: void 0, text: Pe(ze(e2[0].replace(/^ {4}/gm, ""))) }), "u"), l: __name((e2, r3, t2) => J22("pre", { key: t2.key }, J22("code", n({}, e2.attrs, { className: e2.lang ? "lang-" + e2.lang : "" }), e2.text)), "l") }, 4: { t: ["```", "~~~"], o: Me(h3), i: 0, u: __name((e2) => ({ attrs: oe2("code", e2[3] || ""), lang: e2[2] || void 0, text: e2[4], type: "3" }), "u") }, 5: { t: ["`"], o: Te(m2), i: 3, u: __name((e2) => ({ text: Pe(e2[2]) }), "u"), l: __name((e2, n2, r3) => J22("code", { key: r3.key }, e2.text), "l") }, 6: { t: ["[^"], o: Me(v2), i: 0, u: __name((e2) => (ue22.push({ footnote: e2[2], identifier: e2[1] }), {}), "u"), l: He2 }, 7: { t: ["[^"], o: Ie(q2), i: 1, u: __name((e2) => ({ target: "#" + s22(e2[1], Re), text: e2[1] }), "u"), l: __name((e2, n2, r3) => J22("a", { key: r3.key, href: V22(e2.target, "a", "href") }, J22("sup", { key: r3.key }, e2.text)), "l") }, 8: { t: ["[ ]", "[x]"], o: Ie(S2), i: 1, u: __name((e2) => ({ completed: e2[1].toLowerCase() === "x" }), "u"), l: __name((e2, n2, r3) => J22("input", { checked: e2.completed, key: r3.key, readOnly: !0, type: "checkbox" }), "l") }, 9: { t: ["#"], o: Me(t.enforceAtxHeadings ? E2 : z2), i: 1, u: __name((e2, n2, r3) => ({ children: Ze(n2, e2[2], r3), id: s22(e2[2], Re), level: e2[1].length }), "u"), l: __name((e2, n2, r3) => J22("h" + e2.level, { id: e2.id, key: r3.key }, n2(e2.children, r3)), "l") }, 10: { o: Me(A2), i: 0, u: __name((e2, n2, r3) => ({ children: Ze(n2, e2[1], r3), level: e2[2] === "=" ? 1 : 2, type: "9" }), "u") }, 11: { t: ["<"], o: we(R2), i: 1, u(e2, n2, r3) {
      let [, t2] = e2[3].match(ie), o2 = RegExp("^" + t2, "gm"), a22 = e2[3].replace(o2, ""), i22 = (u22 = a22, W22.some((e3) => e3.test(u22)) ? Ge : Ze);
      var u22;
      let l2 = e2[1].toLowerCase(), s32 = c2.indexOf(l2) !== -1, f22 = (s32 ? l2 : e2[1]).trim(), _22 = { attrs: oe2(f22, e2[2]), noInnerParse: s32, tag: f22 };
      if (r3.inAnchor = r3.inAnchor || l2 === "a", s32) _22.text = e2[3];
      else {
        let e3 = r3.inHTML;
        r3.inHTML = !0, _22.children = i22(n2, a22, r3), r3.inHTML = e3;
      }
      return r3.inAnchor = !1, _22;
    }, l: __name((e2, r3, t2) => J22(e2.tag, n({ key: t2.key }, e2.attrs), e2.text || (e2.children ? r3(e2.children, t2) : "")), "l") }, 13: { t: ["<"], o: we(j), i: 1, u(e2) {
      let n2 = e2[1].trim();
      return { attrs: oe2(n2, e2[2] || ""), tag: n2 };
    }, l: __name((e2, r3, t2) => J22(e2.tag, n({}, e2.attrs, { key: t2.key })), "l") }, 12: { t: ["<!--"], o: we(L2), i: 1, u: __name(() => ({}), "u"), l: He2 }, 14: { t: ["!["], o: Te(Se), i: 1, u: __name((e2) => ({ alt: Pe(e2[1]), target: Pe(e2[2]), title: Pe(e2[3]) }), "u"), l: __name((e2, n2, r3) => J22("img", { key: r3.key, alt: e2.alt || void 0, title: e2.title || void 0, src: V22(e2.target, "img", "src") }), "l") }, 15: { t: ["["], o: Ie(be), i: 3, u: __name((e2, n2, r3) => ({ children: Ne(n2, e2[1], r3), target: Pe(e2[2]), title: Pe(e2[3]) }), "u"), l: __name((e2, n2, r3) => J22("a", { key: r3.key, href: V22(e2.target, "a", "href"), title: e2.title }, n2(e2.children, r3)), "l") }, 16: { t: ["<"], o: Ie(M), i: 0, u: __name((e2) => ({ children: [{ text: e2[1], type: "27" }], target: e2[1], type: "15" }), "u") }, 17: { t: __name((e2, n2) => !n2.inAnchor && !t.disableAutoLink && (Ee2(e2, "http://") || Ee2(e2, "https://")), "t"), o: Ie(I2), i: 0, u: __name((e2) => ({ children: [{ text: e2[1], type: "27" }], target: e2[1], title: void 0, type: "15" }), "u") }, 18: { t: ["<"], o: Ie(T2), i: 0, u(e2) {
      let n2 = e2[1], r3 = e2[1];
      return l.test(r3) || (r3 = "mailto:" + r3), { children: [{ text: n2.replace("mailto:", ""), type: "27" }], target: r3, type: "15" };
    } }, 20: $e(J22, 1), 33: $e(J22, 2), 19: { o: Me(k2), i: 3, u: Ve, l: __name(() => `
`, "l") }, 21: { o: Ce(function(e2, n2) {
      if (n2.inline || n2.simple || n2.inHTML && e2.indexOf(`

`) === -1 && n2.prevCapture.indexOf(`

`) === -1) return null;
      let r3 = "";
      e2.split(`
`).every((e3) => (e3 += `
`, !Q22.some((n3) => n3.test(e3)) && (r3 += e3, !!e3.trim())));
      let t2 = ze(r3);
      return t2 === "" ? null : [r3, , t2];
    }), i: 3, u: Ue, l: __name((e2, n2, r3) => J22("p", { key: r3.key }, n2(e2.children, r3)), "l") }, 22: { t: ["["], o: Ie(P3), i: 0, u: __name((e2) => (le22[e2[1]] = { target: e2[2], title: e2[4] }, {}), "u"), l: He2 }, 23: { t: ["!["], o: Te(Z2), i: 0, u: __name((e2) => ({ alt: e2[1] ? Pe(e2[1]) : void 0, ref: e2[2] }), "u"), l: __name((e2, n2, r3) => le22[e2.ref] ? J22("img", { key: r3.key, alt: e2.alt, src: V22(le22[e2.ref].target, "img", "src"), title: le22[e2.ref].title }) : null, "l") }, 24: { t: __name((e2) => e2[0] === "[" && e2.indexOf("](") === -1, "t"), o: Ie(N2), i: 0, u: __name((e2, n2, r3) => ({ children: n2(e2[1], r3), fallbackChildren: e2[0], ref: e2[2] }), "u"), l: __name((e2, n2, r3) => le22[e2.ref] ? J22("a", { key: r3.key, href: V22(le22[e2.ref].target, "a", "href"), title: le22[e2.ref].title }, n2(e2.children, r3)) : J22("span", { key: r3.key }, e2.fallbackChildren), "l") }, 25: { t: ["|"], o: Me(D2), i: 1, u: Oe, l(e2, n2, r3) {
      let t2 = e2;
      return J22("table", { key: r3.key }, J22("thead", null, J22("tr", null, t2.header.map(function(e3, o2) {
        return J22("th", { key: o2, style: je(t2, o2) }, n2(e3, r3));
      }))), J22("tbody", null, t2.cells.map(function(e3, o2) {
        return J22("tr", { key: o2 }, e3.map(function(e4, o3) {
          return J22("td", { key: o3, style: je(t2, o3) }, n2(e4, r3));
        }));
      })));
    } }, 27: { o: Ce(function(e2, n2) {
      let r3;
      return Ee2(e2, ":") && (r3 = re2.exec(e2)), r3 || ae.exec(e2);
    }), i: 4, u(e2) {
      let n2 = e2[0];
      return { text: n2.indexOf("&") === -1 ? n2 : n2.replace(B2, (e3, n3) => t.namedCodesToUnicode[n3] || e3) };
    }, l: __name((e2) => e2.text, "l") }, 28: { t: ["**", "__"], o: Te(X2), i: 2, u: __name((e2, n2, r3) => ({ children: n2(e2[2], r3) }), "u"), l: __name((e2, n2, r3) => J22("strong", { key: r3.key }, n2(e2.children, r3)), "l") }, 29: { t: __name((e2) => {
      let n2 = e2[0];
      return (n2 === "*" || n2 === "_") && e2[1] !== n2;
    }, "t"), o: Te(Y2), i: 3, u: __name((e2, n2, r3) => ({ children: n2(e2[2], r3) }), "u"), l: __name((e2, n2, r3) => J22("em", { key: r3.key }, n2(e2.children, r3)), "l") }, 30: { t: ["\\"], o: Te(te), i: 1, u: __name((e2) => ({ text: e2[1], type: "27" }), "u") }, 31: { t: ["=="], o: Te(ee2), i: 3, u: Ue, l: __name((e2, n2, r3) => J22("mark", { key: r3.key }, n2(e2.children, r3)), "l") }, 32: { t: ["~~"], o: Te(ne), i: 3, u: Ue, l: __name((e2, n2, r3) => J22("del", { key: r3.key }, n2(e2.children, r3)), "l") } };
    t.disableParsingRawHTML === !0 && (delete se2[11], delete se2[13]);
    let fe2 = (function(e2) {
      var n2 = Object.keys(e2);
      function r3(t2, o2) {
        var a22 = [];
        if (o2.prevCapture = o2.prevCapture || "", t2.trim()) for (; t2; ) for (var c22 = 0; c22 < n2.length; ) {
          var i22 = n2[c22], u22 = e2[i22];
          if (!u22.t || Ae(t2, o2, u22.t)) {
            var l2 = u22.o(t2, o2);
            if (l2 && l2[0]) {
              t2 = t2.substring(l2[0].length);
              var s32 = u22.u(l2, r3, o2);
              o2.prevCapture += l2[0], s32.type || (s32.type = i22), a22.push(s32);
              break;
            }
            c22++;
          } else c22++;
        }
        return o2.prevCapture = "", a22;
      }
      return __name(r3, "r"), n2.sort(function(n3, r4) {
        return e2[n3].i - e2[r4].i || (n3 < r4 ? -1 : 1);
      }), function(e3, n3) {
        return r3((function(e4) {
          return e4.replace(x2, `
`).replace($2, "").replace(U2, "    ");
        })(e3), n3);
      };
    })(se2), _e2 = (de2 = /* @__PURE__ */ (function(e2, n2) {
      return function(r3, t2, o2) {
        let a22 = e2[r3.type].l;
        return n2 ? n2(() => a22(r3, t2, o2), r3, t2, o2) : a22(r3, t2, o2);
      };
    })(se2, t.renderRule), __name(function e2(n2, r3 = {}) {
      if (Array.isArray(n2)) {
        let t2 = r3.key, o2 = [], a22 = !1;
        for (let t3 = 0; t3 < n2.length; t3++) {
          r3.key = t3;
          let c22 = e2(n2[t3], r3), i22 = typeof c22 == "string";
          i22 && a22 ? o2[o2.length - 1] += c22 : c22 !== null && o2.push(c22), a22 = i22;
        }
        return r3.key = t2, o2;
      }
      return de2(n2, e2, r3);
    }, "e"));
    var de2;
    let pe2 = K22(r2);
    return ue22.length ? J22("div", null, pe2, J22("footer", { key: "footer" }, ue22.map(function(e2) {
      return J22("div", { id: s22(e2.identifier, Re), key: e2.identifier }, e2.identifier, _e2(fe2(e2.footnote, { inline: !0 })));
    }))) : pe2;
  }
  __name(Je, "Je");
  var index_modern_default = __name((n2) => {
    let { children: t = "", options: o2 } = n2, a22 = (function(e2, n3) {
      if (e2 == null) return {};
      var r2, t2, o3 = {}, a3 = Object.keys(e2);
      for (t2 = 0; t2 < a3.length; t2++) n3.indexOf(r2 = a3[t2]) >= 0 || (o3[r2] = e2[r2]);
      return o3;
    })(n2, r);
    return cloneElement(Je(t, o2), a22);
  }, "default"), Label2 = styled.label(({ theme: theme3 }) => ({
    lineHeight: "18px",
    alignItems: "center",
    marginBottom: 8,
    display: "inline-block",
    position: "relative",
    whiteSpace: "nowrap",
    background: theme3.boolean.background,
    borderRadius: "3em",
    padding: 1,
    '&[aria-disabled="true"]': {
      opacity: 0.5,
      input: {
        cursor: "not-allowed"
      }
    },
    input: {
      appearance: "none",
      width: "100%",
      height: "100%",
      position: "absolute",
      left: 0,
      top: 0,
      margin: 0,
      padding: 0,
      border: "none",
      background: "transparent",
      cursor: "pointer",
      borderRadius: "3em",
      "&:focus": {
        outline: "none",
        boxShadow: `${theme3.color.secondary} 0 0 0 1px inset !important`
      },
      "@media (forced-colors: active)": {
        "&:focus": {
          outline: "1px solid highlight"
        }
      }
    },
    span: {
      textAlign: "center",
      fontSize: theme3.typography.size.s1,
      fontWeight: theme3.typography.weight.bold,
      lineHeight: "1",
      cursor: "pointer",
      display: "inline-block",
      padding: "7px 15px",
      transition: "all 100ms ease-out",
      userSelect: "none",
      borderRadius: "3em",
      color: curriedTransparentize$1(0.5, theme3.color.defaultText),
      background: "transparent",
      "&:hover": {
        boxShadow: `${curriedOpacify$1(0.3, theme3.appBorderColor)} 0 0 0 1px inset`
      },
      "&:active": {
        boxShadow: `${curriedOpacify$1(0.05, theme3.appBorderColor)} 0 0 0 2px inset`,
        color: curriedOpacify$1(1, theme3.appBorderColor)
      },
      "&:first-of-type": {
        paddingRight: 8
      },
      "&:last-of-type": {
        paddingLeft: 8
      }
    },
    "input:checked ~ span:last-of-type, input:not(:checked) ~ span:first-of-type": {
      background: theme3.boolean.selectedBackground,
      boxShadow: theme3.base === "light" ? `${curriedOpacify$1(0.1, theme3.appBorderColor)} 0 0 2px` : `${theme3.appBorderColor} 0 0 0 1px`,
      color: theme3.color.defaultText,
      padding: "7px 15px",
      "@media (forced-colors: active)": {
        textDecoration: "underline"
      }
    }
  })), parse3 = __name((value2) => value2 === "true", "parse"), BooleanControl = __name(({
    name,
    value: value2,
    onChange,
    onBlur,
    onFocus,
    argType
  }) => {
    let onSetFalse = useCallback(() => onChange(!1), [onChange]), readonly = !!argType?.table?.readonly;
    if (value2 === void 0)
      return react_default.createElement(
        Button,
        {
          variant: "outline",
          size: "medium",
          id: getControlSetterButtonId(name),
          onClick: onSetFalse,
          disabled: readonly
        },
        "Set boolean"
      );
    let controlId = getControlId(name), parsedValue = typeof value2 == "string" ? parse3(value2) : value2;
    return react_default.createElement(Label2, { "aria-disabled": readonly, htmlFor: controlId, "aria-label": name }, react_default.createElement(
      "input",
      {
        id: controlId,
        type: "checkbox",
        onChange: (e2) => onChange(e2.target.checked),
        checked: parsedValue,
        role: "switch",
        disabled: readonly,
        name,
        onBlur,
        onFocus
      }
    ), react_default.createElement("span", { "aria-hidden": "true" }, "False"), react_default.createElement("span", { "aria-hidden": "true" }, "True"));
  }, "BooleanControl"), parseDate = __name((value2) => {
    let [year, month, day] = value2.split("-"), result = /* @__PURE__ */ new Date();
    return result.setFullYear(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10)), result;
  }, "parseDate"), parseTime = __name((value2) => {
    let [hours, minutes] = value2.split(":"), result = /* @__PURE__ */ new Date();
    return result.setHours(parseInt(hours, 10)), result.setMinutes(parseInt(minutes, 10)), result;
  }, "parseTime"), formatDate = __name((value2) => {
    let date = new Date(value2), year = `000${date.getFullYear()}`.slice(-4), month = `0${date.getMonth() + 1}`.slice(-2), day = `0${date.getDate()}`.slice(-2);
    return `${year}-${month}-${day}`;
  }, "formatDate"), formatTime = __name((value2) => {
    let date = new Date(value2), hours = `0${date.getHours()}`.slice(-2), minutes = `0${date.getMinutes()}`.slice(-2);
    return `${hours}:${minutes}`;
  }, "formatTime"), FormInput = styled(Form.Input)(({ readOnly }) => ({
    opacity: readOnly ? 0.5 : 1
  })), FlexSpaced = styled.div(({ theme: theme3 }) => ({
    flex: 1,
    display: "flex",
    input: {
      marginLeft: 10,
      flex: 1,
      height: 32,
      // hardcode height bc Chromium bug https://bugs.chromium.org/p/chromium/issues/detail?id=417606
      "&::-webkit-calendar-picker-indicator": {
        opacity: 0.5,
        height: 12,
        filter: theme3.base === "light" ? void 0 : "invert(1)"
      }
    },
    "input:first-of-type": {
      marginLeft: 0,
      flexGrow: 4
    },
    "input:last-of-type": {
      flexGrow: 3
    }
  })), DateControl = __name(({ name, value: value2, onChange, onFocus, onBlur, argType }) => {
    let [valid, setValid] = useState(!0), dateRef = useRef(), timeRef = useRef(), readonly = !!argType?.table?.readonly;
    useEffect(() => {
      valid !== !1 && (dateRef && dateRef.current && (dateRef.current.value = value2 ? formatDate(value2) : ""), timeRef && timeRef.current && (timeRef.current.value = value2 ? formatTime(value2) : ""));
    }, [value2]);
    let onDateChange = __name((e2) => {
      if (!e2.target.value)
        return onChange();
      let parsed = parseDate(e2.target.value), result = new Date(value2 ?? "");
      result.setFullYear(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
      let time = result.getTime();
      time && onChange(time), setValid(!!time);
    }, "onDateChange"), onTimeChange = __name((e2) => {
      if (!e2.target.value)
        return onChange();
      let parsed = parseTime(e2.target.value), result = new Date(value2 ?? "");
      result.setHours(parsed.getHours()), result.setMinutes(parsed.getMinutes());
      let time = result.getTime();
      time && onChange(time), setValid(!!time);
    }, "onTimeChange"), controlId = getControlId(name);
    return react_default.createElement(FlexSpaced, null, react_default.createElement(
      FormInput,
      {
        type: "date",
        max: "9999-12-31",
        ref: dateRef,
        id: `${controlId}-date`,
        name: `${controlId}-date`,
        readOnly: readonly,
        onChange: onDateChange,
        onFocus,
        onBlur
      }
    ), react_default.createElement(
      FormInput,
      {
        type: "time",
        id: `${controlId}-time`,
        name: `${controlId}-time`,
        ref: timeRef,
        onChange: onTimeChange,
        readOnly: readonly,
        onFocus,
        onBlur
      }
    ), valid ? null : react_default.createElement("div", null, "invalid"));
  }, "DateControl"), Wrapper4 = styled.label({
    display: "flex"
  }), parse22 = __name((value2) => {
    let result = parseFloat(value2);
    return Number.isNaN(result) ? void 0 : result;
  }, "parse"), FormInput2 = styled(Form.Input)(({ readOnly }) => ({
    opacity: readOnly ? 0.5 : 1
  })), NumberControl = __name(({
    name,
    value: value2,
    onChange,
    min,
    max,
    step: step2,
    onBlur,
    onFocus,
    argType
  }) => {
    let [inputValue, setInputValue] = useState(typeof value2 == "number" ? value2 : ""), [forceVisible, setForceVisible] = useState(!1), [parseError, setParseError] = useState(null), readonly = !!argType?.table?.readonly, handleChange = useCallback(
      (event) => {
        setInputValue(event.target.value);
        let result = parseFloat(event.target.value);
        if (Number.isNaN(result))
          setParseError(new Error(`'${event.target.value}' is not a number`));
        else {
          let finalValue = result;
          typeof min == "number" && finalValue < min && (finalValue = min), typeof max == "number" && finalValue > max && (finalValue = max), onChange(finalValue), setParseError(null), finalValue !== result && setInputValue(String(finalValue));
        }
      },
      [onChange, setParseError, min, max]
    ), onForceVisible = useCallback(() => {
      setInputValue("0"), onChange(0), setForceVisible(!0);
    }, [setForceVisible]), htmlElRef = useRef(null);
    return useEffect(() => {
      forceVisible && htmlElRef.current && htmlElRef.current.select();
    }, [forceVisible]), useEffect(() => {
      let newInputValue = typeof value2 == "number" ? value2 : "";
      inputValue !== newInputValue && setInputValue(newInputValue);
    }, [value2]), value2 === void 0 ? react_default.createElement(
      Button,
      {
        variant: "outline",
        size: "medium",
        id: getControlSetterButtonId(name),
        onClick: onForceVisible,
        disabled: readonly
      },
      "Set number"
    ) : react_default.createElement(Wrapper4, null, react_default.createElement(
      FormInput2,
      {
        ref: htmlElRef,
        id: getControlId(name),
        type: "number",
        onChange: handleChange,
        size: "flex",
        placeholder: "Edit number...",
        value: inputValue,
        valid: parseError ? "error" : void 0,
        autoFocus: forceVisible,
        readOnly: readonly,
        name,
        min,
        max,
        step: step2,
        onFocus,
        onBlur
      }
    ));
  }, "NumberControl"), selectedKey = __name((value2, options) => {
    let entry = options && Object.entries(options).find(([_key, val]) => val === value2);
    return entry ? entry[0] : void 0;
  }, "selectedKey"), selectedKeys = __name((value2, options) => value2 && options ? Object.entries(options).filter((entry) => value2.includes(entry[1])).map((entry) => entry[0]) : [], "selectedKeys"), selectedValues = __name((keys, options) => keys && options && keys.map((key) => options[key]), "selectedValues"), Wrapper5 = styled.div(
    ({ isInline }) => isInline ? {
      display: "flex",
      flexWrap: "wrap",
      alignItems: "flex-start",
      label: {
        display: "inline-flex",
        marginRight: 15
      }
    } : {
      label: {
        display: "flex"
      }
    },
    (props) => {
      if (props["aria-readonly"] === "true")
        return {
          input: {
            cursor: "not-allowed"
          }
        };
    }
  ), Text = styled.span({
    "[aria-readonly=true] &": {
      opacity: 0.5
    }
  }), Label3 = styled.label({
    lineHeight: "20px",
    alignItems: "center",
    marginBottom: 8,
    "&:last-child": {
      marginBottom: 0
    },
    input: {
      margin: 0,
      marginRight: 6
    }
  }), CheckboxControl = __name(({
    name,
    options,
    value: value2,
    onChange,
    isInline,
    argType
  }) => {
    if (!options)
      return logger.warn(`Checkbox with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-");
    let initial = selectedKeys(value2 || [], options), [selected, setSelected] = useState(initial), readonly = !!argType?.table?.readonly, handleChange = __name((e2) => {
      let option = e2.target.value, updated = [...selected];
      updated.includes(option) ? updated.splice(updated.indexOf(option), 1) : updated.push(option), onChange(selectedValues(updated, options)), setSelected(updated);
    }, "handleChange");
    useEffect(() => {
      setSelected(selectedKeys(value2 || [], options));
    }, [value2]);
    let controlId = getControlId(name);
    return react_default.createElement(Wrapper5, { "aria-readonly": readonly, isInline }, Object.keys(options).map((key, index2) => {
      let id2 = `${controlId}-${index2}`;
      return react_default.createElement(Label3, { key: id2, htmlFor: id2 }, react_default.createElement(
        "input",
        {
          type: "checkbox",
          disabled: readonly,
          id: id2,
          name: id2,
          value: key,
          onChange: handleChange,
          checked: selected?.includes(key)
        }
      ), react_default.createElement(Text, null, key));
    }));
  }, "CheckboxControl"), Wrapper6 = styled.div(
    ({ isInline }) => isInline ? {
      display: "flex",
      flexWrap: "wrap",
      alignItems: "flex-start",
      label: {
        display: "inline-flex",
        marginRight: 15
      }
    } : {
      label: {
        display: "flex"
      }
    },
    (props) => {
      if (props["aria-readonly"] === "true")
        return {
          input: {
            cursor: "not-allowed"
          }
        };
    }
  ), Text2 = styled.span({
    "[aria-readonly=true] &": {
      opacity: 0.5
    }
  }), Label4 = styled.label({
    lineHeight: "20px",
    alignItems: "center",
    marginBottom: 8,
    "&:last-child": {
      marginBottom: 0
    },
    input: {
      margin: 0,
      marginRight: 6
    }
  }), RadioControl = __name(({
    name,
    options,
    value: value2,
    onChange,
    isInline,
    argType
  }) => {
    if (!options)
      return logger.warn(`Radio with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-");
    let selection = selectedKey(value2, options), controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(Wrapper6, { "aria-readonly": readonly, isInline }, Object.keys(options).map((key, index2) => {
      let id2 = `${controlId}-${index2}`;
      return react_default.createElement(Label4, { key: id2, htmlFor: id2 }, react_default.createElement(
        "input",
        {
          type: "radio",
          id: id2,
          name: controlId,
          disabled: readonly,
          value: key,
          onChange: (e2) => onChange(options[e2.currentTarget.value]),
          checked: key === selection
        }
      ), react_default.createElement(Text2, null, key));
    }));
  }, "RadioControl"), styleResets = {
    // resets
    appearance: "none",
    border: "0 none",
    boxSizing: "inherit",
    display: " block",
    margin: " 0",
    background: "transparent",
    padding: 0,
    fontSize: "inherit",
    position: "relative"
  }, OptionsSelect = styled.select(styleResets, ({ theme: theme3 }) => ({
    boxSizing: "border-box",
    position: "relative",
    padding: "6px 10px",
    width: "100%",
    color: theme3.input.color || "inherit",
    background: theme3.input.background,
    borderRadius: theme3.input.borderRadius,
    boxShadow: `${theme3.input.border} 0 0 0 1px inset`,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "20px",
    "&:focus": {
      boxShadow: `${theme3.color.secondary} 0 0 0 1px inset`,
      outline: "none"
    },
    "&[disabled]": {
      cursor: "not-allowed",
      opacity: 0.5
    },
    "::placeholder": {
      color: theme3.textMutedColor
    },
    "&[multiple]": {
      overflow: "auto",
      padding: 0,
      option: {
        display: "block",
        padding: "6px 10px",
        marginLeft: 1,
        marginRight: 1
      }
    }
  })), SelectWrapper = styled.span(({ theme: theme3 }) => ({
    display: "inline-block",
    lineHeight: "normal",
    overflow: "hidden",
    position: "relative",
    verticalAlign: "top",
    width: "100%",
    svg: {
      position: "absolute",
      zIndex: 1,
      pointerEvents: "none",
      height: "12px",
      marginTop: "-6px",
      right: "12px",
      top: "50%",
      fill: theme3.textMutedColor,
      path: {
        fill: theme3.textMutedColor
      }
    }
  })), NO_SELECTION = "Choose option...", SingleSelect = __name(({ name, value: value2, options, onChange, argType }) => {
    let handleChange = __name((e2) => {
      onChange(options[e2.currentTarget.value]);
    }, "handleChange"), selection = selectedKey(value2, options) || NO_SELECTION, controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(SelectWrapper, null, react_default.createElement(ChevronSmallDownIcon, null), react_default.createElement(OptionsSelect, { disabled: readonly, id: controlId, value: selection, onChange: handleChange }, react_default.createElement("option", { key: "no-selection", disabled: !0 }, NO_SELECTION), Object.keys(options).map((key) => react_default.createElement("option", { key, value: key }, key))));
  }, "SingleSelect"), MultiSelect = __name(({ name, value: value2, options, onChange, argType }) => {
    let handleChange = __name((e2) => {
      let selection2 = Array.from(e2.currentTarget.options).filter((option) => option.selected).map((option) => option.value);
      onChange(selectedValues(selection2, options));
    }, "handleChange"), selection = selectedKeys(value2, options), controlId = getControlId(name), readonly = !!argType?.table?.readonly;
    return react_default.createElement(SelectWrapper, null, react_default.createElement(
      OptionsSelect,
      {
        disabled: readonly,
        id: controlId,
        multiple: !0,
        value: selection,
        onChange: handleChange
      },
      Object.keys(options).map((key) => react_default.createElement("option", { key, value: key }, key))
    ));
  }, "MultiSelect"), SelectControl = __name((props) => {
    let { name, options } = props;
    return options ? props.isMulti ? react_default.createElement(MultiSelect, { ...props }) : react_default.createElement(SingleSelect, { ...props }) : (logger.warn(`Select with no options: ${name}`), react_default.createElement(react_default.Fragment, null, "-"));
  }, "SelectControl"), normalizeOptions2 = __name((options, labels) => Array.isArray(options) ? options.reduce((acc, item) => (acc[labels?.[item] || String(item)] = item, acc), {}) : options, "normalizeOptions"), Controls = {
    check: CheckboxControl,
    "inline-check": CheckboxControl,
    radio: RadioControl,
    "inline-radio": RadioControl,
    select: SelectControl,
    "multi-select": SelectControl
  }, OptionsControl = __name((props) => {
    let { type = "select", labels, argType } = props, normalized = {
      ...props,
      argType,
      options: argType ? normalizeOptions2(argType.options, labels) : {},
      isInline: type.includes("inline"),
      isMulti: type.includes("multi")
    }, Control = Controls[type];
    if (Control)
      return react_default.createElement(Control, { ...normalized });
    throw new Error(`Unknown options type: ${type}`);
  }, "OptionsControl"), Container = styled.div(({ theme: theme3 }) => ({
    position: "relative",
    ":hover": {
      "& > .rejt-accordion-button::after": {
        background: theme3.color.secondary
      },
      "& > .rejt-accordion-region > :is(.rejt-plus-menu, .rejt-minus-menu)": {
        opacity: 1
      }
    }
  })), Trigger = styled.button(({ theme: theme3 }) => ({
    padding: 0,
    background: "transparent",
    border: "none",
    marginRight: "3px",
    lineHeight: "22px",
    color: theme3.color.secondary,
    "::after": {
      content: '""',
      position: "absolute",
      top: 0,
      display: "block",
      width: "100%",
      marginLeft: "-1rem",
      height: "22px",
      background: "transparent",
      borderRadius: 4,
      transition: "background 0.2s",
      opacity: 0.1,
      paddingRight: "20px"
    },
    "::before": {
      content: '""',
      position: "absolute"
    },
    '&[aria-expanded="true"]::before': {
      left: -10,
      top: 10,
      borderTop: "3px solid rgba(153,153,153,0.6)",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent"
    },
    '&[aria-expanded="false"]::before': {
      left: -8,
      top: 8,
      borderTop: "3px solid transparent",
      borderBottom: "3px solid transparent",
      borderLeft: "3px solid rgba(153,153,153,0.6)"
    }
  })), Region = styled.div({
    display: "inline"
  });
  function JsonNodeAccordion({
    children,
    name,
    collapsed,
    keyPath,
    deep,
    ...props
  }) {
    let accordionKey = `${keyPath.at(-1) ?? "root"}-${name}-${deep}`, ids = {
      trigger: `${accordionKey}-trigger`,
      region: `${accordionKey}-region`
    }, containerTag = keyPath.length > 0 ? "li" : "div";
    return react_default.createElement(Container, { as: containerTag }, react_default.createElement(
      Trigger,
      {
        type: "button",
        "aria-expanded": !collapsed,
        id: ids.trigger,
        "aria-controls": ids.region,
        className: "rejt-accordion-button",
        ...props
      },
      name,
      " :"
    ), react_default.createElement(
      Region,
      {
        role: "region",
        id: ids.region,
        "aria-labelledby": ids.trigger,
        className: "rejt-accordion-region"
      },
      children
    ));
  }
  __name(JsonNodeAccordion, "JsonNodeAccordion");
  var ERROR = "Error", OBJECT = "Object", ARRAY = "Array", STRING = "String", NUMBER = "Number", BOOLEAN = "Boolean", DATE = "Date", NULL = "Null", UNDEFINED = "Undefined", FUNCTION = "Function", SYMBOL = "Symbol", ADD_DELTA_TYPE = "ADD_DELTA_TYPE", REMOVE_DELTA_TYPE = "REMOVE_DELTA_TYPE", UPDATE_DELTA_TYPE = "UPDATE_DELTA_TYPE", VALUE = "value", KEY2 = "key";
  function getObjectType(obj) {
    return obj !== null && typeof obj == "object" && !Array.isArray(obj) && typeof obj[Symbol.iterator] == "function" ? "Iterable" : Object.prototype.toString.call(obj).slice(8, -1);
  }
  __name(getObjectType, "getObjectType");
  function isComponentWillChange(oldValue, newValue) {
    let oldType = getObjectType(oldValue), newType = getObjectType(newValue);
    return (oldType === "Function" || newType === "Function") && newType !== oldType;
  }
  __name(isComponentWillChange, "isComponentWillChange");
  var _JsonAddValue = class extends Component {
    constructor(props) {
      super(props), this.state = {
        inputRefKey: null,
        inputRefValue: null
      }, this.refInputValue = this.refInputValue.bind(this), this.refInputKey = this.refInputKey.bind(this), this.onKeydown = this.onKeydown.bind(this), this.onSubmit = this.onSubmit.bind(this);
    }
    componentDidMount() {
      let { inputRefKey, inputRefValue } = this.state, { onlyValue } = this.props;
      inputRefKey && typeof inputRefKey.focus == "function" && inputRefKey.focus(), onlyValue && inputRefValue && typeof inputRefValue.focus == "function" && inputRefValue.focus();
    }
    onKeydown(event) {
      if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat)
        return;
      let { inputRefKey, inputRefValue } = this.state, { addButtonElement, handleCancel } = this.props;
      [inputRefKey, inputRefValue, addButtonElement].some(
        (elm) => elm === event.target
      ) && ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.onSubmit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), handleCancel()));
    }
    onSubmit() {
      let { handleAdd, onlyValue, onSubmitValueParser, keyPath, deep } = this.props, { inputRefKey, inputRefValue } = this.state, result = {};
      if (!onlyValue) {
        if (!inputRefKey.value)
          return;
        result.key = inputRefKey.value;
      }
      result.newValue = onSubmitValueParser(!1, keyPath, deep, result.key, inputRefValue.value), handleAdd(result);
    }
    refInputKey(node) {
      this.state.inputRefKey = node;
    }
    refInputValue(node) {
      this.state.inputRefValue = node;
    }
    render() {
      let {
        handleCancel,
        onlyValue,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        keyPath,
        deep
      } = this.props, addButtonElementLayout = addButtonElement && cloneElement(addButtonElement, {
        onClick: this.onSubmit
      }), cancelButtonElementLayout = cancelButtonElement && cloneElement(cancelButtonElement, {
        onClick: handleCancel
      }), inputElementValue = inputElementGenerator(VALUE, keyPath, deep), inputElementValueLayout = cloneElement(inputElementValue, {
        placeholder: "Value",
        ref: this.refInputValue,
        onKeyDown: this.onKeydown
      }), inputElementKeyLayout = null;
      if (!onlyValue) {
        let inputElementKey = inputElementGenerator(KEY2, keyPath, deep);
        inputElementKeyLayout = cloneElement(inputElementKey, {
          placeholder: "Key",
          ref: this.refInputKey,
          onKeyDown: this.onKeydown
        });
      }
      return react_default.createElement("span", { className: "rejt-add-value-node" }, inputElementKeyLayout, inputElementValueLayout, addButtonElementLayout, cancelButtonElementLayout);
    }
  };
  __name(_JsonAddValue, "JsonAddValue");
  var JsonAddValue = _JsonAddValue;
  JsonAddValue.defaultProps = {
    onlyValue: !1,
    addButtonElement: react_default.createElement("button", null, "+"),
    cancelButtonElement: react_default.createElement("button", null, "c")
  };
  var _JsonArray = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        data: props.data,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        nextDeep: (props.deep ?? 0) + 1,
        collapsed: props.isCollapsed(keyPath, props.deep ?? 0, props.data),
        addFormVisible: !1
      }, this.handleCollapseMode = this.handleCollapseMode.bind(this), this.handleRemoveItem = this.handleRemoveItem.bind(this), this.handleAddMode = this.handleAddMode.bind(this), this.handleAddValueAdd = this.handleAddValueAdd.bind(this), this.handleAddValueCancel = this.handleAddValueCancel.bind(this), this.handleEditValue = this.handleEditValue.bind(this), this.onChildUpdate = this.onChildUpdate.bind(this), this.renderCollapsed = this.renderCollapsed.bind(this), this.renderNotCollapsed = this.renderNotCollapsed.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    onChildUpdate(childKey, childData) {
      let { data, keyPath = [] } = this.state;
      data[childKey] = childData, this.setState({
        data
      });
      let { onUpdate } = this.props, size = keyPath.length;
      onUpdate(keyPath[size - 1], data);
    }
    handleAddMode() {
      this.setState({
        addFormVisible: !0
      });
    }
    handleCollapseMode() {
      this.setState((state3) => ({
        collapsed: !state3.collapsed
      }));
    }
    handleRemoveItem(index2) {
      return () => {
        let { beforeRemoveAction, logger: logger5 } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[index2];
        (beforeRemoveAction || Promise.resolve.bind(Promise))(index2, keyPath, deep, oldValue).then(() => {
          let deltaUpdateResult = {
            keyPath,
            deep,
            key: index2,
            oldValue,
            type: REMOVE_DELTA_TYPE
          };
          data.splice(index2, 1), this.setState({ data });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate(deltaUpdateResult);
        }).catch(logger5.error);
      };
    }
    handleAddValueAdd({ newValue }) {
      let { data, keyPath = [], nextDeep: deep } = this.state, { beforeAddAction, logger: logger5 } = this.props, key = data.length;
      (beforeAddAction || Promise.resolve.bind(Promise))(key, keyPath, deep, newValue).then(() => {
        data[key] = newValue, this.setState({
          data
        }), this.handleAddValueCancel();
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
          type: ADD_DELTA_TYPE,
          keyPath,
          deep,
          key,
          newValue
        });
      }).catch(logger5.error);
    }
    handleAddValueCancel() {
      this.setState({
        addFormVisible: !1
      });
    }
    handleEditValue({ key, value: value2 }) {
      return new Promise((resolve, reject) => {
        let { beforeUpdateAction } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[key];
        (beforeUpdateAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue, value2).then(() => {
          data[key] = value2, this.setState({
            data
          });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
            type: UPDATE_DELTA_TYPE,
            keyPath,
            deep,
            key,
            newValue: value2,
            oldValue
          }), resolve(void 0);
        }).catch(reject);
      });
    }
    renderCollapsed() {
      let { name, data, keyPath, deep } = this.state, { handleRemove, readOnly, getStyle, dataType, minusMenuElement } = this.props, { minus, collapsed } = getStyle(name, data, keyPath, deep, dataType), isReadOnly = readOnly(name, data, keyPath, deep, dataType), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the array '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: collapsed }, "[...] ", data.length, " ", data.length === 1 ? "item" : "items"), !isReadOnly && removeItemButton);
    }
    renderNotCollapsed() {
      let { name, data, keyPath, deep, addFormVisible, nextDeep } = this.state, {
        isCollapsed,
        handleRemove,
        onDeltaUpdate,
        readOnly,
        getStyle,
        dataType,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, { minus, plus, delimiter, ul, addForm } = getStyle(name, data, keyPath, deep, dataType), isReadOnly = readOnly(name, data, keyPath, deep, dataType), addItemButton = plusMenuElement && cloneElement(plusMenuElement, {
        onClick: this.handleAddMode,
        className: "rejt-plus-menu",
        style: plus,
        "aria-label": `add a new item to the '${String(name)}' array`
      }), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the array '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "["), !addFormVisible && addItemButton, react_default.createElement("ul", { className: "rejt-not-collapsed-list", style: ul }, data.map((item, index2) => react_default.createElement(
        JsonNode,
        {
          key: index2,
          name: index2.toString(),
          data: item,
          keyPath,
          deep: nextDeep,
          isCollapsed,
          handleRemove: this.handleRemoveItem(index2),
          handleUpdateValue: this.handleEditValue,
          onUpdate: this.onChildUpdate,
          onDeltaUpdate,
          readOnly,
          getStyle,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          textareaElementGenerator,
          minusMenuElement,
          plusMenuElement,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5,
          onSubmitValueParser
        }
      ))), !isReadOnly && addFormVisible && react_default.createElement("div", { className: "rejt-add-form", style: addForm }, react_default.createElement(
        JsonAddValue,
        {
          handleAdd: this.handleAddValueAdd,
          handleCancel: this.handleAddValueCancel,
          onlyValue: !0,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          keyPath,
          deep,
          onSubmitValueParser
        }
      )), react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "]"), !isReadOnly && removeItemButton);
    }
    render() {
      let { name, collapsed, keyPath, deep } = this.state, value2 = collapsed ? this.renderCollapsed() : this.renderNotCollapsed();
      return react_default.createElement(
        JsonNodeAccordion,
        {
          name,
          collapsed,
          deep,
          keyPath,
          onClick: this.handleCollapseMode
        },
        value2
      );
    }
  };
  __name(_JsonArray, "JsonArray");
  var JsonArray = _JsonArray;
  JsonArray.defaultProps = {
    keyPath: [],
    deep: 0,
    minusMenuElement: react_default.createElement("span", null, " - "),
    plusMenuElement: react_default.createElement("span", null, " + ")
  };
  var _JsonFunctionValue = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        value: props.value,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        editEnabled: !1,
        inputRef: null
      }, this.handleEditMode = this.handleEditMode.bind(this), this.refInput = this.refInput.bind(this), this.handleCancelEdit = this.handleCancelEdit.bind(this), this.handleEdit = this.handleEdit.bind(this), this.onKeydown = this.onKeydown.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.value !== state3.value ? { value: props.value } : null;
    }
    componentDidUpdate() {
      let { editEnabled, inputRef, name, value: value2, keyPath, deep } = this.state, { readOnly, dataType } = this.props, readOnlyResult = readOnly(name, value2, keyPath, deep, dataType);
      editEnabled && !readOnlyResult && typeof inputRef.focus == "function" && inputRef.focus();
    }
    onKeydown(event) {
      let { inputRef } = this.state;
      event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || inputRef !== event.target || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.handleEdit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.handleCancelEdit()));
    }
    handleEdit() {
      let { handleUpdateValue, originalValue, logger: logger5, onSubmitValueParser, keyPath } = this.props, { inputRef, name, deep } = this.state;
      if (!inputRef)
        return;
      let newValue = onSubmitValueParser(!0, keyPath, deep, name, inputRef.value), result = {
        value: newValue,
        key: name
      };
      (handleUpdateValue || Promise.resolve.bind(Promise))(result).then(() => {
        isComponentWillChange(originalValue, newValue) || this.handleCancelEdit();
      }).catch(logger5.error);
    }
    handleEditMode() {
      this.setState({
        editEnabled: !0
      });
    }
    refInput(node) {
      this.state.inputRef = node;
    }
    handleCancelEdit() {
      this.setState({
        editEnabled: !1
      });
    }
    render() {
      let { name, value: value2, editEnabled, keyPath, deep } = this.state, {
        handleRemove,
        originalValue,
        readOnly,
        dataType,
        getStyle,
        textareaElementGenerator,
        minusMenuElement,
        keyPath: comeFromKeyPath = []
      } = this.props, style = getStyle(name, originalValue, keyPath, deep, dataType), result = null, minusElement = null, resultOnlyResult = readOnly(name, originalValue, keyPath, deep, dataType);
      if (editEnabled && !resultOnlyResult) {
        let textareaElement = textareaElementGenerator(
          VALUE,
          comeFromKeyPath,
          deep,
          name,
          originalValue,
          dataType
        ), textareaElementLayout = cloneElement(textareaElement, {
          ref: this.refInput,
          defaultValue: value2,
          onKeyDown: this.onKeydown
        });
        result = react_default.createElement("span", { className: "rejt-edit-form", style: style.editForm }, textareaElementLayout), minusElement = null;
      } else {
        result = react_default.createElement(
          "span",
          {
            className: "rejt-value",
            style: style.value,
            onClick: resultOnlyResult ? void 0 : this.handleEditMode
          },
          value2
        );
        let parentPropertyName = comeFromKeyPath.at(-1), minusMenuLayout = minusMenuElement && cloneElement(minusMenuElement, {
          onClick: handleRemove,
          className: "rejt-minus-menu",
          style: style.minus,
          "aria-label": `remove the function '${String(name)}'${String(parentPropertyName) ? ` from '${String(parentPropertyName)}'` : ""}`
        });
        minusElement = resultOnlyResult ? null : minusMenuLayout;
      }
      return react_default.createElement("li", { className: "rejt-value-node", style: style.li }, react_default.createElement("span", { className: "rejt-name", style: style.name }, name, " :", " "), result, minusElement);
    }
  };
  __name(_JsonFunctionValue, "JsonFunctionValue");
  var JsonFunctionValue = _JsonFunctionValue;
  JsonFunctionValue.defaultProps = {
    keyPath: [],
    deep: 0,
    handleUpdateValue: __name(() => {
    }, "handleUpdateValue"),
    cancelButtonElement: react_default.createElement("button", null, "c"),
    minusMenuElement: react_default.createElement("span", null, " - ")
  };
  var _JsonNode = class extends Component {
    constructor(props) {
      super(props), this.state = {
        data: props.data,
        name: props.name,
        keyPath: props.keyPath ?? [],
        deep: props.deep ?? 0
      };
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    render() {
      let { data, name, keyPath, deep } = this.state, {
        isCollapsed,
        handleRemove,
        handleUpdateValue,
        onUpdate,
        onDeltaUpdate,
        readOnly,
        getStyle,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, readOnlyTrue = __name(() => !0, "readOnlyTrue"), dataType = getObjectType(data);
      switch (dataType) {
        case ERROR:
          return react_default.createElement(
            JsonObject,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case OBJECT:
          return react_default.createElement(
            JsonObject,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case ARRAY:
          return react_default.createElement(
            JsonArray,
            {
              data,
              name,
              isCollapsed,
              keyPath,
              deep,
              handleRemove,
              onUpdate,
              onDeltaUpdate,
              readOnly,
              dataType,
              getStyle,
              addButtonElement,
              cancelButtonElement,
              inputElementGenerator,
              textareaElementGenerator,
              minusMenuElement,
              plusMenuElement,
              beforeRemoveAction,
              beforeAddAction,
              beforeUpdateAction,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case STRING:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: `"${data}"`,
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case NUMBER:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data,
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case BOOLEAN:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data ? "true" : "false",
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case DATE:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data.toISOString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case NULL:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: "null",
              originalValue: "null",
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case UNDEFINED:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: "undefined",
              originalValue: "undefined",
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case FUNCTION:
          return react_default.createElement(
            JsonFunctionValue,
            {
              name,
              value: data.toString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly,
              dataType,
              getStyle,
              cancelButtonElement,
              textareaElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        case SYMBOL:
          return react_default.createElement(
            JsonValue,
            {
              name,
              value: data.toString(),
              originalValue: data,
              keyPath,
              deep,
              handleRemove,
              handleUpdateValue,
              readOnly: readOnlyTrue,
              dataType,
              getStyle,
              cancelButtonElement,
              inputElementGenerator,
              minusMenuElement,
              logger: logger5,
              onSubmitValueParser
            }
          );
        default:
          return null;
      }
    }
  };
  __name(_JsonNode, "JsonNode");
  var JsonNode = _JsonNode;
  JsonNode.defaultProps = {
    keyPath: [],
    deep: 0
  };
  var _JsonObject = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = props.deep === -1 ? [] : [...props.keyPath || [], props.name];
      this.state = {
        name: props.name,
        data: props.data,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        nextDeep: (props.deep ?? 0) + 1,
        collapsed: props.isCollapsed(keyPath, props.deep ?? 0, props.data),
        addFormVisible: !1
      }, this.handleCollapseMode = this.handleCollapseMode.bind(this), this.handleRemoveValue = this.handleRemoveValue.bind(this), this.handleAddMode = this.handleAddMode.bind(this), this.handleAddValueAdd = this.handleAddValueAdd.bind(this), this.handleAddValueCancel = this.handleAddValueCancel.bind(this), this.handleEditValue = this.handleEditValue.bind(this), this.onChildUpdate = this.onChildUpdate.bind(this), this.renderCollapsed = this.renderCollapsed.bind(this), this.renderNotCollapsed = this.renderNotCollapsed.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data ? { data: props.data } : null;
    }
    onChildUpdate(childKey, childData) {
      let { data, keyPath = [] } = this.state;
      data[childKey] = childData, this.setState({
        data
      });
      let { onUpdate } = this.props, size = keyPath.length;
      onUpdate(keyPath[size - 1], data);
    }
    handleAddMode() {
      this.setState({
        addFormVisible: !0
      });
    }
    handleAddValueCancel() {
      this.setState({
        addFormVisible: !1
      });
    }
    handleAddValueAdd({ key, newValue }) {
      let { data, keyPath = [], nextDeep: deep } = this.state, { beforeAddAction, logger: logger5 } = this.props;
      (beforeAddAction || Promise.resolve.bind(Promise))(key, keyPath, deep, newValue).then(() => {
        data[key] = newValue, this.setState({
          data
        }), this.handleAddValueCancel();
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
          type: ADD_DELTA_TYPE,
          keyPath,
          deep,
          key,
          newValue
        });
      }).catch(logger5.error);
    }
    handleRemoveValue(key) {
      return () => {
        let { beforeRemoveAction, logger: logger5 } = this.props, { data, keyPath = [], nextDeep: deep } = this.state, oldValue = data[key];
        (beforeRemoveAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue).then(() => {
          let deltaUpdateResult = {
            keyPath,
            deep,
            key,
            oldValue,
            type: REMOVE_DELTA_TYPE
          };
          delete data[key], this.setState({ data });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate(deltaUpdateResult);
        }).catch(logger5.error);
      };
    }
    handleCollapseMode() {
      this.setState((state3) => ({
        collapsed: !state3.collapsed
      }));
    }
    handleEditValue({ key, value: value2 }) {
      return new Promise((resolve, reject) => {
        let { beforeUpdateAction } = this.props, { data, keyPath = [], nextDeep: deep } = this.state, oldValue = data[key];
        (beforeUpdateAction || Promise.resolve.bind(Promise))(key, keyPath, deep, oldValue, value2).then(() => {
          data[key] = value2, this.setState({
            data
          });
          let { onUpdate, onDeltaUpdate } = this.props;
          onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({
            type: UPDATE_DELTA_TYPE,
            keyPath,
            deep,
            key,
            newValue: value2,
            oldValue
          }), resolve();
        }).catch(reject);
      });
    }
    renderCollapsed() {
      let { name, keyPath, deep, data } = this.state, { handleRemove, readOnly, dataType, getStyle, minusMenuElement } = this.props, { minus, collapsed } = getStyle(name, data, keyPath, deep, dataType), keyList = Object.getOwnPropertyNames(data), isReadOnly = readOnly(name, data, keyPath, deep, dataType), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the object '${String(name)}'`
      });
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: collapsed }, "{...}", " ", keyList.length, " ", keyList.length === 1 ? "key" : "keys"), !isReadOnly && removeItemButton);
    }
    renderNotCollapsed() {
      let { name, data, keyPath, deep, nextDeep, addFormVisible } = this.state, {
        isCollapsed,
        handleRemove,
        onDeltaUpdate,
        readOnly,
        getStyle,
        dataType,
        addButtonElement,
        cancelButtonElement,
        inputElementGenerator,
        textareaElementGenerator,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser
      } = this.props, { minus, plus, addForm, ul, delimiter } = getStyle(name, data, keyPath, deep, dataType), keyList = Object.getOwnPropertyNames(data), isReadOnly = readOnly(name, data, keyPath, deep, dataType), addItemButton = plusMenuElement && cloneElement(plusMenuElement, {
        onClick: this.handleAddMode,
        className: "rejt-plus-menu",
        style: plus,
        "aria-label": `add a new property to the object '${String(name)}'`
      }), removeItemButton = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: minus,
        "aria-label": `remove the object '${String(name)}'`
      }), list = keyList.map((key) => react_default.createElement(
        JsonNode,
        {
          key,
          name: key,
          data: data[key],
          keyPath,
          deep: nextDeep,
          isCollapsed,
          handleRemove: this.handleRemoveValue(key),
          handleUpdateValue: this.handleEditValue,
          onUpdate: this.onChildUpdate,
          onDeltaUpdate,
          readOnly,
          getStyle,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          textareaElementGenerator,
          minusMenuElement,
          plusMenuElement,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5,
          onSubmitValueParser
        }
      ));
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "{"), !isReadOnly && addItemButton, react_default.createElement("ul", { className: "rejt-not-collapsed-list", style: ul }, list), !isReadOnly && addFormVisible && react_default.createElement("div", { className: "rejt-add-form", style: addForm }, react_default.createElement(
        JsonAddValue,
        {
          handleAdd: this.handleAddValueAdd,
          handleCancel: this.handleAddValueCancel,
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator,
          keyPath,
          deep,
          onSubmitValueParser
        }
      )), react_default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "}"), !isReadOnly && removeItemButton);
    }
    render() {
      let { name, collapsed, keyPath, deep = 0 } = this.state, value2 = collapsed ? this.renderCollapsed() : this.renderNotCollapsed();
      return react_default.createElement(
        JsonNodeAccordion,
        {
          name,
          collapsed,
          deep,
          keyPath,
          onClick: this.handleCollapseMode
        },
        value2
      );
    }
  };
  __name(_JsonObject, "JsonObject");
  var JsonObject = _JsonObject;
  JsonObject.defaultProps = {
    keyPath: [],
    deep: 0,
    minusMenuElement: react_default.createElement("span", null, " - "),
    plusMenuElement: react_default.createElement("span", null, " + ")
  };
  var _JsonValue = class extends Component {
    constructor(props) {
      super(props);
      let keyPath = [...props.keyPath || [], props.name];
      this.state = {
        value: props.value,
        name: props.name,
        keyPath: keyPath ?? [],
        deep: props.deep ?? 0,
        editEnabled: !1,
        inputRef: null
      }, this.handleEditMode = this.handleEditMode.bind(this), this.refInput = this.refInput.bind(this), this.handleCancelEdit = this.handleCancelEdit.bind(this), this.handleEdit = this.handleEdit.bind(this), this.onKeydown = this.onKeydown.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.value !== state3.value ? { value: props.value } : null;
    }
    componentDidUpdate() {
      let { editEnabled, inputRef, name, value: value2, keyPath, deep } = this.state, { readOnly, dataType } = this.props, isReadOnly = readOnly(name, value2, keyPath, deep, dataType);
      editEnabled && !isReadOnly && typeof inputRef.focus == "function" && inputRef.focus();
    }
    onKeydown(event) {
      let { inputRef } = this.state;
      event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || inputRef !== event.target || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.handleEdit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.handleCancelEdit()));
    }
    handleEdit() {
      let { handleUpdateValue, originalValue, logger: logger5, onSubmitValueParser, keyPath } = this.props, { inputRef, name, deep } = this.state;
      if (!inputRef)
        return;
      let newValue = onSubmitValueParser(!0, keyPath, deep, name, inputRef.value), result = {
        value: newValue,
        key: name
      };
      (handleUpdateValue || Promise.resolve.bind(Promise))(result).then(() => {
        isComponentWillChange(originalValue, newValue) || this.handleCancelEdit();
      }).catch(logger5.error);
    }
    handleEditMode() {
      this.setState({
        editEnabled: !0
      });
    }
    refInput(node) {
      this.state.inputRef = node;
    }
    handleCancelEdit() {
      this.setState({
        editEnabled: !1
      });
    }
    render() {
      let { name, value: value2, editEnabled, keyPath, deep } = this.state, {
        handleRemove,
        originalValue,
        readOnly,
        dataType,
        getStyle,
        inputElementGenerator,
        minusMenuElement,
        keyPath: comeFromKeyPath
      } = this.props, style = getStyle(name, originalValue, keyPath, deep, dataType), isReadOnly = readOnly(name, originalValue, keyPath, deep, dataType), isEditing = editEnabled && !isReadOnly, inputElement = inputElementGenerator(
        VALUE,
        comeFromKeyPath,
        deep,
        name,
        originalValue,
        dataType
      ), inputElementLayout = cloneElement(inputElement, {
        ref: this.refInput,
        defaultValue: JSON.stringify(originalValue),
        onKeyDown: this.onKeydown
      }), parentPropertyName = keyPath.at(-2), minusMenuLayout = minusMenuElement && cloneElement(minusMenuElement, {
        onClick: handleRemove,
        className: "rejt-minus-menu",
        style: style.minus,
        "aria-label": `remove the property '${String(name)}' with value '${String(originalValue)}'${String(parentPropertyName) ? ` from '${String(parentPropertyName)}'` : ""}`
      });
      return react_default.createElement("li", { className: "rejt-value-node", style: style.li }, react_default.createElement("span", { className: "rejt-name", style: style.name }, name, " : "), isEditing ? react_default.createElement("span", { className: "rejt-edit-form", style: style.editForm }, inputElementLayout) : react_default.createElement(
        "span",
        {
          className: "rejt-value",
          style: style.value,
          onClick: isReadOnly ? void 0 : this.handleEditMode
        },
        String(value2)
      ), !isReadOnly && !isEditing && minusMenuLayout);
    }
  };
  __name(_JsonValue, "JsonValue");
  var JsonValue = _JsonValue;
  JsonValue.defaultProps = {
    keyPath: [],
    deep: 0,
    handleUpdateValue: __name(() => Promise.resolve(), "handleUpdateValue"),
    cancelButtonElement: react_default.createElement("button", null, "c"),
    minusMenuElement: react_default.createElement("span", null, " - ")
  };
  function parse32(string) {
    let result = string;
    if (result.indexOf("function") === 0)
      return (0, eval)(`(${result})`);
    try {
      result = JSON.parse(string);
    } catch {
    }
    return result;
  }
  __name(parse32, "parse");
  var object = {
    minus: {
      color: "red"
    },
    plus: {
      color: "green"
    },
    collapsed: {
      color: "grey"
    },
    delimiter: {},
    ul: {
      padding: "0px",
      margin: "0 0 0 25px",
      listStyle: "none"
    },
    name: {
      color: "#2287CD"
    },
    addForm: {}
  }, array = {
    minus: {
      color: "red"
    },
    plus: {
      color: "green"
    },
    collapsed: {
      color: "grey"
    },
    delimiter: {},
    ul: {
      padding: "0px",
      margin: "0 0 0 25px",
      listStyle: "none"
    },
    name: {
      color: "#2287CD"
    },
    addForm: {}
  }, value = {
    minus: {
      color: "red"
    },
    editForm: {},
    value: {
      color: "#7bba3d"
    },
    li: {
      minHeight: "22px",
      lineHeight: "22px",
      outline: "0px"
    },
    name: {
      color: "#2287CD"
    }
  }, _JsonTree = class extends Component {
    constructor(props) {
      super(props), this.state = {
        data: props.data,
        rootName: props.rootName
      }, this.onUpdate = this.onUpdate.bind(this), this.removeRoot = this.removeRoot.bind(this);
    }
    static getDerivedStateFromProps(props, state3) {
      return props.data !== state3.data || props.rootName !== state3.rootName ? {
        data: props.data,
        rootName: props.rootName
      } : null;
    }
    onUpdate(key, data) {
      this.setState({ data }), this.props.onFullyUpdate?.(data);
    }
    removeRoot() {
      this.onUpdate(null, null);
    }
    render() {
      let { data, rootName } = this.state, {
        isCollapsed,
        onDeltaUpdate,
        readOnly,
        getStyle,
        addButtonElement,
        cancelButtonElement,
        inputElement,
        textareaElement,
        minusMenuElement,
        plusMenuElement,
        beforeRemoveAction,
        beforeAddAction,
        beforeUpdateAction,
        logger: logger5,
        onSubmitValueParser,
        fallback = null
      } = this.props, dataType = getObjectType(data), readOnlyFunction = readOnly;
      getObjectType(readOnly) === "Boolean" && (readOnlyFunction = __name(() => readOnly, "readOnlyFunction"));
      let inputElementFunction = inputElement;
      inputElement && getObjectType(inputElement) !== "Function" && (inputElementFunction = __name(() => inputElement, "inputElementFunction"));
      let textareaElementFunction = textareaElement;
      return textareaElement && getObjectType(textareaElement) !== "Function" && (textareaElementFunction = __name(() => textareaElement, "textareaElementFunction")), dataType === "Object" || dataType === "Array" ? react_default.createElement("div", { className: "rejt-tree" }, react_default.createElement(
        JsonNode,
        {
          data,
          name: rootName || "root",
          deep: -1,
          isCollapsed: isCollapsed ?? (() => !1),
          onUpdate: this.onUpdate,
          onDeltaUpdate: onDeltaUpdate ?? (() => {
          }),
          readOnly: readOnlyFunction,
          getStyle: getStyle ?? (() => ({})),
          addButtonElement,
          cancelButtonElement,
          inputElementGenerator: inputElementFunction,
          textareaElementGenerator: textareaElementFunction,
          minusMenuElement,
          plusMenuElement,
          handleRemove: this.removeRoot,
          beforeRemoveAction,
          beforeAddAction,
          beforeUpdateAction,
          logger: logger5 ?? {},
          onSubmitValueParser: onSubmitValueParser ?? ((val) => val)
        }
      )) : fallback;
    }
  };
  __name(_JsonTree, "JsonTree");
  var JsonTree = _JsonTree;
  JsonTree.defaultProps = {
    rootName: "root",
    isCollapsed: __name((keyPath, deep) => deep !== -1, "isCollapsed"),
    getStyle: __name((keyName, data, keyPath, deep, dataType) => {
      switch (dataType) {
        case "Object":
        case "Error":
          return object;
        case "Array":
          return array;
        default:
          return value;
      }
    }, "getStyle"),
    readOnly: __name(() => !1, "readOnly"),
    onFullyUpdate: __name(() => {
    }, "onFullyUpdate"),
    onDeltaUpdate: __name(() => {
    }, "onDeltaUpdate"),
    beforeRemoveAction: __name(() => Promise.resolve(), "beforeRemoveAction"),
    beforeAddAction: __name(() => Promise.resolve(), "beforeAddAction"),
    beforeUpdateAction: __name(() => Promise.resolve(), "beforeUpdateAction"),
    logger: { error: __name(() => {
    }, "error") },
    onSubmitValueParser: __name((isEditMode, keyPath, deep, name, rawValue) => parse32(rawValue), "onSubmitValueParser"),
    inputElement: __name(() => react_default.createElement("input", null), "inputElement"),
    textareaElement: __name(() => react_default.createElement("textarea", null), "textareaElement"),
    fallback: null
  };
  var { window: globalWindow22 } = globalThis, Wrapper7 = styled.div(({ theme: theme3 }) => ({
    position: "relative",
    display: "flex",
    '&[aria-readonly="true"]': {
      opacity: 0.5
    },
    ".rejt-tree": {
      marginLeft: "1rem",
      fontSize: "13px",
      listStyleType: "none"
    },
    ".rejt-value-node:hover": {
      "& > button": {
        opacity: 1
      }
    },
    ".rejt-add-form": {
      marginLeft: 10
    },
    ".rejt-add-value-node": {
      display: "inline-flex",
      alignItems: "center"
    },
    ".rejt-name": {
      lineHeight: "22px"
    },
    ".rejt-not-collapsed-delimiter": {
      lineHeight: "22px"
    },
    ".rejt-value": {
      display: "inline-block",
      border: "1px solid transparent",
      borderRadius: 4,
      margin: "1px 0",
      padding: "0 4px",
      cursor: "text",
      color: theme3.color.defaultText
    },
    ".rejt-value-node:hover > .rejt-value": {
      background: theme3.color.lighter,
      borderColor: theme3.appBorderColor
    }
  })), ButtonInline = styled.button(({ theme: theme3, primary }) => ({
    border: 0,
    height: 20,
    margin: 1,
    borderRadius: 4,
    background: primary ? theme3.color.secondary : "transparent",
    color: primary ? theme3.color.lightest : theme3.color.dark,
    fontWeight: primary ? "bold" : "normal",
    cursor: "pointer"
  })), ActionButton = styled.button(({ theme: theme3 }) => ({
    background: "none",
    border: 0,
    display: "inline-flex",
    verticalAlign: "middle",
    padding: 3,
    marginLeft: 5,
    color: theme3.textMutedColor,
    opacity: 0,
    transition: "opacity 0.2s",
    cursor: "pointer",
    position: "relative",
    svg: {
      width: 9,
      height: 9
    },
    ":disabled": {
      cursor: "not-allowed"
    },
    ":hover, :focus-visible": {
      opacity: 1
    },
    "&:hover:not(:disabled), &:focus-visible:not(:disabled)": {
      "&.rejt-plus-menu": {
        color: theme3.color.ancillary
      },
      "&.rejt-minus-menu": {
        color: theme3.color.negative
      }
    }
  })), Input2 = styled.input(({ theme: theme3, placeholder }) => ({
    outline: 0,
    margin: placeholder ? 1 : "1px 0",
    padding: "3px 4px",
    color: theme3.color.defaultText,
    background: theme3.background.app,
    border: `1px solid ${theme3.appBorderColor}`,
    borderRadius: 4,
    lineHeight: "14px",
    width: placeholder === "Key" ? 80 : 120,
    "&:focus": {
      border: `1px solid ${theme3.color.secondary}`
    }
  })), RawButton = styled(IconButton)(({ theme: theme3 }) => ({
    position: "absolute",
    zIndex: 2,
    top: 2,
    right: 2,
    height: 21,
    padding: "0 3px",
    background: theme3.background.bar,
    border: `1px solid ${theme3.appBorderColor}`,
    borderRadius: 3,
    color: theme3.textMutedColor,
    fontSize: "9px",
    fontWeight: "bold",
    textDecoration: "none",
    span: {
      marginLeft: 3,
      marginTop: 1
    }
  })), RawInput = styled(Form.Textarea)(({ theme: theme3 }) => ({
    flex: 1,
    padding: "7px 6px",
    fontFamily: theme3.typography.fonts.mono,
    fontSize: "12px",
    lineHeight: "18px",
    "&::placeholder": {
      fontFamily: theme3.typography.fonts.base,
      fontSize: "13px"
    },
    "&:placeholder-shown": {
      padding: "7px 10px"
    }
  })), ENTER_EVENT = {
    bubbles: !0,
    cancelable: !0,
    key: "Enter",
    code: "Enter",
    keyCode: 13
  }, dispatchEnterKey = __name((event) => {
    event.currentTarget.dispatchEvent(new globalWindow22.KeyboardEvent("keydown", ENTER_EVENT));
  }, "dispatchEnterKey"), selectValue = __name((event) => {
    event.currentTarget.select();
  }, "selectValue"), getCustomStyleFunction = __name((theme3) => () => ({
    name: {
      color: theme3.color.secondary
    },
    collapsed: {
      color: theme3.color.dark
    },
    ul: {
      listStyle: "none",
      margin: "0 0 0 1rem",
      padding: 0
    },
    li: {
      outline: 0
    }
  }), "getCustomStyleFunction"), ObjectControl = __name(({ name, value: value2, onChange, argType }) => {
    let theme3 = useTheme(), data = useMemo(() => value2 && cloneDeep(value2), [value2]), hasData = data != null, [showRaw, setShowRaw] = useState(!hasData), [parseError, setParseError] = useState(null), readonly = !!argType?.table?.readonly, updateRaw = useCallback(
      (raw) => {
        try {
          raw && onChange(JSON.parse(raw)), setParseError(null);
        } catch (e2) {
          setParseError(e2);
        }
      },
      [onChange]
    ), [forceVisible, setForceVisible] = useState(!1), onForceVisible = useCallback(() => {
      onChange({}), setForceVisible(!0);
    }, [setForceVisible]), htmlElRef = useRef(null);
    if (useEffect(() => {
      forceVisible && htmlElRef.current && htmlElRef.current.select();
    }, [forceVisible]), !hasData)
      return react_default.createElement(Button, { disabled: readonly, id: getControlSetterButtonId(name), onClick: onForceVisible }, "Set object");
    let rawJSONForm = react_default.createElement(
      RawInput,
      {
        ref: htmlElRef,
        id: getControlId(name),
        name,
        defaultValue: value2 === null ? "" : JSON.stringify(value2, null, 2),
        onBlur: (event) => updateRaw(event.target.value),
        placeholder: "Edit JSON string...",
        autoFocus: forceVisible,
        valid: parseError ? "error" : void 0,
        readOnly: readonly
      }
    ), isObjectOrArray = Array.isArray(value2) || typeof value2 == "object" && value2?.constructor === Object;
    return react_default.createElement(Wrapper7, { "aria-readonly": readonly }, isObjectOrArray && react_default.createElement(
      RawButton,
      {
        role: "switch",
        "aria-checked": showRaw,
        "aria-label": `Edit the ${name} properties in text format`,
        onClick: (e2) => {
          e2.preventDefault(), setShowRaw((isRaw) => !isRaw);
        }
      },
      showRaw ? react_default.createElement(EyeCloseIcon, null) : react_default.createElement(EyeIcon, null),
      react_default.createElement("span", null, "RAW")
    ), showRaw ? rawJSONForm : react_default.createElement(
      JsonTree,
      {
        readOnly: readonly || !isObjectOrArray,
        isCollapsed: isObjectOrArray ? (
          /* default value */
          void 0
        ) : () => !0,
        data,
        rootName: name,
        onFullyUpdate: onChange,
        getStyle: getCustomStyleFunction(theme3),
        cancelButtonElement: react_default.createElement(ButtonInline, { type: "button" }, "Cancel"),
        addButtonElement: react_default.createElement(ButtonInline, { type: "submit", primary: !0 }, "Save"),
        plusMenuElement: react_default.createElement(ActionButton, { type: "button" }, react_default.createElement(AddIcon, null)),
        minusMenuElement: react_default.createElement(ActionButton, { type: "button" }, react_default.createElement(SubtractIcon, null)),
        inputElement: (_22, __, ___, key) => key ? react_default.createElement(Input2, { onFocus: selectValue, onBlur: dispatchEnterKey }) : react_default.createElement(Input2, null),
        fallback: rawJSONForm
      }
    ));
  }, "ObjectControl"), RangeInput = styled.input(
    ({ theme: theme3, min, max, value: value2, disabled }) => ({
      // Resytled using http://danielstern.ca/range.css/#/
      "&": {
        width: "100%",
        backgroundColor: "transparent",
        appearance: "none"
      },
      "&::-webkit-slider-runnable-track": {
        background: theme3.base === "light" ? `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} 100%)`,
        boxShadow: `${theme3.appBorderColor} 0 0 0 1px inset`,
        borderRadius: 6,
        width: "100%",
        height: 6,
        cursor: disabled ? "not-allowed" : "pointer"
      },
      "&::-webkit-slider-thumb": {
        marginTop: "-6px",
        width: 16,
        height: 16,
        border: `1px solid ${rgba(theme3.appBorderColor, 0.2)}`,
        borderRadius: "50px",
        boxShadow: `0 1px 3px 0px ${rgba(theme3.appBorderColor, 0.2)}`,
        cursor: disabled ? "not-allowed" : "grab",
        appearance: "none",
        background: `${theme3.input.background}`,
        transition: "all 150ms ease-out",
        "&:hover": {
          background: `${curriedDarken$1(0.05, theme3.input.background)}`,
          transform: "scale3d(1.1, 1.1, 1.1) translateY(-1px)",
          transition: "all 50ms ease-out"
        },
        "&:active": {
          background: `${theme3.input.background}`,
          transform: "scale3d(1, 1, 1) translateY(0px)",
          cursor: disabled ? "not-allowed" : "grab"
        }
      },
      "&:focus": {
        outline: "none",
        "&::-webkit-slider-runnable-track": {
          borderColor: rgba(theme3.color.secondary, 0.4)
        },
        "&::-webkit-slider-thumb": {
          borderColor: theme3.color.secondary,
          boxShadow: `0 0px 5px 0px ${theme3.color.secondary}`
        }
      },
      "&::-moz-range-track": {
        background: theme3.base === "light" ? `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} 100%)`,
        boxShadow: `${theme3.appBorderColor} 0 0 0 1px inset`,
        borderRadius: 6,
        width: "100%",
        height: 6,
        cursor: disabled ? "not-allowed" : "pointer",
        outline: "none"
      },
      "&::-moz-range-thumb": {
        width: 16,
        height: 16,
        border: `1px solid ${rgba(theme3.appBorderColor, 0.2)}`,
        borderRadius: "50px",
        boxShadow: `0 1px 3px 0px ${rgba(theme3.appBorderColor, 0.2)}`,
        cursor: disabled ? "not-allowed" : "grap",
        background: `${theme3.input.background}`,
        transition: "all 150ms ease-out",
        "&:hover": {
          background: `${curriedDarken$1(0.05, theme3.input.background)}`,
          transform: "scale3d(1.1, 1.1, 1.1) translateY(-1px)",
          transition: "all 50ms ease-out"
        },
        "&:active": {
          background: `${theme3.input.background}`,
          transform: "scale3d(1, 1, 1) translateY(0px)",
          cursor: "grabbing"
        }
      },
      "&::-ms-track": {
        background: theme3.base === "light" ? `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme3.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme3.color.green} 0%, ${theme3.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme3.input.background)} 100%)`,
        boxShadow: `${theme3.appBorderColor} 0 0 0 1px inset`,
        color: "transparent",
        width: "100%",
        height: "6px",
        cursor: "pointer"
      },
      "&::-ms-fill-lower": {
        borderRadius: 6
      },
      "&::-ms-fill-upper": {
        borderRadius: 6
      },
      "&::-ms-thumb": {
        width: 16,
        height: 16,
        background: `${theme3.input.background}`,
        border: `1px solid ${rgba(theme3.appBorderColor, 0.2)}`,
        borderRadius: 50,
        cursor: "grab",
        marginTop: 0
      },
      "@supports (-ms-ime-align:auto)": { "input[type=range]": { margin: "0" } }
    })
  ), RangeLabel = styled.span({
    paddingLeft: 5,
    paddingRight: 5,
    fontSize: 12,
    whiteSpace: "nowrap",
    fontFeatureSettings: "tnum",
    fontVariantNumeric: "tabular-nums",
    "[aria-readonly=true] &": {
      opacity: 0.5
    }
  }), RangeCurrentAndMaxLabel = styled(RangeLabel)(({ numberOFDecimalsPlaces, max }) => ({
    // Fixed width of "current / max" label to avoid slider width changes
    // 3 = size of separator " / "
    width: `${numberOFDecimalsPlaces + max.toString().length * 2 + 3}ch`,
    textAlign: "right",
    flexShrink: 0
  })), RangeWrapper = styled.div({
    display: "flex",
    alignItems: "center",
    width: "100%"
  });
  function getNumberOfDecimalPlaces(number) {
    let match = number.toString().match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    return match ? Math.max(
      0,
      // Number of digits right of decimal point.
      (match[1] ? match[1].length : 0) - // Adjust for scientific notation.
      (match[2] ? +match[2] : 0)
    ) : 0;
  }
  __name(getNumberOfDecimalPlaces, "getNumberOfDecimalPlaces");
  var RangeControl = __name(({
    name,
    value: value2,
    onChange,
    min = 0,
    max = 100,
    step: step2 = 1,
    onBlur,
    onFocus,
    argType
  }) => {
    let handleChange = __name((event) => {
      onChange(parse22(event.target.value));
    }, "handleChange"), hasValue = value2 !== void 0, numberOFDecimalsPlaces = useMemo(() => getNumberOfDecimalPlaces(step2), [step2]), readonly = !!argType?.table?.readonly;
    return react_default.createElement(RangeWrapper, { "aria-readonly": readonly }, react_default.createElement(RangeLabel, null, min), react_default.createElement(
      RangeInput,
      {
        id: getControlId(name),
        type: "range",
        disabled: readonly,
        onChange: handleChange,
        name,
        min,
        max,
        step: step2,
        onFocus,
        onBlur,
        value: value2 ?? min
      }
    ), react_default.createElement(RangeCurrentAndMaxLabel, { numberOFDecimalsPlaces, max }, hasValue ? value2.toFixed(numberOFDecimalsPlaces) : "--", " / ", max));
  }, "RangeControl"), Wrapper8 = styled.label({
    display: "flex"
  }), MaxLength = styled.div(({ isMaxed }) => ({
    marginLeft: "0.75rem",
    paddingTop: "0.35rem",
    color: isMaxed ? "red" : void 0
  })), TextControl = __name(({
    name,
    value: value2,
    onChange,
    onFocus,
    onBlur,
    maxLength,
    argType
  }) => {
    let handleChange = __name((event) => {
      onChange(event.target.value);
    }, "handleChange"), readonly = !!argType?.table?.readonly, [forceVisible, setForceVisible] = useState(!1), onForceVisible = useCallback(() => {
      onChange(""), setForceVisible(!0);
    }, [setForceVisible]);
    if (value2 === void 0)
      return react_default.createElement(
        Button,
        {
          variant: "outline",
          size: "medium",
          disabled: readonly,
          id: getControlSetterButtonId(name),
          onClick: onForceVisible
        },
        "Set string"
      );
    let isValid = typeof value2 == "string";
    return react_default.createElement(Wrapper8, null, react_default.createElement(
      Form.Textarea,
      {
        id: getControlId(name),
        maxLength,
        onChange: handleChange,
        disabled: readonly,
        size: "flex",
        placeholder: "Edit string...",
        autoFocus: forceVisible,
        valid: isValid ? void 0 : "error",
        name,
        value: isValid ? value2 : "",
        onFocus,
        onBlur
      }
    ), maxLength && react_default.createElement(MaxLength, { isMaxed: value2?.length === maxLength }, value2?.length ?? 0, " / ", maxLength));
  }, "TextControl"), FileInput = styled(Form.Input)({
    padding: 10
  });
  function revokeOldUrls(urls) {
    urls.forEach((url) => {
      url.startsWith("blob:") && URL.revokeObjectURL(url);
    });
  }
  __name(revokeOldUrls, "revokeOldUrls");
  var FilesControl = __name(({
    onChange,
    name,
    accept = "image/*",
    value: value2,
    argType
  }) => {
    let inputElement = useRef(null), readonly = argType?.control?.readOnly;
    function handleFileChange(e2) {
      if (!e2.target.files)
        return;
      let fileUrls = Array.from(e2.target.files).map((file) => URL.createObjectURL(file));
      onChange(fileUrls), revokeOldUrls(value2 || []);
    }
    return __name(handleFileChange, "handleFileChange"), useEffect(() => {
      value2 == null && inputElement.current && (inputElement.current.value = "");
    }, [value2, name]), react_default.createElement(
      FileInput,
      {
        ref: inputElement,
        id: getControlId(name),
        type: "file",
        name,
        multiple: !0,
        disabled: readonly,
        onChange: handleFileChange,
        accept,
        size: "flex"
      }
    );
  }, "FilesControl"), LazyColorControl = lazy(() => Promise.resolve().then(() => (init_Color_7ZNS6F6B(), Color_7ZNS6F6B_exports))), ColorControl2 = __name((props) => react_default.createElement(Suspense, { fallback: react_default.createElement("div", null) }, react_default.createElement(LazyColorControl, { ...props })), "ColorControl"), Controls2 = {
    array: ObjectControl,
    object: ObjectControl,
    boolean: BooleanControl,
    color: ColorControl2,
    date: DateControl,
    number: NumberControl,
    check: OptionsControl,
    "inline-check": OptionsControl,
    radio: OptionsControl,
    "inline-radio": OptionsControl,
    select: OptionsControl,
    "multi-select": OptionsControl,
    range: RangeControl,
    text: TextControl,
    file: FilesControl
  }, NoControl = __name(() => react_default.createElement(react_default.Fragment, null, "-"), "NoControl"), ArgControl = __name(({ row, arg, updateArgs, isHovered }) => {
    let { key, control } = row, [isFocused, setFocused] = useState(!1), [boxedValue, setBoxedValue] = useState({ value: arg });
    useEffect(() => {
      isFocused || setBoxedValue({ value: arg });
    }, [isFocused, arg]);
    let onChange = useCallback(
      (argVal) => (setBoxedValue({ value: argVal }), updateArgs({ [key]: argVal }), argVal),
      [updateArgs, key]
    ), onBlur = useCallback(() => setFocused(!1), []), onFocus = useCallback(() => setFocused(!0), []);
    if (!control || control.disable) {
      let canBeSetup = control?.disable !== !0 && row?.type?.name !== "function";
      return isHovered && canBeSetup ? react_default.createElement(
        Link,
        {
          href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
          target: "_blank",
          withArrow: !0
        },
        "Setup controls"
      ) : react_default.createElement(NoControl, null);
    }
    let props = { name: key, argType: row, value: boxedValue.value, onChange, onBlur, onFocus }, Control = Controls2[control.type] || NoControl;
    return react_default.createElement(Control, { ...props, ...control, controlType: control.type });
  }, "ArgControl"), Table2 = styled.table(({ theme: theme3 }) => ({
    "&&": {
      // Escape default table styles
      borderCollapse: "collapse",
      borderSpacing: 0,
      border: "none",
      tr: {
        border: "none !important",
        background: "none"
      },
      "td, th": {
        padding: 0,
        border: "none",
        width: "auto!important"
      },
      // End escape
      marginTop: 0,
      marginBottom: 0,
      "th:first-of-type, td:first-of-type": {
        paddingLeft: 0
      },
      "th:last-of-type, td:last-of-type": {
        paddingRight: 0
      },
      td: {
        paddingTop: 0,
        paddingBottom: 4,
        "&:not(:first-of-type)": {
          paddingLeft: 10,
          paddingRight: 0
        }
      },
      tbody: {
        boxShadow: "none",
        border: "none"
      },
      code: codeCommon({ theme: theme3 }),
      div: {
        span: {
          fontWeight: "bold"
        }
      },
      "& code": {
        margin: 0,
        display: "inline-block",
        fontSize: theme3.typography.size.s1
      }
    }
  })), ArgJsDoc = __name(({ tags }) => {
    let params = (tags.params || []).filter((x22) => x22.description), hasDisplayableParams = params.length !== 0, hasDisplayableDeprecated = tags.deprecated != null, hasDisplayableReturns = tags.returns != null && tags.returns.description != null;
    return !hasDisplayableParams && !hasDisplayableReturns && !hasDisplayableDeprecated ? null : react_default.createElement(react_default.Fragment, null, react_default.createElement(Table2, null, react_default.createElement("tbody", null, hasDisplayableDeprecated && react_default.createElement("tr", { key: "deprecated" }, react_default.createElement("td", { colSpan: 2 }, react_default.createElement("strong", null, "Deprecated"), ": ", tags.deprecated?.toString())), hasDisplayableParams && params.map((x22) => react_default.createElement("tr", { key: x22.name }, react_default.createElement("td", null, react_default.createElement("code", null, x22.name)), react_default.createElement("td", null, x22.description))), hasDisplayableReturns && react_default.createElement("tr", { key: "returns" }, react_default.createElement("td", null, react_default.createElement("code", null, "Returns")), react_default.createElement("td", null, tags.returns?.description)))));
  }, "ArgJsDoc"), import_memoizerific3 = __toESM(require_memoizerific(), 1), ITEMS_BEFORE_EXPANSION = 8, Summary = styled.div(({ isExpanded }) => ({
    display: "flex",
    flexDirection: isExpanded ? "column" : "row",
    flexWrap: "wrap",
    alignItems: "flex-start",
    marginBottom: "-4px",
    minWidth: 100
  })), Text3 = styled.span(codeCommon, ({ theme: theme3, simple = !1 }) => ({
    flex: "0 0 auto",
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1,
    wordBreak: "break-word",
    whiteSpace: "normal",
    maxWidth: "100%",
    margin: 0,
    marginRight: "4px",
    marginBottom: "4px",
    paddingTop: "2px",
    paddingBottom: "2px",
    lineHeight: "13px",
    ...simple && {
      background: "transparent",
      border: "0 none",
      paddingLeft: 0
    }
  })), ExpandButton = styled.button(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.mono,
    color: theme3.color.secondary,
    marginBottom: "4px",
    background: "none",
    border: "none"
  })), Expandable = styled.div(codeCommon, ({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.mono,
    color: theme3.color.secondary,
    fontSize: theme3.typography.size.s1,
    // overrides codeCommon
    margin: 0,
    whiteSpace: "nowrap",
    display: "flex",
    alignItems: "center"
  })), Detail = styled.div(({ theme: theme3, width }) => ({
    width,
    minWidth: 200,
    maxWidth: 800,
    padding: 15,
    // Don't remove the mono fontFamily here even if it seems useless, this is used by the browser to calculate the length of a "ch" unit.
    fontFamily: theme3.typography.fonts.mono,
    fontSize: theme3.typography.size.s1,
    // Most custom stylesheet will reset the box-sizing to "border-box" and will break the tooltip.
    boxSizing: "content-box",
    "& code": {
      padding: "0 !important"
    }
  })), ChevronUpIcon2 = styled(ChevronSmallUpIcon)({
    marginLeft: 4
  }), ChevronDownIcon2 = styled(ChevronSmallDownIcon)({
    marginLeft: 4
  }), EmptyArg = __name(() => react_default.createElement("span", null, "-"), "EmptyArg"), ArgText = __name(({ text, simple }) => react_default.createElement(Text3, { simple }, text), "ArgText"), calculateDetailWidth = (0, import_memoizerific3.default)(1e3)((detail) => {
    let lines = detail.split(/\r?\n/);
    return `${Math.max(...lines.map((x22) => x22.length))}ch`;
  }), getSummaryItems = __name((summary) => {
    if (!summary)
      return [summary];
    let summaryItems = summary.split("|").map((value2) => value2.trim());
    return uniq(summaryItems);
  }, "getSummaryItems"), renderSummaryItems = __name((summaryItems, isExpanded = !0) => {
    let items = summaryItems;
    return isExpanded || (items = summaryItems.slice(0, ITEMS_BEFORE_EXPANSION)), items.map((item) => react_default.createElement(ArgText, { key: item, text: item === "" ? '""' : item }));
  }, "renderSummaryItems"), ArgSummary = __name(({ value: value2, initialExpandedArgs }) => {
    let { summary, detail } = value2, [isOpen, setIsOpen] = useState(!1), [isExpanded, setIsExpanded] = useState(initialExpandedArgs || !1);
    if (summary == null)
      return null;
    let summaryAsString = typeof summary.toString == "function" ? summary.toString() : summary;
    if (detail == null) {
      if (/[(){}[\]<>]/.test(summaryAsString))
        return react_default.createElement(ArgText, { text: summaryAsString });
      let summaryItems = getSummaryItems(summaryAsString), itemsCount = summaryItems.length;
      return itemsCount > ITEMS_BEFORE_EXPANSION ? react_default.createElement(Summary, { isExpanded }, renderSummaryItems(summaryItems, isExpanded), react_default.createElement(ExpandButton, { onClick: () => setIsExpanded(!isExpanded) }, isExpanded ? "Show less..." : `Show ${itemsCount - ITEMS_BEFORE_EXPANSION} more...`)) : react_default.createElement(Summary, null, renderSummaryItems(summaryItems));
    }
    return react_default.createElement(
      WithTooltipPure,
      {
        closeOnOutsideClick: !0,
        placement: "bottom",
        visible: isOpen,
        onVisibleChange: (isVisible) => {
          setIsOpen(isVisible);
        },
        tooltip: react_default.createElement(Detail, { width: calculateDetailWidth(detail) }, react_default.createElement(SyntaxHighlighter, { language: "jsx", format: !1 }, detail))
      },
      react_default.createElement(Expandable, { className: "sbdocs-expandable" }, react_default.createElement("span", null, summaryAsString), isOpen ? react_default.createElement(ChevronUpIcon2, null) : react_default.createElement(ChevronDownIcon2, null))
    );
  }, "ArgSummary"), ArgValue = __name(({ value: value2, initialExpandedArgs }) => value2 == null ? react_default.createElement(EmptyArg, null) : react_default.createElement(ArgSummary, { value: value2, initialExpandedArgs }), "ArgValue"), Name = styled.span({ fontWeight: "bold" }), Required = styled.span(({ theme: theme3 }) => ({
    color: theme3.color.negative,
    fontFamily: theme3.typography.fonts.mono,
    cursor: "help"
  })), Description = styled.div(({ theme: theme3 }) => ({
    "&&": {
      p: {
        margin: "0 0 10px 0"
      },
      a: {
        color: theme3.color.secondary
      }
    },
    code: {
      ...codeCommon({ theme: theme3 }),
      fontSize: 12,
      fontFamily: theme3.typography.fonts.mono
    },
    "& code": {
      margin: 0,
      display: "inline-block"
    },
    "& pre > code": {
      whiteSpace: "pre-wrap"
    }
  })), Type = styled.div(({ theme: theme3, hasDescription }) => ({
    color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.2, theme3.color.defaultText),
    marginTop: hasDescription ? 4 : 0
  })), TypeWithJsDoc = styled.div(({ theme: theme3, hasDescription }) => ({
    color: theme3.base === "light" ? curriedTransparentize$1(0.1, theme3.color.defaultText) : curriedTransparentize$1(0.2, theme3.color.defaultText),
    marginTop: hasDescription ? 12 : 0,
    marginBottom: 12
  })), StyledTd = styled.td(({ expandable }) => ({
    paddingLeft: expandable ? "40px !important" : "20px !important"
  })), toSummary = __name((value2) => value2 && { summary: typeof value2 == "string" ? value2 : value2.name }, "toSummary"), ArgRow = __name((props) => {
    let [isHovered, setIsHovered] = useState(!1), { row, updateArgs, compact, expandable, initialExpandedArgs } = props, { name, description } = row, table = row.table || {}, type = table.type || toSummary(row.type), defaultValue = table.defaultValue || row.defaultValue, required = row.type?.required, hasDescription = description != null && description !== "";
    return react_default.createElement("tr", { onMouseEnter: () => setIsHovered(!0), onMouseLeave: () => setIsHovered(!1) }, react_default.createElement(StyledTd, { expandable: expandable ?? !1 }, react_default.createElement(Name, null, name), required ? react_default.createElement(Required, { title: "Required" }, "*") : null), compact ? null : react_default.createElement("td", null, hasDescription && react_default.createElement(Description, null, react_default.createElement(index_modern_default, null, description)), table.jsDocTags != null ? react_default.createElement(react_default.Fragment, null, react_default.createElement(TypeWithJsDoc, { hasDescription }, react_default.createElement(ArgValue, { value: type, initialExpandedArgs })), react_default.createElement(ArgJsDoc, { tags: table.jsDocTags })) : react_default.createElement(Type, { hasDescription }, react_default.createElement(ArgValue, { value: type, initialExpandedArgs }))), compact ? null : react_default.createElement("td", null, react_default.createElement(ArgValue, { value: defaultValue, initialExpandedArgs })), updateArgs ? react_default.createElement("td", null, react_default.createElement(ArgControl, { ...props, isHovered })) : null);
  }, "ArgRow"), Wrapper9 = styled.div(({ inAddonPanel, theme: theme3 }) => ({
    height: inAddonPanel ? "100%" : "auto",
    display: "flex",
    border: inAddonPanel ? "none" : `1px solid ${theme3.appBorderColor}`,
    borderRadius: inAddonPanel ? 0 : theme3.appBorderRadius,
    padding: inAddonPanel ? 0 : 40,
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    gap: 15,
    background: theme3.background.content
  })), Links = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    fontSize: theme3.typography.size.s2 - 1,
    gap: 25
  })), Empty = __name(({ inAddonPanel }) => {
    let [isLoading, setIsLoading] = useState(!0);
    return useEffect(() => {
      let load = setTimeout(() => {
        setIsLoading(!1);
      }, 100);
      return () => clearTimeout(load);
    }, []), isLoading ? null : react_default.createElement(Wrapper9, { inAddonPanel }, react_default.createElement(
      EmptyTabContent,
      {
        title: inAddonPanel ? "Interactive story playground" : "Args table with interactive controls couldn't be auto-generated",
        description: react_default.createElement(react_default.Fragment, null, "Controls give you an easy to use interface to test your components. Set your story args and you'll see controls appearing here automatically."),
        footer: react_default.createElement(Links, null, inAddonPanel && react_default.createElement(react_default.Fragment, null, react_default.createElement(
          Link,
          {
            href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
            target: "_blank",
            withArrow: !0
          },
          react_default.createElement(DocumentIcon, null),
          " Read docs"
        )), !inAddonPanel && react_default.createElement(
          Link,
          {
            href: "https://storybook.js.org/docs/essentials/controls?ref=ui",
            target: "_blank",
            withArrow: !0
          },
          react_default.createElement(DocumentIcon, null),
          " Learn how to set that up"
        ))
      }
    ));
  }, "Empty"), ExpanderIconDown = styled(ChevronDownIcon)(({ theme: theme3 }) => ({
    marginRight: 8,
    marginLeft: -10,
    marginTop: -2,
    // optical alignment
    height: 12,
    width: 12,
    color: theme3.base === "light" ? curriedTransparentize$1(0.25, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
    border: "none",
    display: "inline-block"
  })), ExpanderIconRight = styled(ChevronRightIcon)(({ theme: theme3 }) => ({
    marginRight: 8,
    marginLeft: -10,
    marginTop: -2,
    // optical alignment
    height: 12,
    width: 12,
    color: theme3.base === "light" ? curriedTransparentize$1(0.25, theme3.color.defaultText) : curriedTransparentize$1(0.3, theme3.color.defaultText),
    border: "none",
    display: "inline-block"
  })), FlexWrapper = styled.span(({ theme: theme3 }) => ({
    display: "flex",
    lineHeight: "20px",
    alignItems: "center"
  })), Section = styled.td(({ theme: theme3 }) => ({
    position: "relative",
    letterSpacing: "0.35em",
    textTransform: "uppercase",
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s1 - 1,
    color: theme3.base === "light" ? curriedTransparentize$1(0.4, theme3.color.defaultText) : curriedTransparentize$1(0.6, theme3.color.defaultText),
    background: `${theme3.background.app} !important`,
    "& ~ td": {
      background: `${theme3.background.app} !important`
    }
  })), Subsection = styled.td(({ theme: theme3 }) => ({
    position: "relative",
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s2 - 1,
    background: theme3.background.app
  })), StyledTd2 = styled.td({
    position: "relative"
  }), StyledTr = styled.tr(({ theme: theme3 }) => ({
    "&:hover > td": {
      backgroundColor: `${curriedLighten$1(5e-3, theme3.background.app)} !important`,
      boxShadow: `${theme3.color.mediumlight} 0 - 1px 0 0 inset`,
      cursor: "row-resize"
    }
  })), ClickIntercept = styled.button({
    // reset button style
    background: "none",
    border: "none",
    padding: "0",
    font: "inherit",
    // add custom style
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    height: "100%",
    width: "100%",
    color: "transparent",
    cursor: "row-resize !important"
  }), SectionRow = __name(({
    level = "section",
    label,
    children,
    initialExpanded = !0,
    colSpan = 3
  }) => {
    let [expanded, setExpanded] = useState(initialExpanded), Level = level === "subsection" ? Subsection : Section, itemCount = children?.length || 0, caption = level === "subsection" ? `${itemCount} item${itemCount !== 1 ? "s" : ""}` : "", helperText = `${expanded ? "Hide" : "Show"} ${level === "subsection" ? itemCount : label} item${itemCount !== 1 ? "s" : ""}`;
    return react_default.createElement(react_default.Fragment, null, react_default.createElement(StyledTr, { title: helperText }, react_default.createElement(Level, { colSpan: 1 }, react_default.createElement(ClickIntercept, { onClick: (e2) => setExpanded(!expanded), tabIndex: 0 }, helperText), react_default.createElement(FlexWrapper, null, expanded ? react_default.createElement(ExpanderIconDown, null) : react_default.createElement(ExpanderIconRight, null), label)), react_default.createElement(StyledTd2, { colSpan: colSpan - 1 }, react_default.createElement(
      ClickIntercept,
      {
        onClick: (e2) => setExpanded(!expanded),
        tabIndex: -1,
        style: { outline: "none" }
      },
      helperText
    ), expanded ? null : caption)), expanded ? children : null);
  }, "SectionRow"), TableWrapper = styled.div(({ theme: theme3 }) => ({
    width: "100%",
    borderSpacing: 0,
    color: theme3.color.defaultText
  })), Row = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    borderBottom: `1px solid ${theme3.appBorderColor}`,
    "&:last-child": {
      borderBottom: 0
    }
  })), Column = styled.div(
    ({ position, theme: theme3 }) => {
      let baseStyles = {
        display: "flex",
        flexDirection: "column",
        gap: 5,
        padding: "10px 15px",
        alignItems: "flex-start"
      };
      switch (position) {
        case "first":
          return {
            ...baseStyles,
            width: "25%",
            paddingLeft: 20
          };
        case "second":
          return {
            ...baseStyles,
            width: "35%"
          };
        case "third":
          return {
            ...baseStyles,
            width: "15%"
          };
        case "last":
          return {
            ...baseStyles,
            width: "25%",
            paddingRight: 20
          };
      }
    }
  ), SkeletonText = styled.div(
    ({ theme: theme3, width, height }) => ({
      animation: `${theme3.animation.glow} 1.5s ease-in-out infinite`,
      background: theme3.appBorderColor,
      width: width || "100%",
      height: height || 16,
      borderRadius: 3
    })
  ), Skeleton = __name(() => react_default.createElement(TableWrapper, null, react_default.createElement(Row, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" }))), react_default.createElement(Row, null, react_default.createElement(Column, { position: "first" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "second" }, react_default.createElement(SkeletonText, { width: "80%" }), react_default.createElement(SkeletonText, { width: "30%" })), react_default.createElement(Column, { position: "third" }, react_default.createElement(SkeletonText, { width: "60%" })), react_default.createElement(Column, { position: "last" }, react_default.createElement(SkeletonText, { width: "60%" })))), "Skeleton"), TableWrapper2 = styled.table(({ theme: theme3, compact, inAddonPanel }) => ({
    "&&": {
      // Resets for cascading/system styles
      borderSpacing: 0,
      color: theme3.color.defaultText,
      "td, th": {
        padding: 0,
        border: "none",
        verticalAlign: "top",
        textOverflow: "ellipsis"
      },
      // End Resets
      fontSize: theme3.typography.size.s2 - 1,
      lineHeight: "20px",
      textAlign: "left",
      width: "100%",
      // Margin collapse
      marginTop: inAddonPanel ? 0 : 25,
      marginBottom: inAddonPanel ? 0 : 40,
      "thead th:first-of-type, td:first-of-type": {
        // intentionally specify thead here
        width: "25%"
      },
      "th:first-of-type, td:first-of-type": {
        paddingLeft: 20
      },
      "th:nth-of-type(2), td:nth-of-type(2)": {
        ...compact ? null : {
          // Description column
          width: "35%"
        }
      },
      "td:nth-of-type(3)": {
        ...compact ? null : {
          // Defaults column
          width: "15%"
        }
      },
      "th:last-of-type, td:last-of-type": {
        paddingRight: 20,
        ...compact ? null : {
          // Controls column
          width: "25%"
        }
      },
      th: {
        color: theme3.base === "light" ? curriedTransparentize$1(0.25, theme3.color.defaultText) : curriedTransparentize$1(0.45, theme3.color.defaultText),
        paddingTop: 10,
        paddingBottom: 10,
        paddingLeft: 15,
        paddingRight: 15
      },
      td: {
        paddingTop: "10px",
        paddingBottom: "10px",
        "&:not(:first-of-type)": {
          paddingLeft: 15,
          paddingRight: 15
        },
        "&:last-of-type": {
          paddingRight: 20
        }
      },
      // Makes border alignment consistent w/other DocBlocks
      marginLeft: inAddonPanel ? 0 : 1,
      marginRight: inAddonPanel ? 0 : 1,
      tbody: {
        // Safari doesn't love shadows on tbody so we need to use a shadow filter. In order to do this,
        // the table cells all need to be solid so they have a background color applied.
        // I wasn't sure what kinds of content go in these tables so I was extra specific with selectors
        // to avoid unexpected surprises.
        ...inAddonPanel ? null : {
          filter: theme3.base === "light" ? "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.10))" : "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.20))"
        },
        "> tr > *": {
          // For filter to work properly, the table cells all need to be opaque.
          background: theme3.background.content,
          borderTop: `1px solid ${theme3.appBorderColor}`
        },
        ...inAddonPanel ? null : {
          // This works and I don't know why. :)
          "> tr:first-of-type > *": {
            borderBlockStart: `1px solid ${theme3.appBorderColor}`
          },
          "> tr:last-of-type > *": {
            borderBlockEnd: `1px solid ${theme3.appBorderColor}`
          },
          "> tr > *:first-of-type": {
            borderInlineStart: `1px solid ${theme3.appBorderColor}`
          },
          "> tr > *:last-of-type": {
            borderInlineEnd: `1px solid ${theme3.appBorderColor}`
          },
          // Thank you, Safari, for making me write code like this.
          "> tr:first-of-type > td:first-of-type": {
            borderTopLeftRadius: theme3.appBorderRadius
          },
          "> tr:first-of-type > td:last-of-type": {
            borderTopRightRadius: theme3.appBorderRadius
          },
          "> tr:last-of-type > td:first-of-type": {
            borderBottomLeftRadius: theme3.appBorderRadius
          },
          "> tr:last-of-type > td:last-of-type": {
            borderBottomRightRadius: theme3.appBorderRadius
          }
        }
      }
      // End awesome table styling
    }
  })), TablePositionWrapper = styled.div({
    position: "relative"
  }), ButtonPositionWrapper = styled.div({
    position: "absolute",
    right: 8,
    top: 6
  }), sortFns = {
    alpha: __name((a22, b22) => (a22.name ?? "").localeCompare(b22.name ?? ""), "alpha"),
    requiredFirst: __name((a22, b22) => +!!b22.type?.required - +!!a22.type?.required || (a22.name ?? "").localeCompare(b22.name ?? ""), "requiredFirst"),
    none: null
  }, groupRows = __name((rows, sort) => {
    let sections = { ungrouped: [], ungroupedSubsections: {}, sections: {} };
    if (!rows)
      return sections;
    Object.entries(rows).forEach(([key, row]) => {
      let { category, subcategory } = row?.table || {};
      if (category) {
        let section = sections.sections[category] || { ungrouped: [], subsections: {} };
        if (!subcategory)
          section.ungrouped.push({ key, ...row });
        else {
          let subsection = section.subsections[subcategory] || [];
          subsection.push({ key, ...row }), section.subsections[subcategory] = subsection;
        }
        sections.sections[category] = section;
      } else if (subcategory) {
        let subsection = sections.ungroupedSubsections[subcategory] || [];
        subsection.push({ key, ...row }), sections.ungroupedSubsections[subcategory] = subsection;
      } else
        sections.ungrouped.push({ key, ...row });
    });
    let sortFn = sortFns[sort], sortSubsection = __name((record) => sortFn ? Object.keys(record).reduce(
      (acc, cur) => ({
        ...acc,
        [cur]: record[cur].sort(sortFn)
      }),
      {}
    ) : record, "sortSubsection");
    return {
      ungrouped: sortFn ? sections.ungrouped.sort(sortFn) : sections.ungrouped,
      ungroupedSubsections: sortSubsection(sections.ungroupedSubsections),
      sections: Object.keys(sections.sections).reduce(
        (acc, cur) => ({
          ...acc,
          [cur]: {
            ungrouped: sortFn ? sections.sections[cur].ungrouped.sort(sortFn) : sections.sections[cur].ungrouped,
            subsections: sortSubsection(sections.sections[cur].subsections)
          }
        }),
        {}
      )
    };
  }, "groupRows"), safeIncludeConditionalArg = __name((row, args, globals) => {
    try {
      return includeConditionalArg(row, args, globals);
    } catch (err) {
      return once.warn(err.message), !1;
    }
  }, "safeIncludeConditionalArg"), ArgsTable = __name((props) => {
    let {
      updateArgs,
      resetArgs,
      compact,
      inAddonPanel,
      initialExpandedArgs,
      sort = "none",
      isLoading
    } = props;
    if ("error" in props) {
      let { error } = props;
      return react_default.createElement(EmptyBlock, null, error, "\xA0", react_default.createElement(Link, { href: "http://storybook.js.org/docs/?ref=ui", target: "_blank", withArrow: !0 }, react_default.createElement(DocumentIcon, null), " Read the docs"));
    }
    if (isLoading)
      return react_default.createElement(Skeleton, null);
    let { rows, args, globals } = "rows" in props ? props : { rows: void 0, args: void 0, globals: void 0 }, groups = groupRows(
      pickBy(
        rows || {},
        (row) => !row?.table?.disable && safeIncludeConditionalArg(row, args || {}, globals || {})
      ),
      sort
    ), hasNoUngrouped = groups.ungrouped.length === 0, hasNoSections = Object.entries(groups.sections).length === 0, hasNoUngroupedSubsections = Object.entries(groups.ungroupedSubsections).length === 0;
    if (hasNoUngrouped && hasNoSections && hasNoUngroupedSubsections)
      return react_default.createElement(Empty, { inAddonPanel });
    let colSpan = 1;
    updateArgs && (colSpan += 1), compact || (colSpan += 2);
    let expandable = Object.keys(groups.sections).length > 0, common = { updateArgs, compact, inAddonPanel, initialExpandedArgs };
    return react_default.createElement(ResetWrapper, null, react_default.createElement(TablePositionWrapper, null, updateArgs && !isLoading && resetArgs && react_default.createElement(ButtonPositionWrapper, null, react_default.createElement(
      IconButton,
      {
        onClick: () => resetArgs(),
        "aria-label": "Reset controls",
        title: "Reset controls"
      },
      react_default.createElement(UndoIcon, null)
    )), react_default.createElement(TableWrapper2, { compact, inAddonPanel, className: "docblock-argstable sb-unstyled" }, react_default.createElement("thead", { className: "docblock-argstable-head" }, react_default.createElement("tr", null, react_default.createElement("th", null, react_default.createElement("span", null, "Name")), compact ? null : react_default.createElement("th", null, react_default.createElement("span", null, "Description")), compact ? null : react_default.createElement("th", null, react_default.createElement("span", null, "Default")), updateArgs ? react_default.createElement("th", null, react_default.createElement("span", null, "Control")) : null)), react_default.createElement("tbody", { className: "docblock-argstable-body" }, groups.ungrouped.map((row) => react_default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], ...common })), Object.entries(groups.ungroupedSubsections).map(([subcategory, subsection]) => react_default.createElement(
      SectionRow,
      {
        key: subcategory,
        label: subcategory,
        level: "subsection",
        colSpan
      },
      subsection.map((row) => react_default.createElement(
        ArgRow,
        {
          key: row.key,
          row,
          arg: args && args[row.key],
          expandable,
          ...common
        }
      ))
    )), Object.entries(groups.sections).map(([category, section]) => react_default.createElement(SectionRow, { key: category, label: category, level: "section", colSpan }, section.ungrouped.map((row) => react_default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], ...common })), Object.entries(section.subsections).map(([subcategory, subsection]) => react_default.createElement(
      SectionRow,
      {
        key: subcategory,
        label: subcategory,
        level: "subsection",
        colSpan
      },
      subsection.map((row) => react_default.createElement(
        ArgRow,
        {
          key: row.key,
          row,
          arg: args && args[row.key],
          expandable,
          ...common
        }
      ))
    ))))))));
  }, "ArgsTable"), ADDON_ID62 = "addon-controls", PARAM_KEY52 = "controls", slideIn = keyframes({
    from: { transform: "translateY(40px)" },
    to: { transform: "translateY(0)" }
  }), highlight = keyframes({
    from: { background: "var(--highlight-bg-color)" },
    to: {}
  }), Container2 = styled.div({
    containerType: "size",
    position: "sticky",
    bottom: 0,
    height: 39,
    overflow: "hidden",
    zIndex: 1
  }), Bar22 = styled(Bar)(({ theme: theme3 }) => ({
    "--highlight-bg-color": theme3.base === "dark" ? "#153B5B" : "#E0F0FF",
    display: "flex",
    flexDirection: "row-reverse",
    // hide Info rather than Actions on overflow
    alignItems: "center",
    justifyContent: "space-between",
    flexWrap: "wrap",
    gap: 6,
    padding: "6px 10px",
    animation: `${slideIn} 300ms, ${highlight} 2s`,
    background: theme3.background.bar,
    borderTop: `1px solid ${theme3.appBorderColor}`,
    fontSize: theme3.typography.size.s2,
    "@container (max-width: 799px)": {
      flexDirection: "row",
      justifyContent: "flex-end"
    }
  })), Info = styled.div({
    display: "flex",
    flex: "99 0 auto",
    alignItems: "center",
    marginLeft: 10,
    gap: 6
  }), Actions = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    flex: "1 0 0",
    alignItems: "center",
    gap: 2,
    color: theme3.color.mediumdark,
    fontSize: theme3.typography.size.s2
  })), Label5 = styled.div({
    "@container (max-width: 799px)": {
      lineHeight: 0,
      textIndent: "-9999px",
      "&::after": {
        content: "attr(data-short-label)",
        display: "block",
        lineHeight: "initial",
        textIndent: "0"
      }
    }
  }), ModalInput = styled(Form.Input)(({ theme: theme3 }) => ({
    "::placeholder": {
      color: theme3.color.mediumdark
    },
    "&:invalid:not(:placeholder-shown)": {
      boxShadow: `${theme3.color.negative} 0 0 0 1px inset`
    }
  })), SaveStory = __name(({
    saveStory,
    createStory,
    resetArgs,
    portalSelector
  }) => {
    let inputRef = react_default.useRef(null), [saving, setSaving] = react_default.useState(!1), [creating, setCreating] = react_default.useState(!1), [storyName, setStoryName] = react_default.useState(""), [errorMessage, setErrorMessage] = react_default.useState(null), onSaveStory = __name(async () => {
      saving || (setSaving(!0), await saveStory().catch(() => {
      }), setSaving(!1));
    }, "onSaveStory"), onShowForm = __name(() => {
      setCreating(!0), setStoryName(""), setTimeout(() => inputRef.current?.focus(), 0);
    }, "onShowForm"), onChange = __name((e2) => {
      let value2 = e2.target.value.replace(/^[^a-z]/i, "").replace(/[^a-z0-9-_ ]/gi, "").replaceAll(/([-_ ]+[a-z0-9])/gi, (match) => match.toUpperCase().replace(/[-_ ]/g, ""));
      setStoryName(value2.charAt(0).toUpperCase() + value2.slice(1));
    }, "onChange"), onSubmitForm = __name(async (event) => {
      if (event.preventDefault(), !saving)
        try {
          setErrorMessage(null), setSaving(!0), await createStory(storyName.replace(/^[^a-z]/i, "").replaceAll(/[^a-z0-9]/gi, "")), setCreating(!1), setSaving(!1);
        } catch (e2) {
          setErrorMessage(e2.message), setSaving(!1);
        }
    }, "onSubmitForm");
    return react_default.createElement(Container2, { id: "save-from-controls" }, react_default.createElement(Bar22, null, react_default.createElement(Actions, null, react_default.createElement(
      WithTooltip,
      {
        as: "div",
        hasChrome: !1,
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote, { note: "Save changes to story" })
      },
      react_default.createElement(IconButton, { "aria-label": "Save changes to story", disabled: saving, onClick: onSaveStory }, react_default.createElement(CheckIcon, null), react_default.createElement(Label5, { "data-short-label": "Save" }, "Update story"))
    ), react_default.createElement(
      WithTooltip,
      {
        as: "div",
        hasChrome: !1,
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote, { note: "Create new story with these settings" })
      },
      react_default.createElement(IconButton, { "aria-label": "Create new story with these settings", onClick: onShowForm }, react_default.createElement(AddIcon, null), react_default.createElement(Label5, { "data-short-label": "New" }, "Create new story"))
    ), react_default.createElement(
      WithTooltip,
      {
        as: "div",
        hasChrome: !1,
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote, { note: "Reset changes" })
      },
      react_default.createElement(IconButton, { "aria-label": "Reset changes", onClick: () => resetArgs() }, react_default.createElement(UndoIcon, null), react_default.createElement("span", null, "Reset"))
    )), react_default.createElement(Info, null, react_default.createElement(Label5, { "data-short-label": "Unsaved changes" }, "You modified this story. Do you want to save your changes?")), react_default.createElement(
      Modal,
      {
        width: 350,
        open: creating,
        onOpenChange: setCreating,
        portalSelector
      },
      react_default.createElement(Form, { onSubmit: onSubmitForm, id: "create-new-story-form" }, react_default.createElement(Modal.Content, null, react_default.createElement(Modal.Header, null, react_default.createElement(Modal.Title, null, "Create new story"), react_default.createElement(Modal.Description, null, "This will add a new story to your existing stories file.")), react_default.createElement(
        ModalInput,
        {
          onChange,
          placeholder: "Story export name",
          readOnly: saving,
          ref: inputRef,
          value: storyName
        }
      ), react_default.createElement(Modal.Actions, null, react_default.createElement(Button, { disabled: saving || !storyName, size: "medium", type: "submit", variant: "solid" }, "Create"), react_default.createElement(Modal.Dialog.Close, { asChild: !0 }, react_default.createElement(Button, { disabled: saving, size: "medium", type: "reset" }, "Cancel"))))),
      errorMessage && react_default.createElement(Modal.Error, null, errorMessage)
    )));
  }, "SaveStory"), clean = __name((obj) => Object.entries(obj).reduce(
    (acc, [key, value2]) => value2 !== void 0 ? Object.assign(acc, { [key]: value2 }) : acc,
    {}
  ), "clean"), AddonWrapper = styled.div({
    display: "grid",
    gridTemplateRows: "1fr 39px",
    height: "100%",
    maxHeight: "100vh",
    overflowY: "auto"
  }), ControlsPanel = __name(({ saveStory, createStory }) => {
    let api = useStorybookApi(), [isLoading, setIsLoading] = useState(!0), [args, updateArgs, resetArgs, initialArgs] = useArgs(), [globals] = useGlobals(), rows = useArgTypes(), {
      expanded,
      sort,
      presetColors,
      disableSaveFromUI = !1
    } = useParameter(PARAM_KEY52, {}), { path, previewInitialized } = useStorybookState(), storyData = api.getCurrentStoryData();
    useEffect(() => {
      previewInitialized && setIsLoading(!1);
    }, [previewInitialized]);
    let hasControls = Object.values(rows).some((arg) => arg?.control), withPresetColors = Object.entries(rows).reduce((acc, [key, arg]) => {
      let control = arg?.control;
      return typeof control != "object" || control?.type !== "color" || control?.presetColors ? acc[key] = arg : acc[key] = { ...arg, control: { ...control, presetColors } }, acc;
    }, {}), hasUpdatedArgs = useMemo(
      () => !!args && !!initialArgs && !dequal(clean(args), clean(initialArgs)),
      [args, initialArgs]
    );
    return react_default.createElement(AddonWrapper, null, react_default.createElement(
      ArgsTable,
      {
        key: path,
        compact: !expanded && hasControls,
        rows: withPresetColors,
        args,
        globals,
        updateArgs,
        resetArgs,
        inAddonPanel: !0,
        sort,
        isLoading
      }
    ), hasControls && storyData.type === "story" && storyData.subtype !== "test" && hasUpdatedArgs && scope.CONFIG_TYPE === "DEVELOPMENT" && disableSaveFromUI !== !0 && react_default.createElement(SaveStory, { resetArgs, saveStory, createStory }));
  }, "ControlsPanel");
  function Title2() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), rows = useArgTypes(), controlsCount = Object.values(rows).filter(
      (argType) => argType?.control && !argType?.table?.disable
    ).length, suffix = controlsCount === 0 ? null : react_default.createElement(Badge, { compact: !0, status: selectedPanel === ADDON_ID62 ? "active" : "neutral" }, controlsCount);
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Controls"), suffix);
  }
  __name(Title2, "Title");
  var stringifyArgs = __name((args) => JSON.stringify(args, (_22, value2) => typeof value2 == "function" ? "__sb_empty_function_arg__" : value2), "stringifyArgs"), manager_default = addons.register(ADDON_ID62, (api) => {
    if (globalThis?.FEATURES?.controls) {
      let channel = addons.getChannel(), saveStory = __name(async () => {
        let data = api.getCurrentStoryData();
        if (data.type !== "story")
          throw new Error("Not a story");
        try {
          let response = await experimental_requestResponse(channel, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, {
            // Only send updated args
            args: stringifyArgs(
              Object.entries(data.args || {}).reduce((acc, [key, value2]) => (dequal(value2, data.initialArgs?.[key]) || (acc[key] = value2), acc), {})
            ),
            csfId: data.id,
            importPath: data.importPath
          });
          api.addNotification({
            id: "save-story-success",
            icon: react_default.createElement(PassedIcon, { color: color.positive }),
            content: {
              headline: "Story saved",
              subHeadline: react_default.createElement(react_default.Fragment, null, "Updated story ", react_default.createElement("b", null, response.sourceStoryName), ".")
            },
            duration: 8e3
          });
        } catch (error) {
          throw api.addNotification({
            id: "save-story-error",
            icon: react_default.createElement(FailedIcon, { color: color.negative }),
            content: {
              headline: "Failed to save story",
              subHeadline: error?.message || "Check the Storybook process on the command line for more details."
            },
            duration: 8e3
          }), error;
        }
      }, "saveStory"), createStory = __name(async (name) => {
        let data = api.getCurrentStoryData();
        if (data.type !== "story")
          throw new Error("Not a story");
        let response = await experimental_requestResponse(channel, SAVE_STORY_REQUEST, SAVE_STORY_RESPONSE, {
          args: data.args && stringifyArgs(data.args),
          csfId: data.id,
          importPath: data.importPath,
          name
        });
        api.addNotification({
          id: "save-story-success",
          icon: react_default.createElement(PassedIcon, { color: color.positive }),
          content: {
            headline: "Story created",
            subHeadline: react_default.createElement(react_default.Fragment, null, "Added story ", react_default.createElement("b", null, response.newStoryName), " based on ", react_default.createElement("b", null, response.sourceStoryName), ".")
          },
          duration: 8e3,
          onClick: __name(({ onDismiss }) => {
            onDismiss(), api.selectStory(response.newStoryId);
          }, "onClick")
        });
      }, "createStory");
      addons.add(ADDON_ID62, {
        title: Title2,
        type: types.PANEL,
        paramKey: PARAM_KEY52,
        render: __name(({ active }) => !active || !api.getCurrentStoryData() ? null : react_default.createElement(AddonPanel, { active }, react_default.createElement(ControlsPanel, { saveStory, createStory })), "render")
      }), channel.on(SAVE_STORY_RESPONSE, (data) => {
        if (!data.success)
          return;
        let story = api.getCurrentStoryData();
        story.type === "story" && (api.resetStoryArgs(story), data.payload.newStoryId && api.selectStory(data.payload.newStoryId));
      });
    }
  });
  function Title3() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), [{ count: count2 }, setCount] = useAddonState(ADDON_ID4, { count: 0 });
    useChannel({
      [EVENT_ID]: () => {
        setCount((c22) => ({ ...c22, count: c22.count + 1 }));
      },
      [STORY_CHANGED]: () => {
        setCount((c22) => ({ ...c22, count: 0 }));
      },
      [CLEAR_ID]: () => {
        setCount((c22) => ({ ...c22, count: 0 }));
      }
    });
    let suffix = count2 === 0 ? null : react_default.createElement(Badge, { compact: !0, status: selectedPanel === PANEL_ID ? "active" : "neutral" }, count2);
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Actions"), suffix);
  }
  __name(Title3, "Title");
  var __create2 = Object.create, __defProp3 = Object.defineProperty, __getOwnPropDesc2 = Object.getOwnPropertyDescriptor, __getOwnPropNames3 = Object.getOwnPropertyNames, __getProtoOf2 = Object.getPrototypeOf, __hasOwnProp2 = Object.prototype.hasOwnProperty, __commonJS2 = __name((cb, mod) => __name(function() {
    return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  }, "__require"), "__commonJS"), __export3 = __name((target, all2) => {
    for (var name in all2)
      __defProp3(target, name, { get: all2[name], enumerable: !0 });
  }, "__export"), __copyProps2 = __name((to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function")
      for (let key of __getOwnPropNames3(from))
        !__hasOwnProp2.call(to, key) && key !== except && __defProp3(to, key, { get: __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    return to;
  }, "__copyProps"), __toESM2 = __name((mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: !0 }) : target, mod)), "__toESM"), require_is_object = __commonJS2({
    "node_modules/is-object/index.js"(exports, module) {
      "use strict";
      module.exports = __name(function(x22) {
        return typeof x22 == "object" && x22 !== null;
      }, "isObject");
    }
  }), require_is_window = __commonJS2({
    "node_modules/is-window/index.js"(exports, module) {
      "use strict";
      module.exports = function(obj) {
        if (obj == null)
          return !1;
        var o2 = Object(obj);
        return o2 === o2.window;
      };
    }
  }), require_is_dom = __commonJS2({
    "node_modules/is-dom/index.js"(exports, module) {
      var isObject22 = require_is_object(), isWindow2 = require_is_window();
      function isNode(val) {
        return !isObject22(val) || !isWindow2(window) || typeof window.Node != "function" ? !1 : typeof val.nodeType == "number" && typeof val.nodeName == "string";
      }
      __name(isNode, "isNode"), module.exports = isNode;
    }
  }), themes_exports = {};
  __export3(themes_exports, {
    chromeDark: __name(() => theme, "chromeDark"),
    chromeLight: __name(() => theme2, "chromeLight")
  });
  var theme = {
    BASE_FONT_FAMILY: "Menlo, monospace",
    BASE_FONT_SIZE: "11px",
    BASE_LINE_HEIGHT: 1.2,
    BASE_BACKGROUND_COLOR: "rgb(36, 36, 36)",
    BASE_COLOR: "rgb(213, 213, 213)",
    OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
    OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
    OBJECT_NAME_COLOR: "rgb(227, 110, 236)",
    OBJECT_VALUE_NULL_COLOR: "rgb(127, 127, 127)",
    OBJECT_VALUE_UNDEFINED_COLOR: "rgb(127, 127, 127)",
    OBJECT_VALUE_REGEXP_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_STRING_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_SYMBOL_COLOR: "rgb(233, 63, 59)",
    OBJECT_VALUE_NUMBER_COLOR: "hsl(252, 100%, 75%)",
    OBJECT_VALUE_BOOLEAN_COLOR: "hsl(252, 100%, 75%)",
    OBJECT_VALUE_FUNCTION_PREFIX_COLOR: "rgb(85, 106, 242)",
    HTML_TAG_COLOR: "rgb(93, 176, 215)",
    HTML_TAGNAME_COLOR: "rgb(93, 176, 215)",
    HTML_TAGNAME_TEXT_TRANSFORM: "lowercase",
    HTML_ATTRIBUTE_NAME_COLOR: "rgb(155, 187, 220)",
    HTML_ATTRIBUTE_VALUE_COLOR: "rgb(242, 151, 102)",
    HTML_COMMENT_COLOR: "rgb(137, 137, 137)",
    HTML_DOCTYPE_COLOR: "rgb(192, 192, 192)",
    ARROW_COLOR: "rgb(145, 145, 145)",
    ARROW_MARGIN_RIGHT: 3,
    ARROW_FONT_SIZE: 12,
    ARROW_ANIMATION_DURATION: "0",
    TREENODE_FONT_FAMILY: "Menlo, monospace",
    TREENODE_FONT_SIZE: "11px",
    TREENODE_LINE_HEIGHT: 1.2,
    TREENODE_PADDING_LEFT: 12,
    TABLE_BORDER_COLOR: "rgb(85, 85, 85)",
    TABLE_TH_BACKGROUND_COLOR: "rgb(44, 44, 44)",
    TABLE_TH_HOVER_COLOR: "rgb(48, 48, 48)",
    TABLE_SORT_ICON_COLOR: "black",
    TABLE_DATA_BACKGROUND_IMAGE: "linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(51, 139, 255, 0.0980392) 50%, rgba(51, 139, 255, 0.0980392))",
    TABLE_DATA_BACKGROUND_SIZE: "128px 32px"
  }, theme2 = {
    BASE_FONT_FAMILY: "Menlo, monospace",
    BASE_FONT_SIZE: "11px",
    BASE_LINE_HEIGHT: 1.2,
    BASE_BACKGROUND_COLOR: "white",
    BASE_COLOR: "black",
    OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
    OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
    OBJECT_NAME_COLOR: "rgb(136, 19, 145)",
    OBJECT_VALUE_NULL_COLOR: "rgb(128, 128, 128)",
    OBJECT_VALUE_UNDEFINED_COLOR: "rgb(128, 128, 128)",
    OBJECT_VALUE_REGEXP_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_STRING_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_SYMBOL_COLOR: "rgb(196, 26, 22)",
    OBJECT_VALUE_NUMBER_COLOR: "rgb(28, 0, 207)",
    OBJECT_VALUE_BOOLEAN_COLOR: "rgb(28, 0, 207)",
    OBJECT_VALUE_FUNCTION_PREFIX_COLOR: "rgb(13, 34, 170)",
    HTML_TAG_COLOR: "rgb(168, 148, 166)",
    HTML_TAGNAME_COLOR: "rgb(136, 18, 128)",
    HTML_TAGNAME_TEXT_TRANSFORM: "lowercase",
    HTML_ATTRIBUTE_NAME_COLOR: "rgb(153, 69, 0)",
    HTML_ATTRIBUTE_VALUE_COLOR: "rgb(26, 26, 166)",
    HTML_COMMENT_COLOR: "rgb(35, 110, 37)",
    HTML_DOCTYPE_COLOR: "rgb(192, 192, 192)",
    ARROW_COLOR: "#6e6e6e",
    ARROW_MARGIN_RIGHT: 3,
    ARROW_FONT_SIZE: 12,
    ARROW_ANIMATION_DURATION: "0",
    TREENODE_FONT_FAMILY: "Menlo, monospace",
    TREENODE_FONT_SIZE: "11px",
    TREENODE_LINE_HEIGHT: 1.2,
    TREENODE_PADDING_LEFT: 12,
    TABLE_BORDER_COLOR: "#aaa",
    TABLE_TH_BACKGROUND_COLOR: "#eee",
    TABLE_TH_HOVER_COLOR: "hsla(0, 0%, 90%, 1)",
    TABLE_SORT_ICON_COLOR: "#6e6e6e",
    TABLE_DATA_BACKGROUND_IMAGE: "linear-gradient(to bottom, white, white 50%, rgb(234, 243, 255) 50%, rgb(234, 243, 255))",
    TABLE_DATA_BACKGROUND_SIZE: "128px 32px"
  }, ExpandedPathsContext = createContext([{}, () => {
  }]), unselectable = {
    WebkitTouchCallout: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
    msUserSelect: "none",
    OUserSelect: "none",
    userSelect: "none"
  }, createTheme = __name((theme3) => ({
    DOMNodePreview: {
      htmlOpenTag: {
        base: {
          color: theme3.HTML_TAG_COLOR
        },
        tagName: {
          color: theme3.HTML_TAGNAME_COLOR,
          textTransform: theme3.HTML_TAGNAME_TEXT_TRANSFORM
        },
        htmlAttributeName: {
          color: theme3.HTML_ATTRIBUTE_NAME_COLOR
        },
        htmlAttributeValue: {
          color: theme3.HTML_ATTRIBUTE_VALUE_COLOR
        }
      },
      htmlCloseTag: {
        base: {
          color: theme3.HTML_TAG_COLOR
        },
        offsetLeft: {
          marginLeft: -theme3.TREENODE_PADDING_LEFT
        },
        tagName: {
          color: theme3.HTML_TAGNAME_COLOR,
          textTransform: theme3.HTML_TAGNAME_TEXT_TRANSFORM
        }
      },
      htmlComment: {
        color: theme3.HTML_COMMENT_COLOR
      },
      htmlDoctype: {
        color: theme3.HTML_DOCTYPE_COLOR
      }
    },
    ObjectPreview: {
      objectDescription: {
        fontStyle: "italic"
      },
      preview: {
        fontStyle: "italic"
      },
      arrayMaxProperties: theme3.OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES,
      objectMaxProperties: theme3.OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES
    },
    ObjectName: {
      base: {
        color: theme3.OBJECT_NAME_COLOR
      },
      dimmed: {
        opacity: 0.6
      }
    },
    ObjectValue: {
      objectValueNull: {
        color: theme3.OBJECT_VALUE_NULL_COLOR
      },
      objectValueUndefined: {
        color: theme3.OBJECT_VALUE_UNDEFINED_COLOR
      },
      objectValueRegExp: {
        color: theme3.OBJECT_VALUE_REGEXP_COLOR
      },
      objectValueString: {
        color: theme3.OBJECT_VALUE_STRING_COLOR
      },
      objectValueSymbol: {
        color: theme3.OBJECT_VALUE_SYMBOL_COLOR
      },
      objectValueNumber: {
        color: theme3.OBJECT_VALUE_NUMBER_COLOR
      },
      objectValueBoolean: {
        color: theme3.OBJECT_VALUE_BOOLEAN_COLOR
      },
      objectValueFunctionPrefix: {
        color: theme3.OBJECT_VALUE_FUNCTION_PREFIX_COLOR,
        fontStyle: "italic"
      },
      objectValueFunctionName: {
        fontStyle: "italic"
      }
    },
    TreeView: {
      treeViewOutline: {
        padding: 0,
        margin: 0,
        listStyleType: "none"
      }
    },
    TreeNode: {
      treeNodeBase: {
        color: theme3.BASE_COLOR,
        backgroundColor: theme3.BASE_BACKGROUND_COLOR,
        lineHeight: theme3.TREENODE_LINE_HEIGHT,
        cursor: "default",
        boxSizing: "border-box",
        listStyle: "none",
        fontFamily: theme3.TREENODE_FONT_FAMILY,
        fontSize: theme3.TREENODE_FONT_SIZE
      },
      treeNodePreviewContainer: {},
      treeNodePlaceholder: {
        whiteSpace: "pre",
        fontSize: theme3.ARROW_FONT_SIZE,
        marginRight: theme3.ARROW_MARGIN_RIGHT,
        ...unselectable
      },
      treeNodeArrow: {
        base: {
          color: theme3.ARROW_COLOR,
          display: "inline-block",
          fontSize: theme3.ARROW_FONT_SIZE,
          marginRight: theme3.ARROW_MARGIN_RIGHT,
          ...parseFloat(theme3.ARROW_ANIMATION_DURATION) > 0 ? {
            transition: `transform ${theme3.ARROW_ANIMATION_DURATION} ease 0s`
          } : {},
          ...unselectable
        },
        expanded: {
          WebkitTransform: "rotateZ(90deg)",
          MozTransform: "rotateZ(90deg)",
          transform: "rotateZ(90deg)"
        },
        collapsed: {
          WebkitTransform: "rotateZ(0deg)",
          MozTransform: "rotateZ(0deg)",
          transform: "rotateZ(0deg)"
        }
      },
      treeNodeChildNodesContainer: {
        margin: 0,
        paddingLeft: theme3.TREENODE_PADDING_LEFT
      }
    },
    TableInspector: {
      base: {
        color: theme3.BASE_COLOR,
        position: "relative",
        border: `1px solid ${theme3.TABLE_BORDER_COLOR}`,
        fontFamily: theme3.BASE_FONT_FAMILY,
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%",
        boxSizing: "border-box",
        cursor: "default"
      }
    },
    TableInspectorHeaderContainer: {
      base: {
        top: 0,
        height: "17px",
        left: 0,
        right: 0,
        overflowX: "hidden"
      },
      table: {
        tableLayout: "fixed",
        borderSpacing: 0,
        borderCollapse: "separate",
        height: "100%",
        width: "100%",
        margin: 0
      }
    },
    TableInspectorDataContainer: {
      tr: {
        display: "table-row"
      },
      td: {
        boxSizing: "border-box",
        border: "none",
        height: "16px",
        verticalAlign: "top",
        padding: "1px 4px",
        WebkitUserSelect: "text",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        lineHeight: "14px"
      },
      div: {
        position: "static",
        top: "17px",
        bottom: 0,
        overflowY: "overlay",
        transform: "translateZ(0)",
        left: 0,
        right: 0,
        overflowX: "hidden"
      },
      table: {
        positon: "static",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        borderTop: "0 none transparent",
        margin: 0,
        backgroundImage: theme3.TABLE_DATA_BACKGROUND_IMAGE,
        backgroundSize: theme3.TABLE_DATA_BACKGROUND_SIZE,
        tableLayout: "fixed",
        borderSpacing: 0,
        borderCollapse: "separate",
        width: "100%",
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%"
      }
    },
    TableInspectorTH: {
      base: {
        position: "relative",
        height: "auto",
        textAlign: "left",
        backgroundColor: theme3.TABLE_TH_BACKGROUND_COLOR,
        borderBottom: `1px solid ${theme3.TABLE_BORDER_COLOR}`,
        fontWeight: "normal",
        verticalAlign: "middle",
        padding: "0 4px",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        lineHeight: "14px",
        ":hover": {
          backgroundColor: theme3.TABLE_TH_HOVER_COLOR
        }
      },
      div: {
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        fontSize: theme3.BASE_FONT_SIZE,
        lineHeight: "120%"
      }
    },
    TableInspectorLeftBorder: {
      none: {
        borderLeft: "none"
      },
      solid: {
        borderLeft: `1px solid ${theme3.TABLE_BORDER_COLOR}`
      }
    },
    TableInspectorSortIcon: {
      display: "block",
      marginRight: 3,
      width: 8,
      height: 7,
      marginTop: -7,
      color: theme3.TABLE_SORT_ICON_COLOR,
      fontSize: 12,
      ...unselectable
    }
  }), "createTheme"), DEFAULT_THEME_NAME = "chromeLight", ThemeContext = createContext(createTheme(themes_exports[DEFAULT_THEME_NAME])), useStyles = __name((baseStylesKey) => useContext(ThemeContext)[baseStylesKey], "useStyles"), themeAcceptor = __name((WrappedComponent) => __name(({ theme: theme3 = DEFAULT_THEME_NAME, ...restProps }) => {
    let themeStyles = useMemo(() => {
      switch (Object.prototype.toString.call(theme3)) {
        case "[object String]":
          return createTheme(themes_exports[theme3]);
        case "[object Object]":
          return createTheme(theme3);
        default:
          return createTheme(themes_exports[DEFAULT_THEME_NAME]);
      }
    }, [theme3]);
    return react_default.createElement(ThemeContext.Provider, {
      value: themeStyles
    }, react_default.createElement(WrappedComponent, {
      ...restProps
    }));
  }, "ThemeAcceptor"), "themeAcceptor"), Arrow = __name(({ expanded, styles: styles2 }) => react_default.createElement("span", {
    style: {
      ...styles2.base,
      ...expanded ? styles2.expanded : styles2.collapsed
    }
  }, "\u25B6"), "Arrow"), TreeNode = memo((props) => {
    props = {
      expanded: !0,
      nodeRenderer: __name(({ name }) => react_default.createElement("span", null, name), "nodeRenderer"),
      onClick: __name(() => {
      }, "onClick"),
      shouldShowArrow: !1,
      shouldShowPlaceholder: !0,
      ...props
    };
    let { expanded, onClick, children, nodeRenderer, title, shouldShowArrow, shouldShowPlaceholder } = props, styles2 = useStyles("TreeNode"), NodeRenderer = nodeRenderer;
    return react_default.createElement("li", {
      "aria-expanded": expanded,
      role: "treeitem",
      style: styles2.treeNodeBase,
      title
    }, react_default.createElement("div", {
      style: styles2.treeNodePreviewContainer,
      onClick
    }, shouldShowArrow || Children.count(children) > 0 ? react_default.createElement(Arrow, {
      expanded,
      styles: styles2.treeNodeArrow
    }) : shouldShowPlaceholder && react_default.createElement("span", {
      style: styles2.treeNodePlaceholder
    }, "\xA0"), react_default.createElement(NodeRenderer, {
      ...props
    })), react_default.createElement("ol", {
      role: "group",
      style: styles2.treeNodeChildNodesContainer
    }, expanded ? children : void 0));
  }), DEFAULT_ROOT_PATH = "$", WILDCARD = "*";
  function hasChildNodes(data, dataIterator) {
    return !dataIterator(data).next().done;
  }
  __name(hasChildNodes, "hasChildNodes");
  var wildcardPathsFromLevel = __name((level) => Array.from({ length: level }, (_22, i22) => [DEFAULT_ROOT_PATH].concat(Array.from({ length: i22 }, () => "*")).join(".")), "wildcardPathsFromLevel"), getExpandedPaths = __name((data, dataIterator, expandPaths, expandLevel, prevExpandedPaths) => {
    let wildcardPaths = [].concat(wildcardPathsFromLevel(expandLevel)).concat(expandPaths).filter((path) => typeof path == "string"), expandedPaths = [];
    return wildcardPaths.forEach((wildcardPath) => {
      let keyPaths = wildcardPath.split("."), populatePaths = __name((curData, curPath, depth) => {
        if (depth === keyPaths.length) {
          expandedPaths.push(curPath);
          return;
        }
        let key = keyPaths[depth];
        if (depth === 0)
          hasChildNodes(curData, dataIterator) && (key === DEFAULT_ROOT_PATH || key === WILDCARD) && populatePaths(curData, DEFAULT_ROOT_PATH, depth + 1);
        else if (key === WILDCARD)
          for (let { name, data: data2 } of dataIterator(curData))
            hasChildNodes(data2, dataIterator) && populatePaths(data2, `${curPath}.${name}`, depth + 1);
        else {
          let value2 = curData[key];
          hasChildNodes(value2, dataIterator) && populatePaths(value2, `${curPath}.${key}`, depth + 1);
        }
      }, "populatePaths");
      populatePaths(data, "", 0);
    }), expandedPaths.reduce((obj, path) => (obj[path] = !0, obj), { ...prevExpandedPaths });
  }, "getExpandedPaths"), ConnectedTreeNode = memo((props) => {
    let { data, dataIterator, path, depth, nodeRenderer } = props, [expandedPaths, setExpandedPaths] = useContext(ExpandedPathsContext), nodeHasChildNodes = hasChildNodes(data, dataIterator), expanded = !!expandedPaths[path], handleClick = useCallback(() => nodeHasChildNodes && setExpandedPaths((prevExpandedPaths) => ({
      ...prevExpandedPaths,
      [path]: !expanded
    })), [nodeHasChildNodes, setExpandedPaths, path, expanded]);
    return react_default.createElement(TreeNode, {
      expanded,
      onClick: handleClick,
      shouldShowArrow: nodeHasChildNodes,
      shouldShowPlaceholder: depth > 0,
      nodeRenderer,
      ...props
    }, expanded ? [...dataIterator(data)].map(({ name, data: data2, ...renderNodeProps }) => react_default.createElement(ConnectedTreeNode, {
      name,
      data: data2,
      depth: depth + 1,
      path: `${path}.${name}`,
      key: name,
      dataIterator,
      nodeRenderer,
      ...renderNodeProps
    })) : null);
  }), TreeView = memo(({ name, data, dataIterator, nodeRenderer, expandPaths, expandLevel }) => {
    let styles2 = useStyles("TreeView"), stateAndSetter = useState({}), [, setExpandedPaths] = stateAndSetter;
    return useLayoutEffect(() => setExpandedPaths((prevExpandedPaths) => getExpandedPaths(data, dataIterator, expandPaths, expandLevel, prevExpandedPaths)), [data, dataIterator, expandPaths, expandLevel]), react_default.createElement(ExpandedPathsContext.Provider, {
      value: stateAndSetter
    }, react_default.createElement("ol", {
      role: "tree",
      style: styles2.treeViewOutline
    }, react_default.createElement(ConnectedTreeNode, {
      name,
      data,
      dataIterator,
      depth: 0,
      path: DEFAULT_ROOT_PATH,
      nodeRenderer
    })));
  }), ObjectName = __name(({ name, dimmed = !1, styles: styles2 = {} }) => {
    let themeStyles = useStyles("ObjectName"), appliedStyles = {
      ...themeStyles.base,
      ...dimmed ? themeStyles.dimmed : {},
      ...styles2
    };
    return react_default.createElement("span", {
      style: appliedStyles
    }, name);
  }, "ObjectName"), ObjectValue = __name(({ object: object2, styles: styles2 }) => {
    let themeStyles = useStyles("ObjectValue"), mkStyle = __name((key) => ({ ...themeStyles[key], ...styles2 }), "mkStyle");
    switch (typeof object2) {
      case "bigint":
        return react_default.createElement("span", {
          style: mkStyle("objectValueNumber")
        }, String(object2), "n");
      case "number":
        return react_default.createElement("span", {
          style: mkStyle("objectValueNumber")
        }, String(object2));
      case "string":
        return react_default.createElement("span", {
          style: mkStyle("objectValueString")
        }, '"', object2, '"');
      case "boolean":
        return react_default.createElement("span", {
          style: mkStyle("objectValueBoolean")
        }, String(object2));
      case "undefined":
        return react_default.createElement("span", {
          style: mkStyle("objectValueUndefined")
        }, "undefined");
      case "object":
        return object2 === null ? react_default.createElement("span", {
          style: mkStyle("objectValueNull")
        }, "null") : object2 instanceof Date ? react_default.createElement("span", null, object2.toString()) : object2 instanceof RegExp ? react_default.createElement("span", {
          style: mkStyle("objectValueRegExp")
        }, object2.toString()) : Array.isArray(object2) ? react_default.createElement("span", null, `Array(${object2.length})`) : object2.constructor ? typeof object2.constructor.isBuffer == "function" && object2.constructor.isBuffer(object2) ? react_default.createElement("span", null, `Buffer[${object2.length}]`) : react_default.createElement("span", null, object2.constructor.name) : react_default.createElement("span", null, "Object");
      case "function":
        return react_default.createElement("span", null, react_default.createElement("span", {
          style: mkStyle("objectValueFunctionPrefix")
        }, "\u0192\xA0"), react_default.createElement("span", {
          style: mkStyle("objectValueFunctionName")
        }, object2.name, "()"));
      case "symbol":
        return react_default.createElement("span", {
          style: mkStyle("objectValueSymbol")
        }, object2.toString());
      default:
        return react_default.createElement("span", null);
    }
  }, "ObjectValue"), hasOwnProperty = Object.prototype.hasOwnProperty, propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
  function getPropertyValue(object2, propertyName) {
    let propertyDescriptor = Object.getOwnPropertyDescriptor(object2, propertyName);
    if (propertyDescriptor.get)
      try {
        return propertyDescriptor.get();
      } catch {
        return propertyDescriptor.get;
      }
    return object2[propertyName];
  }
  __name(getPropertyValue, "getPropertyValue");
  function intersperse(arr, sep) {
    return arr.length === 0 ? [] : arr.slice(1).reduce((xs, x22) => xs.concat([sep, x22]), [arr[0]]);
  }
  __name(intersperse, "intersperse");
  var ObjectPreview = __name(({ data }) => {
    let styles2 = useStyles("ObjectPreview"), object2 = data;
    if (typeof object2 != "object" || object2 === null || object2 instanceof Date || object2 instanceof RegExp)
      return react_default.createElement(ObjectValue, {
        object: object2
      });
    if (Array.isArray(object2)) {
      let maxProperties = styles2.arrayMaxProperties, previewArray = object2.slice(0, maxProperties).map((element, index2) => react_default.createElement(ObjectValue, {
        key: index2,
        object: element
      }));
      object2.length > maxProperties && previewArray.push(react_default.createElement("span", {
        key: "ellipsis"
      }, "\u2026"));
      let arrayLength = object2.length;
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
        style: styles2.objectDescription
      }, arrayLength === 0 ? "" : `(${arrayLength})\xA0`), react_default.createElement("span", {
        style: styles2.preview
      }, "[", intersperse(previewArray, ", "), "]"));
    } else {
      let maxProperties = styles2.objectMaxProperties, propertyNodes = [];
      for (let propertyName in object2)
        if (hasOwnProperty.call(object2, propertyName)) {
          let ellipsis;
          propertyNodes.length === maxProperties - 1 && Object.keys(object2).length > maxProperties && (ellipsis = react_default.createElement("span", {
            key: "ellipsis"
          }, "\u2026"));
          let propertyValue = getPropertyValue(object2, propertyName);
          if (propertyNodes.push(react_default.createElement("span", {
            key: propertyName
          }, react_default.createElement(ObjectName, {
            name: propertyName || '""'
          }), ":\xA0", react_default.createElement(ObjectValue, {
            object: propertyValue
          }), ellipsis)), ellipsis)
            break;
        }
      let objectConstructorName = object2.constructor ? object2.constructor.name : "Object";
      return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
        style: styles2.objectDescription
      }, objectConstructorName === "Object" ? "" : `${objectConstructorName} `), react_default.createElement("span", {
        style: styles2.preview
      }, "{", intersperse(propertyNodes, ", "), "}"));
    }
  }, "ObjectPreview"), ObjectRootLabel = __name(({ name, data }) => typeof name == "string" ? react_default.createElement("span", null, react_default.createElement(ObjectName, {
    name
  }), react_default.createElement("span", null, ": "), react_default.createElement(ObjectPreview, {
    data
  })) : react_default.createElement(ObjectPreview, {
    data
  }), "ObjectRootLabel"), ObjectLabel = __name(({ name, data, isNonenumerable = !1 }) => {
    let object2 = data;
    return react_default.createElement("span", null, typeof name == "string" ? react_default.createElement(ObjectName, {
      name,
      dimmed: isNonenumerable
    }) : react_default.createElement(ObjectPreview, {
      data: name
    }), react_default.createElement("span", null, ": "), react_default.createElement(ObjectValue, {
      object: object2
    }));
  }, "ObjectLabel"), createIterator = __name((showNonenumerable, sortObjectKeys) => __name(function* (data) {
    if (!(typeof data == "object" && data !== null || typeof data == "function"))
      return;
    let dataIsArray = Array.isArray(data);
    if (!dataIsArray && data[Symbol.iterator]) {
      let i22 = 0;
      for (let entry of data) {
        if (Array.isArray(entry) && entry.length === 2) {
          let [k22, v22] = entry;
          yield {
            name: k22,
            data: v22
          };
        } else
          yield {
            name: i22.toString(),
            data: entry
          };
        i22++;
      }
    } else {
      let keys = Object.getOwnPropertyNames(data);
      sortObjectKeys === !0 && !dataIsArray ? keys.sort() : typeof sortObjectKeys == "function" && keys.sort(sortObjectKeys);
      for (let propertyName of keys)
        if (propertyIsEnumerable.call(data, propertyName)) {
          let propertyValue = getPropertyValue(data, propertyName);
          yield {
            name: propertyName || '""',
            data: propertyValue
          };
        } else if (showNonenumerable) {
          let propertyValue;
          try {
            propertyValue = getPropertyValue(data, propertyName);
          } catch {
          }
          propertyValue !== void 0 && (yield {
            name: propertyName,
            data: propertyValue,
            isNonenumerable: !0
          });
        }
      showNonenumerable && data !== Object.prototype && (yield {
        name: "__proto__",
        data: Object.getPrototypeOf(data),
        isNonenumerable: !0
      });
    }
  }, "objectIterator"), "createIterator"), defaultNodeRenderer = __name(({ depth, name, data, isNonenumerable }) => depth === 0 ? react_default.createElement(ObjectRootLabel, {
    name,
    data
  }) : react_default.createElement(ObjectLabel, {
    name,
    data,
    isNonenumerable
  }), "defaultNodeRenderer"), ObjectInspector = __name(({ showNonenumerable = !1, sortObjectKeys, nodeRenderer, ...treeViewProps }) => {
    let dataIterator = createIterator(showNonenumerable, sortObjectKeys), renderer = nodeRenderer || defaultNodeRenderer;
    return react_default.createElement(TreeView, {
      nodeRenderer: renderer,
      dataIterator,
      ...treeViewProps
    });
  }, "ObjectInspector"), themedObjectInspector = themeAcceptor(ObjectInspector);
  function getHeaders(data) {
    if (typeof data == "object") {
      let rowHeaders = [];
      if (Array.isArray(data)) {
        let nRows = data.length;
        rowHeaders = [...Array(nRows).keys()];
      } else data !== null && (rowHeaders = Object.keys(data));
      let colHeaders = rowHeaders.reduce((colHeaders2, rowHeader) => {
        let row = data[rowHeader];
        return typeof row == "object" && row !== null && Object.keys(row).reduce((xs, x22) => (xs.includes(x22) || xs.push(x22), xs), colHeaders2), colHeaders2;
      }, []);
      return {
        rowHeaders,
        colHeaders
      };
    }
  }
  __name(getHeaders, "getHeaders");
  var DataContainer = __name(({ rows, columns, rowsData }) => {
    let styles2 = useStyles("TableInspectorDataContainer"), borderStyles = useStyles("TableInspectorLeftBorder");
    return react_default.createElement("div", {
      style: styles2.div
    }, react_default.createElement("table", {
      style: styles2.table
    }, react_default.createElement("colgroup", null), react_default.createElement("tbody", null, rows.map((row, i22) => react_default.createElement("tr", {
      key: row,
      style: styles2.tr
    }, react_default.createElement("td", {
      style: { ...styles2.td, ...borderStyles.none }
    }, row), columns.map((column) => {
      let rowData = rowsData[i22];
      return typeof rowData == "object" && rowData !== null && hasOwnProperty.call(rowData, column) ? react_default.createElement("td", {
        key: column,
        style: { ...styles2.td, ...borderStyles.solid }
      }, react_default.createElement(ObjectValue, {
        object: rowData[column]
      })) : react_default.createElement("td", {
        key: column,
        style: { ...styles2.td, ...borderStyles.solid }
      });
    }))))));
  }, "DataContainer"), SortIconContainer = __name((props) => react_default.createElement("div", {
    style: {
      position: "absolute",
      top: 1,
      right: 0,
      bottom: 1,
      display: "flex",
      alignItems: "center"
    }
  }, props.children), "SortIconContainer"), SortIcon = __name(({ sortAscending }) => {
    let styles2 = useStyles("TableInspectorSortIcon"), glyph = sortAscending ? "\u25B2" : "\u25BC";
    return react_default.createElement("div", {
      style: styles2
    }, glyph);
  }, "SortIcon"), TH = __name(({
    sortAscending = !1,
    sorted = !1,
    onClick = void 0,
    borderStyle = {},
    children,
    ...thProps
  }) => {
    let styles2 = useStyles("TableInspectorTH"), [hovered, setHovered] = useState(!1), handleMouseEnter = useCallback(() => setHovered(!0), []), handleMouseLeave = useCallback(() => setHovered(!1), []);
    return react_default.createElement("th", {
      ...thProps,
      style: {
        ...styles2.base,
        ...borderStyle,
        ...hovered ? styles2.base[":hover"] : {}
      },
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick
    }, react_default.createElement("div", {
      style: styles2.div
    }, children), sorted && react_default.createElement(SortIconContainer, null, react_default.createElement(SortIcon, {
      sortAscending
    })));
  }, "TH"), HeaderContainer = __name(({
    indexColumnText = "(index)",
    columns = [],
    sorted,
    sortIndexColumn,
    sortColumn,
    sortAscending,
    onTHClick,
    onIndexTHClick
  }) => {
    let styles2 = useStyles("TableInspectorHeaderContainer"), borderStyles = useStyles("TableInspectorLeftBorder");
    return react_default.createElement("div", {
      style: styles2.base
    }, react_default.createElement("table", {
      style: styles2.table
    }, react_default.createElement("tbody", null, react_default.createElement("tr", null, react_default.createElement(TH, {
      borderStyle: borderStyles.none,
      sorted: sorted && sortIndexColumn,
      sortAscending,
      onClick: onIndexTHClick
    }, indexColumnText), columns.map((column) => react_default.createElement(TH, {
      borderStyle: borderStyles.solid,
      key: column,
      sorted: sorted && sortColumn === column,
      sortAscending,
      onClick: onTHClick.bind(null, column)
    }, column))))));
  }, "HeaderContainer"), TableInspector = __name(({
    data,
    columns
  }) => {
    let styles2 = useStyles("TableInspector"), [{ sorted, sortIndexColumn, sortColumn, sortAscending }, setState] = useState({
      sorted: !1,
      sortIndexColumn: !1,
      sortColumn: void 0,
      sortAscending: !1
    }), handleIndexTHClick = useCallback(() => {
      setState(({ sortIndexColumn: sortIndexColumn2, sortAscending: sortAscending2 }) => ({
        sorted: !0,
        sortIndexColumn: !0,
        sortColumn: void 0,
        sortAscending: sortIndexColumn2 ? !sortAscending2 : !0
      }));
    }, []), handleTHClick = useCallback((col) => {
      setState(({ sortColumn: sortColumn2, sortAscending: sortAscending2 }) => ({
        sorted: !0,
        sortIndexColumn: !1,
        sortColumn: col,
        sortAscending: col === sortColumn2 ? !sortAscending2 : !0
      }));
    }, []);
    if (typeof data != "object" || data === null)
      return react_default.createElement("div", null);
    let { rowHeaders, colHeaders } = getHeaders(data);
    columns !== void 0 && (colHeaders = columns);
    let rowsData = rowHeaders.map((rowHeader) => data[rowHeader]), columnDataWithRowIndexes;
    if (sortColumn !== void 0 ? columnDataWithRowIndexes = rowsData.map((rowData, index2) => typeof rowData == "object" && rowData !== null ? [rowData[sortColumn], index2] : [void 0, index2]) : sortIndexColumn && (columnDataWithRowIndexes = rowHeaders.map((rowData, index2) => [rowHeaders[index2], index2])), columnDataWithRowIndexes !== void 0) {
      let comparator = __name((mapper, ascending) => (a22, b22) => {
        let v1 = mapper(a22), v22 = mapper(b22), type1 = typeof v1, type2 = typeof v22, lt = __name((v12, v222) => v12 < v222 ? -1 : v12 > v222 ? 1 : 0, "lt"), result;
        if (type1 === type2)
          result = lt(v1, v22);
        else {
          let order = {
            string: 0,
            number: 1,
            object: 2,
            symbol: 3,
            boolean: 4,
            undefined: 5,
            function: 6
          };
          result = lt(order[type1], order[type2]);
        }
        return ascending || (result = -result), result;
      }, "comparator"), sortedRowIndexes = columnDataWithRowIndexes.sort(comparator((item) => item[0], sortAscending)).map((item) => item[1]);
      rowHeaders = sortedRowIndexes.map((i22) => rowHeaders[i22]), rowsData = sortedRowIndexes.map((i22) => rowsData[i22]);
    }
    return react_default.createElement("div", {
      style: styles2.base
    }, react_default.createElement(HeaderContainer, {
      columns: colHeaders,
      sorted,
      sortIndexColumn,
      sortColumn,
      sortAscending,
      onTHClick: handleTHClick,
      onIndexTHClick: handleIndexTHClick
    }), react_default.createElement(DataContainer, {
      rows: rowHeaders,
      columns: colHeaders,
      rowsData
    }));
  }, "TableInspector"), themedTableInspector = themeAcceptor(TableInspector), TEXT_NODE_MAX_INLINE_CHARS = 80, shouldInline = __name((data) => data.childNodes.length === 0 || data.childNodes.length === 1 && data.childNodes[0].nodeType === Node.TEXT_NODE && data.textContent.length < TEXT_NODE_MAX_INLINE_CHARS, "shouldInline"), OpenTag = __name(({ tagName, attributes, styles: styles2 }) => react_default.createElement("span", {
    style: styles2.base
  }, "<", react_default.createElement("span", {
    style: styles2.tagName
  }, tagName), (() => {
    if (attributes) {
      let attributeNodes = [];
      for (let i22 = 0; i22 < attributes.length; i22++) {
        let attribute = attributes[i22];
        attributeNodes.push(react_default.createElement("span", {
          key: i22
        }, " ", react_default.createElement("span", {
          style: styles2.htmlAttributeName
        }, attribute.name), '="', react_default.createElement("span", {
          style: styles2.htmlAttributeValue
        }, attribute.value), '"'));
      }
      return attributeNodes;
    }
  })(), ">"), "OpenTag"), CloseTag = __name(({ tagName, isChildNode = !1, styles: styles2 }) => react_default.createElement("span", {
    style: Object.assign({}, styles2.base, isChildNode && styles2.offsetLeft)
  }, "</", react_default.createElement("span", {
    style: styles2.tagName
  }, tagName), ">"), "CloseTag"), nameByNodeType = {
    1: "ELEMENT_NODE",
    3: "TEXT_NODE",
    7: "PROCESSING_INSTRUCTION_NODE",
    8: "COMMENT_NODE",
    9: "DOCUMENT_NODE",
    10: "DOCUMENT_TYPE_NODE",
    11: "DOCUMENT_FRAGMENT_NODE"
  }, DOMNodePreview = __name(({ isCloseTag, data, expanded }) => {
    let styles2 = useStyles("DOMNodePreview");
    if (isCloseTag)
      return react_default.createElement(CloseTag, {
        styles: styles2.htmlCloseTag,
        isChildNode: !0,
        tagName: data.tagName
      });
    switch (data.nodeType) {
      case Node.ELEMENT_NODE:
        return react_default.createElement("span", null, react_default.createElement(OpenTag, {
          tagName: data.tagName,
          attributes: data.attributes,
          styles: styles2.htmlOpenTag
        }), shouldInline(data) ? data.textContent : !expanded && "\u2026", !expanded && react_default.createElement(CloseTag, {
          tagName: data.tagName,
          styles: styles2.htmlCloseTag
        }));
      case Node.TEXT_NODE:
        return react_default.createElement("span", null, data.textContent);
      case Node.CDATA_SECTION_NODE:
        return react_default.createElement("span", null, "<![CDATA[" + data.textContent + "]]>");
      case Node.COMMENT_NODE:
        return react_default.createElement("span", {
          style: styles2.htmlComment
        }, "<!--", data.textContent, "-->");
      case Node.PROCESSING_INSTRUCTION_NODE:
        return react_default.createElement("span", null, data.nodeName);
      case Node.DOCUMENT_TYPE_NODE:
        return react_default.createElement("span", {
          style: styles2.htmlDoctype
        }, "<!DOCTYPE ", data.name, data.publicId ? ` PUBLIC "${data.publicId}"` : "", !data.publicId && data.systemId ? " SYSTEM" : "", data.systemId ? ` "${data.systemId}"` : "", ">");
      case Node.DOCUMENT_NODE:
        return react_default.createElement("span", null, data.nodeName);
      case Node.DOCUMENT_FRAGMENT_NODE:
        return react_default.createElement("span", null, data.nodeName);
      default:
        return react_default.createElement("span", null, nameByNodeType[data.nodeType]);
    }
  }, "DOMNodePreview"), domIterator = __name(function* (data) {
    if (data && data.childNodes) {
      if (shouldInline(data))
        return;
      for (let i22 = 0; i22 < data.childNodes.length; i22++) {
        let node = data.childNodes[i22];
        node.nodeType === Node.TEXT_NODE && node.textContent.trim().length === 0 || (yield {
          name: `${node.tagName}[${i22}]`,
          data: node
        });
      }
      data.tagName && (yield {
        name: "CLOSE_TAG",
        data: {
          tagName: data.tagName
        },
        isCloseTag: !0
      });
    }
  }, "domIterator"), DOMInspector = __name((props) => react_default.createElement(TreeView, {
    nodeRenderer: DOMNodePreview,
    dataIterator: domIterator,
    ...props
  }), "DOMInspector"), themedDOMInspector = themeAcceptor(DOMInspector), import_is_dom = __toESM2(require_is_dom()), Inspector = __name(({ table = !1, data, ...rest }) => table ? react_default.createElement(themedTableInspector, {
    data,
    ...rest
  }) : (0, import_is_dom.default)(data) ? react_default.createElement(themedDOMInspector, {
    data,
    ...rest
  }) : react_default.createElement(themedObjectInspector, {
    data,
    ...rest
  }), "Inspector"), Action = styled.div({
    display: "flex",
    padding: 0,
    borderLeft: "5px solid transparent",
    borderBottom: "1px solid transparent",
    transition: "all 0.1s",
    alignItems: "flex-start",
    whiteSpace: "pre"
  }), Counter = styled.div(({ theme: theme3 }) => ({
    backgroundColor: curriedOpacify$1(0.5, theme3.appBorderColor),
    color: theme3.color.inverseText,
    fontSize: theme3.typography.size.s1,
    fontWeight: theme3.typography.weight.bold,
    lineHeight: 1,
    padding: "1px 5px",
    borderRadius: 20,
    margin: "2px 0px"
  })), InspectorContainer = styled.div({
    flex: 1,
    padding: "0 0 0 5px"
  }), UnstyledWrapped = forwardRef(
    ({ children, className }, ref) => react_default.createElement(ScrollArea, { ref, horizontal: !0, vertical: !0, className }, children)
  );
  UnstyledWrapped.displayName = "UnstyledWrapped";
  var Wrapper10 = styled(UnstyledWrapped)({
    margin: 0,
    padding: "10px 5px 20px"
  }), ThemedInspector = withTheme(({ theme: theme3, ...props }) => react_default.createElement(Inspector, { theme: theme3.addonActionsTheme || "chromeLight", table: !1, ...props })), ActionLogger = __name(({ actions: actions2, onClear }) => {
    let wrapperRef = useRef(null), wrapper = wrapperRef.current, wasAtBottom = wrapper && wrapper.scrollHeight - wrapper.scrollTop === wrapper.clientHeight;
    return useEffect(() => {
      wasAtBottom && (wrapperRef.current.scrollTop = wrapperRef.current.scrollHeight);
    }, [wasAtBottom, actions2.length]), react_default.createElement(Fragment, null, react_default.createElement(Wrapper10, { ref: wrapperRef }, actions2.map((action2) => react_default.createElement(Action, { key: action2.id }, action2.count > 1 && react_default.createElement(Counter, null, action2.count), react_default.createElement(InspectorContainer, null, react_default.createElement(
      ThemedInspector,
      {
        sortObjectKeys: !0,
        showNonenumerable: !1,
        name: action2.data.name,
        data: action2.data.args ?? action2.data
      }
    ))))), react_default.createElement(ActionBar, { actionItems: [{ title: "Clear", onClick: onClear }] }));
  }, "ActionLogger"), safeDeepEqual = __name((a22, b22) => {
    try {
      return dequal(a22, b22);
    } catch {
      return !1;
    }
  }, "safeDeepEqual"), _ActionLogger = class extends Component {
    constructor(props) {
      super(props), this.handleStoryChange = __name(() => {
        let { actions: actions2 } = this.state;
        actions2.length > 0 && actions2[0].options.clearOnStoryChange && this.clearActions();
      }, "handleStoryChange"), this.addAction = __name((action2) => {
        this.setState((prevState) => {
          let actions2 = [...prevState.actions], previous = actions2.length && actions2[actions2.length - 1];
          return previous && safeDeepEqual(previous.data, action2.data) ? previous.count++ : (action2.count = 1, actions2.push(action2)), { actions: actions2.slice(0, action2.options.limit) };
        });
      }, "addAction"), this.clearActions = __name(() => {
        let { api } = this.props;
        api.emit(CLEAR_ID), this.setState({ actions: [] });
      }, "clearActions"), this.mounted = !1, this.state = { actions: [] };
    }
    componentDidMount() {
      this.mounted = !0;
      let { api } = this.props;
      api.on(EVENT_ID, this.addAction), api.on(STORY_CHANGED, this.handleStoryChange);
    }
    componentWillUnmount() {
      this.mounted = !1;
      let { api } = this.props;
      api.off(STORY_CHANGED, this.handleStoryChange), api.off(EVENT_ID, this.addAction);
    }
    render() {
      let { actions: actions2 = [] } = this.state, { active } = this.props, props = {
        actions: actions2,
        onClear: this.clearActions
      };
      return active ? react_default.createElement(ActionLogger, { ...props }) : null;
    }
  };
  __name(_ActionLogger, "ActionLogger");
  var ActionLogger2 = _ActionLogger, manager_default2 = addons.register(ADDON_ID4, (api) => {
    globalThis?.FEATURES?.actions && addons.add(PANEL_ID, {
      title: Title3,
      type: types.PANEL,
      render: __name(({ active }) => react_default.createElement(ActionLogger2, { api, active: !!active }), "render"),
      paramKey: PARAM_KEY4
    });
  }), ADDON_ID72 = "storybook/interactions", PANEL_ID22 = `${ADDON_ID72}/panel`, DOCUMENTATION_LINK = "writing-tests/integrations/vitest-addon", DOCUMENTATION_DISCREPANCY_LINK = `${DOCUMENTATION_LINK}#what-happens-when-there-are-different-test-results-in-multiple-environments`, DOCUMENTATION_PLAY_FUNCTION_LINK = "writing-stories/play-function#writing-stories-with-the-play-function", INTERNAL_RENDER_CALL_ID = "internal_render_call", ADDON_ID8 = "storybook/a11y", PANEL_ID32 = `${ADDON_ID8}/panel`, UI_STATE_ID = `${ADDON_ID8}/ui`, RESULT = `${ADDON_ID8}/result`, REQUEST = `${ADDON_ID8}/request`, RUNNING = `${ADDON_ID8}/running`, ERROR2 = `${ADDON_ID8}/error`, MANUAL = `${ADDON_ID8}/manual`, SELECT = `${ADDON_ID8}/select`, DOCUMENTATION_LINK2 = "writing-tests/accessibility-testing", DOCUMENTATION_DISCREPANCY_LINK2 = `${DOCUMENTATION_LINK2}#why-are-my-tests-failing-in-different-environments`, ADDON_ID9 = "storybook/test", TEST_PROVIDER_ID = `${ADDON_ID9}/test-provider`, STORYBOOK_ADDON_TEST_CHANNEL = "STORYBOOK_ADDON_TEST_CHANNEL", DOCUMENTATION_LINK3 = "writing-tests/integrations/vitest-addon", DOCUMENTATION_FATAL_ERROR_LINK = `${DOCUMENTATION_LINK3}#what-happens-if-vitest-itself-has-an-error`, storeOptions = {
    id: ADDON_ID9,
    initialState: {
      config: {
        coverage: !1,
        a11y: !1
      },
      watching: !1,
      cancelling: !1,
      fatalError: void 0,
      indexUrl: void 0,
      previewAnnotations: [],
      currentRun: {
        triggeredBy: void 0,
        config: {
          coverage: !1,
          a11y: !1
        },
        componentTestCount: {
          success: 0,
          error: 0
        },
        a11yCount: {
          success: 0,
          warning: 0,
          error: 0
        },
        storyIds: void 0,
        totalTestCount: void 0,
        startedAt: void 0,
        finishedAt: void 0,
        unhandledErrors: [],
        coverageSummary: void 0
      }
    }
  }, STORE_CHANNEL_EVENT_NAME = `UNIVERSAL_STORE:${storeOptions.id}`, STATUS_TYPE_ID_COMPONENT_TEST = "storybook/component-test", import_ansi_to_html2 = __toESM(require_ansi_to_html(), 1);
  function ansiRegex({ onlyFirst = !1 } = {}) {
    let pattern = "(?:\\u001B\\][\\s\\S]*?(?:\\u0007|\\u001B\\u005C|\\u009C))|[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]";
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  }
  __name(ansiRegex, "ansiRegex");
  var regex = ansiRegex();
  function stripAnsi(string) {
    if (typeof string != "string")
      throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    return string.replace(regex, "");
  }
  __name(stripAnsi, "stripAnsi");
  function isTestAssertionError(error) {
    return isChaiError(error) || isJestError(error);
  }
  __name(isTestAssertionError, "isTestAssertionError");
  function isChaiError(error) {
    return error && typeof error == "object" && "name" in error && typeof error.name == "string" && error.name === "AssertionError";
  }
  __name(isChaiError, "isChaiError");
  function isJestError(error) {
    return error && typeof error == "object" && "message" in error && typeof error.message == "string" && stripAnsi(error.message).startsWith("expect(");
  }
  __name(isJestError, "isJestError");
  function createAnsiToHtmlFilter(theme3) {
    return new import_ansi_to_html2.default({
      escapeXML: !0,
      fg: theme3.color.defaultText,
      bg: theme3.background.content
    });
  }
  __name(createAnsiToHtmlFilter, "createAnsiToHtmlFilter");
  function useAnsiToHtmlFilter() {
    let theme3 = useTheme();
    return createAnsiToHtmlFilter(theme3);
  }
  __name(useAnsiToHtmlFilter, "useAnsiToHtmlFilter");
  var Wrapper11 = styled.div(({ theme: { color: color2, typography: typography4, background: background2 } }) => ({
    textAlign: "start",
    padding: "11px 15px",
    fontSize: `${typography4.size.s2 - 1}px`,
    fontWeight: typography4.weight.regular,
    lineHeight: "1rem",
    background: background2.app,
    borderBottom: `1px solid ${color2.border}`,
    color: color2.defaultText,
    backgroundClip: "padding-box",
    position: "relative"
  })), DetachedDebuggerMessage = __name(({ storyUrl }) => react_default.createElement(Wrapper11, null, "Debugger controls are not available on composed Storybooks.", " ", react_default.createElement(
    Link,
    {
      href: `${storyUrl}&addonPanel=${PANEL_ID22}`,
      target: "_blank",
      rel: "noopener noreferrer",
      withArrow: !0
    },
    "Open in external Storybook"
  )), "DetachedDebuggerMessage"), Links2 = styled.div(({ theme: theme3 }) => ({
    display: "flex",
    fontSize: theme3.typography.size.s2 - 1,
    gap: 25
  })), Empty2 = __name(() => {
    let [isLoading, setIsLoading] = useState(!0), docsUrl = useStorybookApi().getDocsUrl({
      subpath: DOCUMENTATION_PLAY_FUNCTION_LINK,
      versioned: !0,
      renderer: !0
    });
    return useEffect(() => {
      let load = setTimeout(() => {
        setIsLoading(!1);
      }, 100);
      return () => clearTimeout(load);
    }, []), isLoading ? null : react_default.createElement("div", null, react_default.createElement(
      EmptyTabContent,
      {
        title: "Interactions",
        description: react_default.createElement(react_default.Fragment, null, "Interactions allow you to verify the functional aspects of UIs. Write a play function for your story and you'll see it run here."),
        footer: react_default.createElement(Links2, null, react_default.createElement(Link, { href: docsUrl, target: "_blank", withArrow: !0 }, react_default.createElement(DocumentIcon, null), " Read docs"))
      }
    ));
  }, "Empty");
  function toVal(mix2) {
    var k22, y22, str2 = "";
    if (mix2)
      if (typeof mix2 == "object")
        if (Array.isArray(mix2))
          for (k22 = 0; k22 < mix2.length; k22++)
            mix2[k22] && (y22 = toVal(mix2[k22])) && (str2 && (str2 += " "), str2 += y22);
        else
          for (k22 in mix2)
            mix2[k22] && (y22 = toVal(k22)) && (str2 && (str2 += " "), str2 += y22);
      else typeof mix2 != "boolean" && !mix2.call && (str2 && (str2 += " "), str2 += mix2);
    return str2;
  }
  __name(toVal, "toVal");
  function clsx_m_default() {
    for (var i22 = 0, x22, str2 = ""; i22 < arguments.length; )
      (x22 = toVal(arguments[i22++])) && (str2 && (str2 += " "), str2 += x22);
    return str2;
  }
  __name(clsx_m_default, "default");
  var isArray = __name((val) => Array.isArray(val) || // Detect https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays
  ArrayBuffer.isView(val) && !(val instanceof DataView), "isArray"), isObject4 = __name((val) => val !== null && typeof val == "object" && !isArray(val) && !(val instanceof Date) && !(val instanceof RegExp) && !(val instanceof Error) && !(val instanceof WeakMap) && !(val instanceof WeakSet), "isObject"), isKnownObject = __name((val) => isObject4(val) || isArray(val) || typeof val == "function" || val instanceof Promise, "isKnownObject"), getPromiseState = __name((promise) => {
    let unique = /unique/;
    return Promise.race([promise, unique]).then((result) => result === unique ? ["pending"] : ["fulfilled", result], (e2) => ["rejected", e2]);
  }, "getPromiseState"), buildAST = __name(async (key, value2, depth, sortKeys, isPrototype, showPrototype) => {
    let astNode = {
      key,
      depth,
      value: value2,
      type: "value",
      parent: void 0
    };
    if (value2 && isKnownObject(value2) && depth < 100) {
      let children = [], t = "object";
      if (isArray(value2)) {
        for (let i22 = 0; i22 < value2.length; i22++)
          children.push(async () => {
            let child = await buildAST(i22.toString(), value2[i22], depth + 1, sortKeys);
            return child.parent = astNode, child;
          });
        t = "array";
      } else {
        let keys = Object.getOwnPropertyNames(value2);
        sortKeys && keys.sort();
        for (let i22 = 0; i22 < keys.length; i22++) {
          let safeValue;
          try {
            safeValue = value2[keys[i22]];
          } catch {
          }
          children.push(async () => {
            let child = await buildAST(keys[i22], safeValue, depth + 1, sortKeys);
            return child.parent = astNode, child;
          });
        }
        if (typeof value2 == "function" && (t = "function"), value2 instanceof Promise) {
          let [status, result] = await getPromiseState(value2);
          children.push(async () => {
            let child = await buildAST("<state>", status, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), status !== "pending" && children.push(async () => {
            let child = await buildAST("<value>", result, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "promise";
        }
        if (value2 instanceof Map) {
          let parsedEntries = Array.from(value2.entries()).map((entry) => {
            let [entryKey, entryValue] = entry;
            return {
              "<key>": entryKey,
              "<value>": entryValue
            };
          });
          children.push(async () => {
            let child = await buildAST("<entries>", parsedEntries, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), children.push(async () => {
            let child = await buildAST("size", value2.size, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "map";
        }
        if (value2 instanceof Set) {
          let parsedEntries = Array.from(value2.entries()).map((entry) => entry[1]);
          children.push(async () => {
            let child = await buildAST("<entries>", parsedEntries, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), children.push(async () => {
            let child = await buildAST("size", value2.size, depth + 1, sortKeys);
            return child.parent = astNode, child;
          }), t = "set";
        }
      }
      value2 !== Object.prototype && showPrototype && children.push(async () => {
        let child = await buildAST("<prototype>", Object.getPrototypeOf(value2), depth + 1, sortKeys, !0);
        return child.parent = astNode, child;
      }), astNode.type = t, astNode.children = children, astNode.isPrototype = isPrototype;
    }
    return astNode;
  }, "buildAST"), parse4 = __name((data, sortKeys, includePrototypes) => buildAST("root", data, 0, sortKeys === !1 ? sortKeys : !0, void 0, includePrototypes === !1 ? includePrototypes : !0), "parse");
  function ownKeys(e2, r2) {
    var t = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  __name(ownKeys, "ownKeys");
  function _objectSpread2(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t = arguments[r2] != null ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t), !0).forEach(function(r3) {
        _defineProperty(e2, r3, t[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t, r3));
      });
    }
    return e2;
  }
  __name(_objectSpread2, "_objectSpread2");
  var _excluded = ["children"], ThemeContext2 = react_default.createContext({
    theme: "chrome",
    colorScheme: "light"
  }), ThemeProvider2 = __name((_ref) => {
    let {
      children
    } = _ref, value2 = _objectWithoutProperties(_ref, _excluded), wrappedTheme = react_default.useContext(ThemeContext2);
    return react_default.createElement(ThemeContext2.Provider, {
      value: _objectSpread2(_objectSpread2({}, wrappedTheme), value2)
    }, children);
  }, "ThemeProvider"), useTheme4 = __name((props, styles2 = {}) => {
    let themeContext = react_default.useContext(ThemeContext2), currentTheme = props.theme || themeContext.theme || "chrome", currentColorScheme = props.colorScheme || themeContext.colorScheme || "light", themeClass = clsx_m_default(styles2[currentTheme], styles2[currentColorScheme]);
    return {
      currentColorScheme,
      currentTheme,
      themeClass
    };
  }, "useTheme"), TreeContext = react_default.createContext({
    isChild: !1,
    depth: 0,
    hasHover: !0
  }), TreeContext_default = TreeContext, Tree_css_default = { tree: "Tree-tree-fbbbe38", item: "Tree-item-353d6f3", group: "Tree-group-d3c3d8a", label: "Tree-label-d819155", focusWhite: "Tree-focusWhite-f1e00c2", arrow: "Tree-arrow-03ab2e7", hover: "Tree-hover-3cc4e5d", open: "Tree-open-3f1a336", dark: "Tree-dark-1b4aa00", chrome: "Tree-chrome-bcbcac6", light: "Tree-light-09174ee" }, _excluded2 = ["theme", "hover", "colorScheme", "children", "label", "className", "onUpdate", "onSelect", "open"], Tree = __name((props) => {
    let {
      theme: theme3,
      hover,
      colorScheme,
      children,
      label,
      className,
      onUpdate,
      onSelect,
      open
    } = props, html = _objectWithoutProperties(props, _excluded2), {
      themeClass,
      currentTheme
    } = useTheme4({
      theme: theme3,
      colorScheme
    }, Tree_css_default), [isOpen, setOpen] = useState(open);
    useEffect(() => {
      setOpen(open);
    }, [open]);
    let updateState = __name((value2) => {
      setOpen(value2), onUpdate && onUpdate(value2);
    }, "updateState"), hasChildren = react_default.Children.count(children) > 0, updateFocus = __name((newNode, previousNode) => {
      if (newNode.isSameNode(previousNode || null)) return;
      let focusableNode = newNode.querySelector('[tabindex="-1"]');
      focusableNode?.focus(), newNode.setAttribute("aria-selected", "true"), previousNode?.removeAttribute("aria-selected");
    }, "updateFocus"), getParent = __name((node, role) => {
      let parent = node;
      for (; parent && parent.parentElement; ) {
        if (parent.getAttribute("role") === role)
          return parent;
        parent = parent.parentElement;
      }
      return null;
    }, "getParent"), getListElements = __name((node) => {
      let tree = getParent(node, "tree");
      return tree ? Array.from(tree.querySelectorAll("li")) : [];
    }, "getListElements"), moveBack = __name((node) => {
      let group = getParent(node, "group"), toggle = group?.previousElementSibling;
      if (toggle && toggle.getAttribute("tabindex") === "-1") {
        let toggleParent = toggle.parentElement, nodeParent = node.parentElement;
        updateFocus(toggleParent, nodeParent);
      }
    }, "moveBack"), moveHome = __name((node, direction) => {
      let elements = getListElements(node);
      elements.forEach((element) => {
        element.removeAttribute("aria-selected");
      }), direction === "start" && elements[0] && updateFocus(elements[0]), direction === "end" && elements[elements.length - 1] && updateFocus(elements[elements.length - 1]);
    }, "moveHome"), moveFocusAdjacent = __name((node, direction) => {
      let elements = getListElements(node) || [];
      for (let i22 = 0; i22 < elements.length; i22++) {
        let currentNode = elements[i22];
        if (currentNode.getAttribute("aria-selected") === "true") {
          direction === "up" && elements[i22 - 1] ? updateFocus(elements[i22 - 1], currentNode) : direction === "down" && elements[i22 + 1] && updateFocus(elements[i22 + 1], currentNode);
          return;
        }
      }
      updateFocus(elements[0]);
    }, "moveFocusAdjacent"), handleKeypress = __name((event, isChild2) => {
      let node = event.target;
      (event.key === "Enter" || event.key === " ") && updateState(!isOpen), event.key === "ArrowRight" && isOpen && !isChild2 ? moveFocusAdjacent(node, "down") : event.key === "ArrowRight" && updateState(!0), event.key === "ArrowLeft" && (!isOpen || isChild2) ? moveBack(node) : event.key === "ArrowLeft" && updateState(!1), event.key === "ArrowDown" && moveFocusAdjacent(node, "down"), event.key === "ArrowUp" && moveFocusAdjacent(node, "up"), event.key === "Home" && moveHome(node, "start"), event.key === "End" && moveHome(node, "end");
    }, "handleKeypress"), handleClick = __name((event, isChild2) => {
      let node = event.target, parent = getParent(node, "treeitem"), elements = getListElements(node) || [], found = !1;
      for (let i22 = 0; i22 < elements.length; i22++) {
        let currentNode = elements[i22];
        if (currentNode.getAttribute("aria-selected") === "true") {
          parent && (found = !0, updateFocus(parent, currentNode));
          break;
        }
      }
      !found && parent && updateFocus(parent), isChild2 || updateState(!isOpen);
    }, "handleClick"), handleBlur = __name((event) => {
      let node = event.currentTarget;
      !node.contains(document.activeElement) && node.getAttribute("role") === "tree" && node.setAttribute("tabindex", "0");
    }, "handleBlur"), handleFocus = __name((event) => {
      let node = event.target;
      if (node.getAttribute("role") === "tree") {
        let selected = node.querySelector('[aria-selected="true"]');
        selected ? updateFocus(selected) : moveFocusAdjacent(node, "down"), node.setAttribute("tabindex", "-1");
      }
    }, "handleFocus"), handleButtonFocus = __name(() => {
      onSelect?.();
    }, "handleButtonFocus"), getPaddingStyles = __name((depth2) => {
      let space = depth2 * 0.9 + 0.3;
      return {
        paddingLeft: `${space}em`,
        width: `calc(100% - ${space}em)`
      };
    }, "getPaddingStyles"), {
      isChild,
      depth,
      hasHover
    } = react_default.useContext(TreeContext_default), showHover = hasHover ? hover : !1;
    if (!isChild)
      return react_default.createElement("ul", _extends({
        role: "tree",
        tabIndex: 0,
        className: clsx_m_default(Tree_css_default.tree, Tree_css_default.group, themeClass, className),
        onFocus: handleFocus,
        onBlur: handleBlur
      }, html), react_default.createElement(TreeContext_default.Provider, {
        value: {
          isChild: !0,
          depth: 0,
          hasHover: showHover
        }
      }, react_default.createElement(Tree, props)));
    if (!hasChildren)
      return react_default.createElement("li", _extends({
        role: "treeitem",
        className: Tree_css_default.item
      }, html), react_default.createElement("div", {
        role: "button",
        className: clsx_m_default(Tree_css_default.label, {
          [Tree_css_default.hover]: showHover,
          [Tree_css_default.focusWhite]: currentTheme === "firefox"
        }),
        tabIndex: -1,
        style: getPaddingStyles(depth),
        onKeyDown: __name((e2) => {
          handleKeypress(e2, isChild);
        }, "onKeyDown"),
        onClick: __name((e2) => handleClick(e2, !0), "onClick"),
        onFocus: handleButtonFocus
      }, react_default.createElement("span", null, label)));
    let arrowClass = clsx_m_default(Tree_css_default.arrow, {
      [Tree_css_default.open]: isOpen
    });
    return react_default.createElement("li", {
      role: "treeitem",
      "aria-expanded": isOpen,
      className: Tree_css_default.item
    }, react_default.createElement("div", {
      role: "button",
      tabIndex: -1,
      className: clsx_m_default(Tree_css_default.label, {
        [Tree_css_default.hover]: showHover,
        [Tree_css_default.focusWhite]: currentTheme === "firefox"
      }),
      style: getPaddingStyles(depth),
      onClick: __name((e2) => handleClick(e2), "onClick"),
      onKeyDown: __name((e2) => handleKeypress(e2), "onKeyDown"),
      onFocus: handleButtonFocus
    }, react_default.createElement("span", null, react_default.createElement("span", {
      "aria-hidden": !0,
      className: arrowClass
    }), react_default.createElement("span", null, label))), react_default.createElement("ul", _extends({
      role: "group",
      className: clsx_m_default(className, Tree_css_default.group)
    }, html), isOpen && react_default.Children.map(children, (child) => react_default.createElement(TreeContext_default.Provider, {
      value: {
        isChild: !0,
        depth: depth + 1,
        hasHover: showHover
      }
    }, child))));
  }, "Tree");
  Tree.defaultProps = {
    open: !1,
    hover: !0
  };
  var ObjectInspector_css_default = { "object-inspector": "ObjectInspector-object-inspector-0c33e82", objectInspector: "ObjectInspector-object-inspector-0c33e82", "object-label": "ObjectInspector-object-label-b81482b", objectLabel: "ObjectInspector-object-label-b81482b", text: "ObjectInspector-text-25f57f3", key: "ObjectInspector-key-4f712bb", value: "ObjectInspector-value-f7ec2e5", string: "ObjectInspector-string-c496000", regex: "ObjectInspector-regex-59d45a3", error: "ObjectInspector-error-b818698", boolean: "ObjectInspector-boolean-2dd1642", number: "ObjectInspector-number-a6daabb", undefined: "ObjectInspector-undefined-3a68263", null: "ObjectInspector-null-74acb50", function: "ObjectInspector-function-07bbdcd", "function-decorator": "ObjectInspector-function-decorator-3d22c24", functionDecorator: "ObjectInspector-function-decorator-3d22c24", prototype: "ObjectInspector-prototype-f2449ee", dark: "ObjectInspector-dark-0c96c97", chrome: "ObjectInspector-chrome-2f3ca98", light: "ObjectInspector-light-78bef54" }, _excluded3 = ["ast", "theme", "showKey", "colorScheme", "className"], buildValue = __name((key, value2, valueClass, showKey, depth) => {
    let computedKey = key.includes("-") ? `"${key}"` : key, isRoot = depth <= 0;
    return react_default.createElement("span", {
      className: ObjectInspector_css_default.text
    }, !isRoot && showKey && react_default.createElement(react_default.Fragment, null, react_default.createElement("span", {
      className: ObjectInspector_css_default.key
    }, computedKey), react_default.createElement("span", null, ":\xA0")), react_default.createElement("span", {
      className: valueClass
    }, value2));
  }, "buildValue"), ObjectValue2 = __name((props) => {
    let {
      ast,
      theme: theme3,
      showKey,
      colorScheme,
      className
    } = props, html = _objectWithoutProperties(props, _excluded3), {
      themeClass
    } = useTheme4({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default), [asyncValue, setAsyncValue] = useState(react_default.createElement("span", null)), value2 = react_default.createElement("span", null);
    return useEffect(() => {
      ast.value instanceof Promise && __name(async (promise) => {
        setAsyncValue(buildValue(ast.key, `Promise { "${await getPromiseState(promise)}" }`, ObjectInspector_css_default.key, showKey, ast.depth));
      }, "waitForPromiseResult")(ast.value);
    }, [ast, showKey]), typeof ast.value == "number" || typeof ast.value == "bigint" ? value2 = buildValue(ast.key, String(ast.value), ObjectInspector_css_default.number, showKey, ast.depth) : typeof ast.value == "boolean" ? value2 = buildValue(ast.key, String(ast.value), ObjectInspector_css_default.boolean, showKey, ast.depth) : typeof ast.value == "string" ? value2 = buildValue(ast.key, `"${ast.value}"`, ObjectInspector_css_default.string, showKey, ast.depth) : typeof ast.value > "u" ? value2 = buildValue(ast.key, "undefined", ObjectInspector_css_default.undefined, showKey, ast.depth) : typeof ast.value == "symbol" ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.string, showKey, ast.depth) : typeof ast.value == "function" ? value2 = buildValue(ast.key, `${ast.value.name}()`, ObjectInspector_css_default.key, showKey, ast.depth) : typeof ast.value == "object" && (ast.value === null ? value2 = buildValue(ast.key, "null", ObjectInspector_css_default.null, showKey, ast.depth) : Array.isArray(ast.value) ? value2 = buildValue(ast.key, `Array(${ast.value.length})`, ObjectInspector_css_default.key, showKey, ast.depth) : ast.value instanceof Date ? value2 = buildValue(ast.key, `Date ${ast.value.toString()}`, ObjectInspector_css_default.value, showKey, ast.depth) : ast.value instanceof RegExp ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.regex, showKey, ast.depth) : ast.value instanceof Error ? value2 = buildValue(ast.key, ast.value.toString(), ObjectInspector_css_default.error, showKey, ast.depth) : isObject4(ast.value) ? value2 = buildValue(ast.key, "{\u2026}", ObjectInspector_css_default.key, showKey, ast.depth) : value2 = buildValue(ast.key, ast.value.constructor.name, ObjectInspector_css_default.key, showKey, ast.depth)), react_default.createElement("span", _extends({
      className: clsx_m_default(themeClass, className)
    }, html), asyncValue, value2);
  }, "ObjectValue");
  ObjectValue2.defaultProps = {
    showKey: !0
  };
  var ObjectValue_default = ObjectValue2, _excluded4 = ["ast", "theme", "previewMax", "open", "colorScheme", "className"], buildPreview = __name((children, previewMax, showKey) => {
    let previews = [];
    for (let i22 = 0; i22 < children.length; i22++) {
      let child = children[i22];
      if (child.isPrototype || (previews.push(react_default.createElement(ObjectValue_default, {
        key: child.key,
        ast: child,
        showKey
      })), i22 < children.length - 1 ? previews.push(", ") : previews.push(" ")), child.isPrototype && i22 === children.length - 1 && (previews.pop(), previews.push(" ")), i22 === previewMax - 1 && children.length > previewMax) {
        previews.push("\u2026 ");
        break;
      }
    }
    return previews;
  }, "buildPreview"), getArrayLabel = __name((ast, open, previewMax, theme3) => {
    let l2 = ast.value.length;
    return open ? react_default.createElement("span", null, "Array(", l2, ")") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `${theme3 === "firefox" ? "Array" : ""}(${l2}) [ `), buildPreview(ast.children, previewMax, !1), react_default.createElement("span", null, "]"));
  }, "getArrayLabel"), getObjectLabel = __name((ast, open, previewMax, theme3) => ast.isPrototype ? react_default.createElement("span", null, `Object ${theme3 === "firefox" ? "{ \u2026 }" : ""}`) : open ? react_default.createElement("span", null, "{\u2026}") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `${theme3 === "firefox" ? "Object " : ""}{ `), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}")), "getObjectLabel"), getPromiseLabel = __name((ast, open, previewMax) => open ? react_default.createElement("span", null, `Promise { "${String(ast.children[0].value)}" }`) : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, "Promise { "), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}")), "getPromiseLabel"), getMapLabel = __name((ast, open, previewMax, theme3) => {
    let {
      size
    } = ast.value;
    return open ? react_default.createElement("span", null, `Map(${size})`) : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `Map${theme3 === "chrome" ? `(${size})` : ""} { `), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}"));
  }, "getMapLabel"), getSetLabel = __name((ast, open, previewMax) => {
    let {
      size
    } = ast.value;
    return open ? react_default.createElement("span", null, "Set(", size, ")") : react_default.createElement(react_default.Fragment, null, react_default.createElement("span", null, `Set(${ast.value.size}) {`), buildPreview(ast.children, previewMax, !0), react_default.createElement("span", null, "}"));
  }, "getSetLabel"), ObjectLabel2 = __name((props) => {
    let {
      ast,
      theme: theme3,
      previewMax,
      open,
      colorScheme,
      className
    } = props, html = _objectWithoutProperties(props, _excluded4), {
      themeClass,
      currentTheme
    } = useTheme4({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default), isPrototype = ast.isPrototype || !1, classes2 = clsx_m_default(ObjectInspector_css_default.objectLabel, themeClass, className, {
      [ObjectInspector_css_default.prototype]: isPrototype
    }), isRoot = ast.depth <= 0, Key = __name(() => react_default.createElement("span", {
      className: isPrototype ? ObjectInspector_css_default.prototype : ObjectInspector_css_default.key
    }, isRoot ? "" : `${ast.key}: `), "Key");
    return ast.type === "array" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getArrayLabel(ast, open, previewMax, currentTheme)) : ast.type === "function" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), currentTheme === "chrome" && react_default.createElement("span", {
      className: ObjectInspector_css_default.functionDecorator
    }, "\u0192 "), react_default.createElement("span", {
      className: clsx_m_default({
        [ObjectInspector_css_default.function]: !isPrototype
      })
    }, `${ast.value.name}()`)) : ast.type === "promise" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getPromiseLabel(ast, open, previewMax)) : ast.type === "map" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getMapLabel(ast, open, previewMax, currentTheme)) : ast.type === "set" ? react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getSetLabel(ast, open, previewMax)) : react_default.createElement("span", _extends({
      className: classes2
    }, html), react_default.createElement(Key, null), getObjectLabel(ast, open, previewMax, currentTheme));
  }, "ObjectLabel");
  ObjectLabel2.defaultProps = {
    previewMax: 8,
    open: !1
  };
  var ObjectLabel_default = ObjectLabel2, ObjectInspectorItem = __name((props) => {
    let {
      ast,
      expandLevel,
      depth
    } = props, [resolved, setResolved] = useState(), [open, setOpen] = useState(depth < expandLevel);
    return useEffect(() => {
      __name(async () => {
        if (ast.type !== "value") {
          let promises = ast.children.map((f22) => f22()), children = await Promise.all(promises), r2 = _objectSpread2(_objectSpread2({}, ast), {}, {
            children
          });
          setResolved(r2);
        }
      }, "resolve")();
    }, [ast]), resolved ? react_default.createElement(Tree, {
      hover: !1,
      open,
      label: react_default.createElement(ObjectLabel_default, {
        open,
        ast: resolved
      }),
      onSelect: __name(() => {
        var _props$onSelect;
        (_props$onSelect = props.onSelect) === null || _props$onSelect === void 0 || _props$onSelect.call(props, ast);
      }, "onSelect"),
      onUpdate: __name((value2) => {
        setOpen(value2);
      }, "onUpdate")
    }, resolved.children.map((child) => react_default.createElement(ObjectInspectorItem, {
      key: child.key,
      ast: child,
      depth: depth + 1,
      expandLevel,
      onSelect: props.onSelect
    }))) : react_default.createElement(Tree, {
      hover: !1,
      label: react_default.createElement(ObjectValue_default, {
        ast
      }),
      onSelect: __name(() => {
        var _props$onSelect2;
        (_props$onSelect2 = props.onSelect) === null || _props$onSelect2 === void 0 || _props$onSelect2.call(props, ast);
      }, "onSelect")
    });
  }, "ObjectInspectorItem");
  ObjectInspectorItem.defaultProps = {
    expandLevel: 0,
    depth: 0
  };
  var ObjectInspectorItem_default = ObjectInspectorItem, _excluded5 = ["data", "expandLevel", "sortKeys", "includePrototypes", "className", "theme", "colorScheme", "onSelect"], ObjectInspector2 = __name((props) => {
    let {
      data,
      expandLevel,
      sortKeys,
      includePrototypes,
      className,
      theme: theme3,
      colorScheme,
      onSelect
    } = props, html = _objectWithoutProperties(props, _excluded5), [ast, setAST] = useState(void 0), {
      themeClass,
      currentTheme,
      currentColorScheme
    } = useTheme4({
      theme: theme3,
      colorScheme
    }, ObjectInspector_css_default);
    return useEffect(() => {
      __name(async () => {
        setAST(await parse4(data, sortKeys, includePrototypes));
      }, "runParser")();
    }, [data, sortKeys, includePrototypes]), react_default.createElement("div", _extends({
      className: clsx_m_default(ObjectInspector_css_default.objectInspector, className, themeClass)
    }, html), ast && react_default.createElement(ThemeProvider2, {
      theme: currentTheme,
      colorScheme: currentColorScheme
    }, react_default.createElement(ObjectInspectorItem_default, {
      ast,
      expandLevel,
      onSelect
    })));
  }, "ObjectInspector");
  ObjectInspector2.defaultProps = {
    expandLevel: 0,
    sortKeys: !0,
    includePrototypes: !0
  };
  var colorsLight = {
    base: "#444",
    nullish: "#7D99AA",
    string: "#16B242",
    number: "#5D40D0",
    boolean: "#f41840",
    objectkey: "#698394",
    instance: "#A15C20",
    function: "#EA7509",
    muted: "#7D99AA",
    tag: {
      name: "#6F2CAC",
      suffix: "#1F99E5"
    },
    date: "#459D9C",
    error: {
      name: "#D43900",
      message: "#444"
    },
    regex: {
      source: "#A15C20",
      flags: "#EA7509"
    },
    meta: "#EA7509",
    method: "#0271B6"
  }, colorsDark = {
    base: "#eee",
    nullish: "#aaa",
    string: "#5FE584",
    number: "#6ba5ff",
    boolean: "#ff4191",
    objectkey: "#accfe6",
    instance: "#E3B551",
    function: "#E3B551",
    muted: "#aaa",
    tag: {
      name: "#f57bff",
      suffix: "#8EB5FF"
    },
    date: "#70D4D3",
    error: {
      name: "#f40",
      message: "#eee"
    },
    regex: {
      source: "#FAD483",
      flags: "#E3B551"
    },
    meta: "#FAD483",
    method: "#5EC1FF"
  }, useThemeColors = __name(() => {
    let { base } = useTheme();
    return base === "dark" ? colorsDark : colorsLight;
  }, "useThemeColors"), special = /[^A-Z0-9]/i, trimEnd = /[\s.,]+$/gm, ellipsize = __name((string, maxlength) => {
    if (string.length <= maxlength)
      return string;
    for (let i22 = maxlength - 1; i22 >= 0; i22 -= 1)
      if (special.test(string[i22]) && i22 > 10)
        return `${string.slice(0, i22).replace(trimEnd, "")}\u2026`;
    return `${string.slice(0, maxlength).replace(trimEnd, "")}\u2026`;
  }, "ellipsize"), stringify3 = __name((value2) => {
    try {
      return JSON.stringify(value2, null, 1);
    } catch {
      return String(value2);
    }
  }, "stringify"), interleave = __name((nodes, separator) => nodes.flatMap(
    (node, index2) => index2 === nodes.length - 1 ? [node] : [node, react_default.cloneElement(separator, { key: `sep${index2}` })]
  ), "interleave"), Node2 = __name(({
    value: value2,
    nested,
    showObjectInspector,
    callsById,
    ...props
  }) => {
    switch (!0) {
      case value2 === null:
        return react_default.createElement(NullNode, { ...props });
      case value2 === void 0:
        return react_default.createElement(UndefinedNode, { ...props });
      case Array.isArray(value2):
        return react_default.createElement(ArrayNode, { ...props, value: value2, callsById });
      case typeof value2 == "string":
        return react_default.createElement(StringNode, { ...props, value: value2 });
      case typeof value2 == "number":
        return react_default.createElement(NumberNode, { ...props, value: value2 });
      case typeof value2 == "boolean":
        return react_default.createElement(BooleanNode, { ...props, value: value2 });
      case Object.prototype.hasOwnProperty.call(value2, "__date__"):
        return react_default.createElement(DateNode, { ...props, ...value2.__date__ });
      case Object.prototype.hasOwnProperty.call(value2, "__error__"):
        return react_default.createElement(ErrorNode, { ...props, ...value2.__error__ });
      case Object.prototype.hasOwnProperty.call(value2, "__regexp__"):
        return react_default.createElement(RegExpNode, { ...props, ...value2.__regexp__ });
      case Object.prototype.hasOwnProperty.call(value2, "__function__"):
        return react_default.createElement(FunctionNode, { ...props, ...value2.__function__ });
      case Object.prototype.hasOwnProperty.call(value2, "__symbol__"):
        return react_default.createElement(SymbolNode, { ...props, ...value2.__symbol__ });
      case Object.prototype.hasOwnProperty.call(value2, "__element__"):
        return react_default.createElement(ElementNode, { ...props, ...value2.__element__ });
      case Object.prototype.hasOwnProperty.call(value2, "__class__"):
        return react_default.createElement(ClassNode, { ...props, ...value2.__class__ });
      case Object.prototype.hasOwnProperty.call(value2, "__callId__"):
        return react_default.createElement(MethodCall, { call: callsById?.get(value2.__callId__), callsById });
      case Object.prototype.toString.call(value2) === "[object Object]":
        return react_default.createElement(
          ObjectNode,
          {
            value: value2,
            showInspector: showObjectInspector,
            callsById,
            ...props
          }
        );
      default:
        return react_default.createElement(OtherNode, { value: value2, ...props });
    }
  }, "Node"), NullNode = __name((props) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.nullish }, ...props }, "null");
  }, "NullNode"), UndefinedNode = __name((props) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.nullish }, ...props }, "undefined");
  }, "UndefinedNode"), StringNode = __name(({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.string }, ...props }, JSON.stringify(ellipsize(value2, 50)));
  }, "StringNode"), NumberNode = __name(({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.number }, ...props }, value2);
  }, "NumberNode"), BooleanNode = __name(({ value: value2, ...props }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.boolean }, ...props }, String(value2));
  }, "BooleanNode"), ArrayNode = __name(({
    value: value2,
    nested = !1,
    callsById
  }) => {
    let colors3 = useThemeColors();
    if (nested)
      return react_default.createElement("span", { style: { color: colors3.base } }, "[\u2026]");
    let nodes = value2.slice(0, 3).map((v22, index2) => react_default.createElement(Node2, { key: `${index2}--${JSON.stringify(v22)}`, value: v22, nested: !0, callsById })), nodelist = interleave(nodes, react_default.createElement("span", null, ", "));
    return value2.length <= 3 ? react_default.createElement("span", { style: { color: colors3.base } }, "[", nodelist, "]") : react_default.createElement("span", { style: { color: colors3.base } }, "(", value2.length, ") [", nodelist, ", \u2026]");
  }, "ArrayNode"), ObjectNode = __name(({
    showInspector,
    value: value2,
    callsById,
    nested = !1
  }) => {
    let isDarkMode = useTheme().base === "dark", colors3 = useThemeColors();
    if (showInspector)
      return react_default.createElement(react_default.Fragment, null, react_default.createElement(
        ObjectInspector2,
        {
          id: "interactions-object-inspector",
          data: value2,
          includePrototypes: !1,
          colorScheme: isDarkMode ? "dark" : "light"
        }
      ));
    if (nested)
      return react_default.createElement("span", { style: { color: colors3.base } }, "{\u2026}");
    let nodelist = interleave(
      Object.entries(value2).slice(0, 2).map(([k22, v22]) => react_default.createElement(Fragment, { key: k22 }, react_default.createElement("span", { style: { color: colors3.objectkey } }, k22, ": "), react_default.createElement(Node2, { value: v22, callsById, nested: !0 }))),
      react_default.createElement("span", null, ", ")
    );
    return Object.keys(value2).length <= 2 ? react_default.createElement("span", { style: { color: colors3.base } }, "{ ", nodelist, " }") : react_default.createElement("span", { style: { color: colors3.base } }, "(", Object.keys(value2).length, ") ", "{ ", nodelist, ", \u2026 }");
  }, "ObjectNode"), ClassNode = __name(({ name }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.instance } }, name);
  }, "ClassNode"), FunctionNode = __name(({ name }) => {
    let colors3 = useThemeColors();
    return name ? react_default.createElement("span", { style: { color: colors3.function } }, name) : react_default.createElement("span", { style: { color: colors3.nullish, fontStyle: "italic" } }, "anonymous");
  }, "FunctionNode"), ElementNode = __name(({
    prefix: prefix2,
    localName,
    id: id2,
    classNames = [],
    innerText
  }) => {
    let name = prefix2 ? `${prefix2}:${localName}` : localName, colors3 = useThemeColors();
    return react_default.createElement("span", { style: { wordBreak: "keep-all" } }, react_default.createElement("span", { key: `${name}_lt`, style: { color: colors3.muted } }, "<"), react_default.createElement("span", { key: `${name}_tag`, style: { color: colors3.tag.name } }, name), react_default.createElement("span", { key: `${name}_suffix`, style: { color: colors3.tag.suffix } }, id2 ? `#${id2}` : classNames.reduce((acc, className) => `${acc}.${className}`, "")), react_default.createElement("span", { key: `${name}_gt`, style: { color: colors3.muted } }, ">"), !id2 && classNames.length === 0 && innerText && react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { key: `${name}_text` }, innerText), react_default.createElement("span", { key: `${name}_close_lt`, style: { color: colors3.muted } }, "<"), react_default.createElement("span", { key: `${name}_close_tag`, style: { color: colors3.tag.name } }, "/", name), react_default.createElement("span", { key: `${name}_close_gt`, style: { color: colors3.muted } }, ">")));
  }, "ElementNode"), DateNode = __name(({ value: value2 }) => {
    let parsed = new Date(value2);
    isNaN(Number(parsed)) && (logger.warn("Invalid date value:", value2), parsed = null);
    let colors3 = useThemeColors();
    if (!parsed)
      return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.date } }, "Invalid date");
    let [date, time, ms] = parsed.toISOString().split(/[T.Z]/);
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.date } }, date, react_default.createElement("span", { style: { opacity: 0.7 } }, "T"), time === "00:00:00" ? react_default.createElement("span", { style: { opacity: 0.7 } }, time) : time, ms === "000" ? react_default.createElement("span", { style: { opacity: 0.7 } }, ".", ms) : `.${ms}`, react_default.createElement("span", { style: { opacity: 0.7 } }, "Z"));
  }, "DateNode"), ErrorNode = __name(({ name, message }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.error.name } }, name, message && ": ", message && react_default.createElement("span", { style: { color: colors3.error.message }, title: message.length > 50 ? message : "" }, ellipsize(message, 50)));
  }, "ErrorNode"), RegExpNode = __name(({ flags, source }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.regex.flags } }, "/", react_default.createElement("span", { style: { color: colors3.regex.source } }, source), "/", flags);
  }, "RegExpNode"), SymbolNode = __name(({ description }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { whiteSpace: "nowrap", color: colors3.instance } }, "Symbol(", description && react_default.createElement("span", { style: { color: colors3.meta } }, '"', description, '"'), ")");
  }, "SymbolNode"), OtherNode = __name(({ value: value2 }) => {
    let colors3 = useThemeColors();
    return react_default.createElement("span", { style: { color: colors3.meta } }, stringify3(value2));
  }, "OtherNode"), StepNode = __name(({ label }) => {
    let colors3 = useThemeColors(), { typography: typography4 } = useTheme();
    return react_default.createElement(
      "span",
      {
        style: {
          color: colors3.base,
          fontFamily: typography4.fonts.base,
          fontSize: typography4.size.s2 - 1
        }
      },
      label
    );
  }, "StepNode"), MethodCall = __name(({
    call,
    callsById
  }) => {
    if (!call)
      return null;
    if (call.method === "step" && call.path?.length === 0)
      return react_default.createElement(StepNode, { label: call.args[0] });
    let path = call.path?.flatMap((elem, index2) => {
      let callId = elem.__callId__;
      return [
        callId ? react_default.createElement(MethodCall, { key: `elem${index2}`, call: callsById?.get(callId), callsById }) : react_default.createElement("span", { key: `elem${index2}` }, elem),
        react_default.createElement("wbr", { key: `wbr${index2}` }),
        react_default.createElement("span", { key: `dot${index2}` }, ".")
      ];
    }), args = call.args?.flatMap((arg, index2, array2) => {
      let node = react_default.createElement(Node2, { key: `node${index2}`, value: arg, callsById });
      return index2 < array2.length - 1 ? [node, react_default.createElement("span", { key: `comma${index2}` }, ",\xA0"), react_default.createElement("wbr", { key: `wbr${index2}` })] : [node];
    }), colors3 = useThemeColors();
    return react_default.createElement(react_default.Fragment, null, react_default.createElement("span", { style: { color: colors3.base } }, path), react_default.createElement("span", { style: { color: colors3.method } }, call.method), react_default.createElement("span", { style: { color: colors3.base } }, "(", react_default.createElement("wbr", null), args, react_default.createElement("wbr", null), ")"));
  }, "MethodCall"), getParams = __name((line, fromIndex = 0) => {
    for (let i22 = fromIndex, depth = 1; i22 < line.length; i22 += 1)
      if (line[i22] === "(" ? depth += 1 : line[i22] === ")" && (depth -= 1), depth === 0)
        return line.slice(fromIndex, i22);
    return "";
  }, "getParams"), parseValue2 = __name((value2) => {
    try {
      return value2 === "undefined" ? void 0 : JSON.parse(value2);
    } catch {
      return value2;
    }
  }, "parseValue"), StyledExpected = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "light" ? theme3.color.positiveText : theme3.color.positive
  })), StyledReceived = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "light" ? theme3.color.negativeText : theme3.color.negative
  })), Received = __name(({ value: value2, parsed }) => parsed ? react_default.createElement(Node2, { showObjectInspector: !0, value: value2, style: { color: "#D43900" } }) : react_default.createElement(StyledReceived, null, value2), "Received"), Expected = __name(({ value: value2, parsed }) => parsed ? typeof value2 == "string" && value2.startsWith("called with") ? react_default.createElement(react_default.Fragment, null, value2) : react_default.createElement(Node2, { showObjectInspector: !0, value: value2, style: { color: "#16B242" } }) : react_default.createElement(StyledExpected, null, value2), "Expected"), MatcherResult = __name(({
    message,
    style = {}
  }) => {
    let filter = useAnsiToHtmlFilter(), lines = message.split(`
`);
    return react_default.createElement(
      "pre",
      {
        style: {
          margin: 0,
          padding: "8px 10px 8px 36px",
          fontSize: typography.size.s1,
          ...style
        }
      },
      lines.flatMap((line, index2) => {
        if (line.startsWith("expect(")) {
          let received = getParams(line, 7), remainderIndex = received ? 7 + received.length : 0, matcher = received && line.slice(remainderIndex).match(/\.(to|last|nth)[A-Z]\w+\(/);
          if (matcher) {
            let expectedIndex = remainderIndex + (matcher.index ?? 0) + matcher[0].length, expected = getParams(line, expectedIndex);
            if (expected)
              return [
                "expect(",
                react_default.createElement(Received, { key: `received_${received}`, value: received }),
                line.slice(remainderIndex, expectedIndex),
                react_default.createElement(Expected, { key: `expected_${expected}`, value: expected }),
                line.slice(expectedIndex + expected.length),
                react_default.createElement("br", { key: `br${index2}` })
              ];
          }
        }
        if (line.match(/^\s*- /))
          return [react_default.createElement(Expected, { key: line + index2, value: line }), react_default.createElement("br", { key: `br${index2}` })];
        if (line.match(/^\s*\+ /) || line.match(/^Received: $/))
          return [react_default.createElement(Received, { key: line + index2, value: line }), react_default.createElement("br", { key: `br${index2}` })];
        let [, assertionLabel, assertionValue] = line.match(/^(Expected|Received): (.*)$/) || [];
        if (assertionLabel && assertionValue)
          return assertionLabel === "Expected" ? [
            "Expected: ",
            react_default.createElement(Expected, { key: line + index2, value: parseValue2(assertionValue), parsed: !0 }),
            react_default.createElement("br", { key: `br${index2}` })
          ] : [
            "Received: ",
            react_default.createElement(Received, { key: line + index2, value: parseValue2(assertionValue), parsed: !0 }),
            react_default.createElement("br", { key: `br${index2}` })
          ];
        let [, prefix2, numberOfCalls] = line.match(/(Expected number|Received number|Number) of calls: (\d+)$/i) || [];
        if (prefix2 && numberOfCalls)
          return [
            `${prefix2} of calls: `,
            react_default.createElement(Node2, { key: line + index2, value: Number(numberOfCalls) }),
            react_default.createElement("br", { key: `br${index2}` })
          ];
        let [, receivedValue] = line.match(/^Received has value: (.+)$/) || [];
        return receivedValue ? [
          "Received has value: ",
          react_default.createElement(Node2, { key: line + index2, value: parseValue2(receivedValue) }),
          react_default.createElement("br", { key: `br${index2}` })
        ] : [
          react_default.createElement(
            "span",
            {
              key: line + index2,
              dangerouslySetInnerHTML: { __html: filter.toHtml(line) }
            }
          ),
          react_default.createElement("br", { key: `br${index2}` })
        ];
      })
    );
  }, "MatcherResult"), WarningContainer = styled.div({
    width: 14,
    height: 14,
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }), StatusIcon2 = __name(({ status }) => {
    let theme3 = useTheme();
    switch (status) {
      case "done":
        return react_default.createElement(CheckIcon, { color: theme3.color.positive, "data-testid": "icon-done" });
      case "error":
        return react_default.createElement(StopAltIcon, { color: theme3.color.negative, "data-testid": "icon-error" });
      case "active":
        return react_default.createElement(PlayIcon, { color: theme3.color.secondary, "data-testid": "icon-active" });
      case "waiting":
        return react_default.createElement(WarningContainer, { "data-testid": "icon-waiting" }, react_default.createElement(CircleIcon, { color: curriedTransparentize$1(0.5, "#CCCCCC"), size: 6 }));
      default:
        return null;
    }
  }, "StatusIcon"), MethodCallWrapper = styled.div({
    fontFamily: typography.fonts.mono,
    fontSize: typography.size.s1,
    overflowWrap: "break-word",
    inlineSize: "calc( 100% - 40px )"
  }), RowContainer = styled("div", {
    shouldForwardProp: __name((prop) => !["call", "pausedAt"].includes(prop.toString()), "shouldForwardProp")
  })(
    ({ theme: theme3, call }) => ({
      position: "relative",
      display: "flex",
      flexDirection: "column",
      borderBottom: `1px solid ${theme3.appBorderColor}`,
      fontFamily: typography.fonts.base,
      fontSize: 13,
      ...call.status === "error" && {
        backgroundColor: theme3.base === "dark" ? curriedTransparentize$1(0.93, theme3.color.negative) : theme3.background.warning
      },
      paddingLeft: (call.ancestors?.length ?? 0) * 20
    }),
    ({ theme: theme3, call, pausedAt }) => pausedAt === call.id && {
      "&::before": {
        content: '""',
        position: "absolute",
        top: -5,
        zIndex: 1,
        borderTop: "4.5px solid transparent",
        borderLeft: `7px solid ${theme3.color.warning}`,
        borderBottom: "4.5px solid transparent"
      },
      "&::after": {
        content: '""',
        position: "absolute",
        top: -1,
        zIndex: 1,
        width: "100%",
        borderTop: `1.5px solid ${theme3.color.warning}`
      }
    }
  ), RowHeader = styled.div(({ theme: theme3, isInteractive }) => ({
    display: "flex",
    "&:hover": isInteractive ? {} : { background: theme3.background.hoverable }
  })), RowLabel = styled("button", {
    shouldForwardProp: __name((prop) => !["call"].includes(prop.toString()), "shouldForwardProp")
  })(({ theme: theme3, disabled, call }) => ({
    flex: 1,
    display: "grid",
    background: "none",
    border: 0,
    gridTemplateColumns: "15px 1fr",
    alignItems: "center",
    minHeight: 40,
    margin: 0,
    padding: "8px 15px",
    textAlign: "start",
    cursor: disabled || call.status === "error" ? "default" : "pointer",
    "&:focus-visible": {
      outline: 0,
      boxShadow: `inset 3px 0 0 0 ${call.status === "error" ? theme3.color.warning : theme3.color.secondary}`,
      background: call.status === "error" ? "transparent" : theme3.background.hoverable
    },
    "& > div": {
      opacity: call.status === "waiting" ? 0.5 : 1
    }
  })), RowActions = styled.div({
    display: "flex",
    alignItems: "center",
    padding: 6
  }), StyledIconButton = styled(IconButton)(({ theme: theme3 }) => ({
    color: theme3.textMutedColor,
    margin: "0 3px"
  })), Note2 = styled(TooltipNote)(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.base
  })), RowMessage = styled("div")(({ theme: theme3 }) => ({
    padding: "8px 10px 8px 36px",
    fontSize: typography.size.s1,
    color: theme3.color.defaultText,
    pre: {
      margin: 0,
      padding: 0
    }
  })), ErrorName = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? "#5EC1FF" : "#0271B6"
  })), ErrorMessage2 = styled.span(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? "#eee" : "#444"
  })), ErrorExplainer = styled.p(({ theme: theme3 }) => ({
    color: theme3.base === "dark" ? theme3.color.negative : theme3.color.negativeText,
    fontSize: theme3.typography.size.s2,
    maxWidth: 500,
    textWrap: "balance"
  })), Exception = __name(({ exception }) => {
    let filter = useAnsiToHtmlFilter();
    if (!exception)
      return null;
    if (exception.callId === INTERNAL_RENDER_CALL_ID)
      return createElement(RowMessage, null, createElement("pre", null, createElement(ErrorName, null, exception.name, ":"), " ", createElement(ErrorMessage2, null, exception.message)), createElement(ErrorExplainer, null, "The component failed to render properly. Automated component tests will not run until this is resolved. Check the full error message in Storybook\u2019s canvas to debug."));
    if (isJestError(exception))
      return createElement(MatcherResult, { ...exception });
    if (isChaiError(exception))
      return createElement(RowMessage, null, createElement(
        MatcherResult,
        {
          message: `${exception.message}${exception.diff ? `

${exception.diff}` : ""}`,
          style: { padding: 0 }
        }
      ), createElement("p", null, "See the full stack trace in the browser console."));
    let paragraphs = exception.message.split(`

`), more = paragraphs.length > 1;
    return createElement(RowMessage, null, createElement("pre", { dangerouslySetInnerHTML: { __html: filter.toHtml(paragraphs[0]) } }), more && createElement("p", null, "See the full stack trace in the browser console."));
  }, "Exception"), Interaction = __name(({
    call,
    callsById,
    controls,
    controlStates,
    childCallIds,
    isHidden,
    isCollapsed,
    toggleCollapsed,
    pausedAt
  }) => {
    let [isHovered, setIsHovered] = useState(!1), isInteractive = !controlStates.goto || !call.interceptable || !!call.ancestors?.length;
    return isHidden || call.id === INTERNAL_RENDER_CALL_ID ? null : createElement(RowContainer, { call, pausedAt }, createElement(RowHeader, { isInteractive }, createElement(
      RowLabel,
      {
        "aria-label": "Interaction step",
        call,
        onClick: () => controls.goto(call.id),
        disabled: isInteractive,
        onMouseEnter: () => controlStates.goto && setIsHovered(!0),
        onMouseLeave: () => controlStates.goto && setIsHovered(!1)
      },
      createElement(StatusIcon2, { status: isHovered ? "active" : call.status }),
      createElement(MethodCallWrapper, { style: { marginLeft: 6, marginBottom: 1 } }, createElement(MethodCall, { call, callsById }))
    ), createElement(RowActions, null, (childCallIds?.length ?? 0) > 0 && createElement(
      WithTooltip,
      {
        hasChrome: !1,
        tooltip: createElement(Note2, { note: `${isCollapsed ? "Show" : "Hide"} interactions` })
      },
      createElement(
        StyledIconButton,
        {
          onClick: toggleCollapsed,
          "aria-label": isCollapsed ? "Expand interaction" : "Collapse interaction"
        },
        isCollapsed ? createElement(ChevronDownIcon, null) : createElement(ChevronUpIcon, null)
      )
    ))), call.status === "error" && call.exception?.callId === call.id && createElement(Exception, { exception: call.exception }));
  }, "Interaction"), StatusColorMapping = {
    rendering: "mediumdark",
    playing: "warning",
    completed: "positive",
    errored: "negative",
    aborted: "purple"
  }, StatusTextMapping = {
    rendering: "Wait",
    playing: "Runs",
    completed: "Pass",
    errored: "Fail",
    aborted: "Bail"
  }, StatusNoteMapping = {
    rendering: "Story is rendering",
    playing: "Interactions are running",
    completed: "Story ran successfully",
    errored: "Story failed to complete",
    aborted: "Interactions aborted due to file changes"
  }, StyledBadge = styled.div(({ theme: theme3, status }) => ({
    display: "inline-block",
    padding: "4px 6px 4px 8px",
    borderRadius: "4px",
    backgroundColor: theme3.color[StatusColorMapping[status]],
    color: "white",
    fontFamily: typography.fonts.base,
    textTransform: "uppercase",
    fontSize: typography.size.s1,
    letterSpacing: 3,
    fontWeight: typography.weight.bold,
    minWidth: 65,
    textAlign: "center"
  })), StatusBadge = __name(({ status }) => {
    let badgeText = StatusTextMapping[status], badgeNote = StatusNoteMapping[status];
    return react_default.createElement(
      WithTooltip,
      {
        hasChrome: !1,
        placement: "top",
        trigger: "hover",
        tooltip: react_default.createElement(TooltipNote, { note: badgeNote })
      },
      react_default.createElement(StyledBadge, { "aria-label": "Story status", status }, badgeText)
    );
  }, "StatusBadge"), SubnavWrapper = styled.div(({ theme: theme3 }) => ({
    boxShadow: `${theme3.appBorderColor} 0 -1px 0 0 inset`,
    background: theme3.background.app,
    position: "sticky",
    top: 0,
    zIndex: 1
  })), StyledSubnav = styled.nav({
    height: 39,
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    paddingLeft: 15
  }), StyledButton = styled(Button)(({ theme: theme3 }) => ({
    borderRadius: 4,
    padding: 6,
    color: theme3.textMutedColor,
    "&:not(:disabled)": {
      "&:hover,&:focus-visible": {
        color: theme3.color.secondary
      }
    }
  })), Note22 = styled(TooltipNote)(({ theme: theme3 }) => ({
    fontFamily: theme3.typography.fonts.base
  })), StyledIconButton2 = styled(IconButton)(({ theme: theme3 }) => ({
    color: theme3.textMutedColor,
    margin: "0 3px"
  })), StyledSeparator = styled(Separator)({
    marginTop: 0
  }), StyledLocation = styled(P)(({ theme: theme3, isText }) => ({
    color: isText ? theme3.textMutedColor : theme3.color.secondary,
    cursor: isText ? "default" : "pointer",
    fontWeight: isText ? theme3.typography.weight.regular : theme3.typography.weight.bold,
    justifyContent: "flex-end",
    textAlign: "right",
    whiteSpace: "nowrap",
    marginTop: "auto",
    marginBottom: 1,
    paddingRight: 15,
    fontSize: 13
  })), Group = styled.div({
    display: "flex",
    alignItems: "center"
  }), RewindButton = styled(StyledIconButton2)({
    marginLeft: 9
  }), JumpToEndButton = styled(StyledButton)({
    marginLeft: 9,
    marginRight: 9,
    lineHeight: "12px"
  }), RerunButton = styled(StyledIconButton2)(({ theme: theme3, animating, disabled }) => ({
    opacity: disabled ? 0.5 : 1,
    svg: {
      animation: animating ? `${theme3.animation.rotate360} 200ms ease-out` : void 0
    }
  })), Subnav = __name(({
    controls,
    controlStates,
    status,
    storyFileName,
    onScrollToEnd,
    importPath,
    canOpenInEditor,
    api
  }) => {
    let buttonText = status === "errored" ? "Scroll to error" : "Scroll to end", theme3 = useTheme();
    return react_default.createElement(SubnavWrapper, null, react_default.createElement(Bar, { backgroundColor: theme3.background.app }, react_default.createElement(StyledSubnav, { "aria-label": "Component tests toolbar" }, react_default.createElement(Group, null, react_default.createElement(StatusBadge, { status }), react_default.createElement(JumpToEndButton, { onClick: onScrollToEnd, disabled: !onScrollToEnd }, buttonText), react_default.createElement(StyledSeparator, null), react_default.createElement(WithTooltip, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Go to start" }) }, react_default.createElement(
      RewindButton,
      {
        "aria-label": "Go to start",
        onClick: controls.start,
        disabled: !controlStates.start
      },
      react_default.createElement(RewindIcon, null)
    )), react_default.createElement(WithTooltip, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Go back" }) }, react_default.createElement(
      StyledIconButton2,
      {
        "aria-label": "Go back",
        onClick: controls.back,
        disabled: !controlStates.back
      },
      react_default.createElement(PlayBackIcon, null)
    )), react_default.createElement(WithTooltip, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Go forward" }) }, react_default.createElement(
      StyledIconButton2,
      {
        "aria-label": "Go forward",
        onClick: controls.next,
        disabled: !controlStates.next
      },
      react_default.createElement(PlayNextIcon, null)
    )), react_default.createElement(WithTooltip, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Go to end" }) }, react_default.createElement(
      StyledIconButton2,
      {
        "aria-label": "Go to end",
        onClick: controls.end,
        disabled: !controlStates.end
      },
      react_default.createElement(FastForwardIcon, null)
    )), react_default.createElement(WithTooltip, { trigger: "hover", hasChrome: !1, tooltip: react_default.createElement(Note22, { note: "Rerun" }) }, react_default.createElement(RerunButton, { "aria-label": "Rerun", onClick: controls.rerun }, react_default.createElement(SyncIcon, null)))), (importPath || storyFileName) && react_default.createElement(Group, null, canOpenInEditor ? react_default.createElement(
      WithTooltip,
      {
        trigger: "hover",
        hasChrome: !1,
        tooltip: react_default.createElement(Note22, { note: "Open in editor" })
      },
      react_default.createElement(
        StyledLocation,
        {
          "aria-label": "Open in editor",
          onClick: () => {
            api.openInEditor({
              file: importPath
            });
          }
        },
        storyFileName
      )
    ) : react_default.createElement(StyledLocation, { isText: !0 }, storyFileName)))));
  }, "Subnav"), Wrapper12 = styled.div(({ theme: { color: color2, typography: typography4, background: background2 } }) => ({
    textAlign: "start",
    padding: "11px 15px",
    fontSize: `${typography4.size.s2 - 1}px`,
    fontWeight: typography4.weight.regular,
    lineHeight: "1rem",
    background: background2.app,
    borderBottom: `1px solid ${color2.border}`,
    color: color2.defaultText,
    backgroundClip: "padding-box",
    position: "relative",
    code: {
      fontSize: `${typography4.size.s1 - 1}px`,
      color: "inherit",
      margin: "0 0.2em",
      padding: "0 0.2em",
      background: "rgba(255, 255, 255, 0.8)",
      borderRadius: "2px",
      boxShadow: "0 0 0 1px rgba(0, 0, 0, 0.1)"
    }
  })), TestDiscrepancyMessage = __name(({ browserTestStatus }) => {
    let docsUrl = useStorybookApi().getDocsUrl({
      subpath: DOCUMENTATION_DISCREPANCY_LINK,
      versioned: !0,
      renderer: !0
    }), [passed, failed] = browserTestStatus === "error" ? ["the CLI", "this browser"] : ["this browser", "the CLI"];
    return react_default.createElement(Wrapper12, null, "This interaction test passed in ", passed, ", but the tests failed in ", failed, ".", " ", react_default.createElement(Link, { href: docsUrl, target: "_blank", withArrow: !0 }, "Learn what could cause this"));
  }, "TestDiscrepancyMessage"), Container3 = styled.div(({ theme: theme3 }) => ({
    height: "100%",
    background: theme3.background.content
  })), CaughtException = styled.div(({ theme: theme3 }) => ({
    borderBottom: `1px solid ${theme3.appBorderColor}`,
    backgroundColor: theme3.base === "dark" ? curriedTransparentize$1(0.93, theme3.color.negative) : theme3.background.warning,
    padding: 15,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "19px"
  })), CaughtExceptionCode = styled.code(({ theme: theme3 }) => ({
    margin: "0 1px",
    padding: 3,
    fontSize: theme3.typography.size.s1 - 1,
    lineHeight: 1,
    verticalAlign: "top",
    background: "rgba(0, 0, 0, 0.05)",
    border: `1px solid ${theme3.appBorderColor}`,
    borderRadius: 3
  })), CaughtExceptionTitle = styled.div({
    paddingBottom: 4,
    fontWeight: "bold"
  }), CaughtExceptionDescription = styled.p({
    margin: 0,
    padding: "0 0 20px"
  }), CaughtExceptionStack = styled.pre(({ theme: theme3 }) => ({
    margin: 0,
    padding: 0,
    "&:not(:last-child)": {
      paddingBottom: 16
    },
    fontSize: theme3.typography.size.s1 - 1
  })), InteractionsPanel = memo(
    __name(function({
      storyUrl,
      status,
      calls,
      controls,
      controlStates,
      interactions,
      fileName,
      hasException,
      caughtException,
      unhandledErrors,
      pausedAt,
      onScrollToEnd,
      endRef,
      hasResultMismatch,
      browserTestStatus,
      importPath,
      canOpenInEditor,
      api
    }) {
      let filter = useAnsiToHtmlFilter(), hasRealInteractions = interactions.some((i22) => i22.id !== INTERNAL_RENDER_CALL_ID);
      return createElement(Container3, null, hasResultMismatch && createElement(TestDiscrepancyMessage, { browserTestStatus }), controlStates.detached && (hasRealInteractions || hasException) && createElement(DetachedDebuggerMessage, { storyUrl }), createElement(
        Subnav,
        {
          controls,
          controlStates,
          status,
          storyFileName: fileName,
          onScrollToEnd,
          importPath,
          canOpenInEditor,
          api
        }
      ), createElement("div", { "aria-label": "Interactions list" }, interactions.map((call) => createElement(
        Interaction,
        {
          key: call.id,
          call,
          callsById: calls,
          controls,
          controlStates,
          childCallIds: call.childCallIds,
          isHidden: call.isHidden,
          isCollapsed: call.isCollapsed,
          toggleCollapsed: call.toggleCollapsed,
          pausedAt
        }
      ))), caughtException && !isTestAssertionError(caughtException) && createElement(CaughtException, null, createElement(CaughtExceptionTitle, null, "Caught exception in ", createElement(CaughtExceptionCode, null, "play"), " function"), createElement(
        CaughtExceptionStack,
        {
          "data-chromatic": "ignore",
          dangerouslySetInnerHTML: {
            __html: filter.toHtml(printSerializedError(caughtException))
          }
        }
      )), unhandledErrors && createElement(CaughtException, null, createElement(CaughtExceptionTitle, null, "Unhandled Errors"), createElement(CaughtExceptionDescription, null, "Found ", unhandledErrors.length, " unhandled error", unhandledErrors.length > 1 ? "s" : "", " ", "while running the play function. This might cause false positive assertions. Resolve unhandled errors or ignore unhandled errors with setting the", createElement(CaughtExceptionCode, null, "test.dangerouslyIgnoreUnhandledErrors"), " ", "parameter to ", createElement(CaughtExceptionCode, null, "true"), "."), unhandledErrors.map((error, i22) => createElement(CaughtExceptionStack, { key: i22, "data-chromatic": "ignore" }, printSerializedError(error)))), createElement("div", { ref: endRef }), status === "completed" && !caughtException && !hasRealInteractions && createElement(Empty2, null));
    }, "InteractionsPanel")
  );
  function printSerializedError(error) {
    return error.stack || `${error.name}: ${error.message}`;
  }
  __name(printSerializedError, "printSerializedError");
  var INITIAL_CONTROL_STATES = {
    detached: !1,
    start: !1,
    back: !1,
    goto: !1,
    next: !1,
    end: !1
  }, playStatusMap = {
    rendering: "rendering",
    playing: "playing",
    completed: "completed",
    errored: "errored",
    aborted: "aborted"
  }, terminalStatuses = ["completed", "errored", "aborted"], storyStatusMap = {
    done: "status-value:success",
    error: "status-value:error",
    active: "status-value:pending",
    waiting: "status-value:pending"
  }, getInteractions = __name(({
    log,
    calls,
    collapsed,
    setCollapsed
  }) => {
    let callsById = /* @__PURE__ */ new Map(), childCallMap = /* @__PURE__ */ new Map();
    return log.map(({ callId, ancestors, status }) => {
      let isHidden = !1;
      return ancestors.forEach((ancestor) => {
        collapsed.has(ancestor) && (isHidden = !0), childCallMap.set(ancestor, (childCallMap.get(ancestor) || []).concat(callId));
      }), { ...calls.get(callId), status, isHidden };
    }).map((call) => {
      let status = call.status === "error" && call.ancestors && callsById.get(call.ancestors.slice(-1)[0])?.status === "active" ? "active" : call.status;
      return callsById.set(call.id, { ...call, status }), {
        ...call,
        status,
        childCallIds: childCallMap.get(call.id),
        isCollapsed: collapsed.has(call.id),
        toggleCollapsed: __name(() => setCollapsed((ids) => (ids.has(call.id) ? ids.delete(call.id) : ids.add(call.id), new Set(ids))), "toggleCollapsed")
      };
    });
  }, "getInteractions"), getPanelState = __name((state3, {
    log,
    calls,
    collapsed,
    setCollapsed
  }) => getInteractions({ log, calls, collapsed, setCollapsed }).reduce(
    (acc, interaction) => (interaction.id === INTERNAL_RENDER_CALL_ID ? acc.interactions.push(interaction) : state3.status !== "rendering" && (acc.controlStates = state3.controlStates, acc.interactions.push(interaction), interaction.method !== "step" && acc.interactionsCount++), acc),
    {
      ...state3,
      controlStates: INITIAL_CONTROL_STATES,
      interactions: [],
      interactionsCount: 0
    }
  ), "getPanelState"), getInternalRenderCall = __name((storyId, exception) => ({
    id: INTERNAL_RENDER_CALL_ID,
    method: "render",
    args: [],
    cursor: 0,
    storyId,
    ancestors: [],
    path: [],
    interceptable: !0,
    retain: !1,
    exception
  }), "getInternalRenderCall"), getInternalRenderLogItem = __name((status) => ({
    callId: INTERNAL_RENDER_CALL_ID,
    status,
    ancestors: []
  }), "getInternalRenderLogItem"), Panel = memo(
    __name(function({ refId, storyId, storyUrl }) {
      let { statusValue, testRunId } = experimental_useStatusStore((state22) => {
        let storyStatus = refId ? void 0 : state22[storyId]?.[STATUS_TYPE_ID_COMPONENT_TEST];
        return {
          statusValue: storyStatus?.value,
          testRunId: storyStatus?.data?.testRunId
        };
      }), state3 = useStorybookState(), api = useStorybookApi(), importPath = api.getData(state3.storyId, state3.refId)?.importPath, canOpenInEditor = scope.CONFIG_TYPE === "DEVELOPMENT" && !state3.refId, [panelState, set] = useAddonState(ADDON_ID72, {
        status: "rendering",
        controlStates: INITIAL_CONTROL_STATES,
        interactions: [],
        interactionsCount: 0,
        hasException: !1,
        pausedAt: void 0,
        caughtException: void 0,
        unhandledErrors: void 0
      }), [scrollTarget, setScrollTarget] = useState(void 0), [collapsed, setCollapsed] = useState(/* @__PURE__ */ new Set()), [hasResultMismatch, setResultMismatch] = useState(!1), {
        status = "rendering",
        controlStates = INITIAL_CONTROL_STATES,
        interactions = [],
        pausedAt = void 0,
        caughtException = void 0,
        unhandledErrors = void 0
      } = panelState, log = useRef([getInternalRenderLogItem(
        "active"
        /* ACTIVE */
      )]), calls = useRef(
        /* @__PURE__ */ new Map([[INTERNAL_RENDER_CALL_ID, getInternalRenderCall(storyId)]])
      ), setCall = __name(({ status: status2, ...call }) => calls.current.set(call.id, call), "setCall"), endRef = useRef();
      useEffect(() => {
        let observer;
        return scope.IntersectionObserver && (observer = new scope.IntersectionObserver(
          ([end]) => setScrollTarget(end.isIntersecting ? void 0 : end.target),
          { root: scope.document.querySelector("#panel-tab-content") }
        ), endRef.current && observer.observe(endRef.current)), () => observer?.disconnect();
      }, []);
      let lastStoryId = useRef(void 0), lastRenderId = useRef(0), emit = useChannel(
        {
          [EVENTS3.CALL]: setCall,
          [EVENTS3.SYNC]: (payload) => {
            log.current = [getInternalRenderLogItem(
              "done"
              /* DONE */
            ), ...payload.logItems], set(
              (state22) => getPanelState(
                { ...state22, controlStates: payload.controlStates, pausedAt: payload.pausedAt },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              )
            );
          },
          [STORY_RENDER_PHASE_CHANGED]: (event) => {
            lastStoryId.current === event.storyId && ["preparing", "loading"].includes(event.newPhase) || (lastStoryId.current = event.storyId, lastRenderId.current = Math.max(lastRenderId.current, event.renderId || 0), lastRenderId.current === event.renderId && (event.newPhase === "rendering" ? (log.current = [getInternalRenderLogItem(
              "active"
              /* ACTIVE */
            )], calls.current.set(INTERNAL_RENDER_CALL_ID, getInternalRenderCall(storyId)), set({
              status: "rendering",
              controlStates: INITIAL_CONTROL_STATES,
              pausedAt: void 0,
              interactions: [],
              interactionsCount: 0,
              hasException: !1,
              caughtException: void 0,
              unhandledErrors: void 0
            })) : set((state22) => {
              let status2 = event.newPhase in playStatusMap && !terminalStatuses.includes(state22.status) ? playStatusMap[event.newPhase] : state22.status;
              return getPanelState(
                { ...state22, status: status2, pausedAt: void 0 },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              );
            })));
          },
          [STORY_THREW_EXCEPTION]: (e2) => {
            log.current = [getInternalRenderLogItem(
              "error"
              /* ERROR */
            )], calls.current.set(
              INTERNAL_RENDER_CALL_ID,
              getInternalRenderCall(storyId, { ...e2, callId: INTERNAL_RENDER_CALL_ID })
            ), set(
              (state22) => getPanelState(
                {
                  ...state22,
                  hasException: !0,
                  caughtException: void 0,
                  controlStates: INITIAL_CONTROL_STATES,
                  pausedAt: void 0
                },
                { log: log.current, calls: calls.current, collapsed, setCollapsed }
              )
            );
          },
          [PLAY_FUNCTION_THREW_EXCEPTION]: (caughtException2) => {
            set((state22) => ({ ...state22, caughtException: caughtException2, hasException: !0 }));
          },
          [UNHANDLED_ERRORS_WHILE_PLAYING]: (unhandledErrors2) => {
            set((state22) => ({ ...state22, unhandledErrors: unhandledErrors2, hasException: !0 }));
          }
        },
        [collapsed]
      );
      useEffect(() => {
        set(
          (state22) => getPanelState(state22, { log: log.current, calls: calls.current, collapsed, setCollapsed })
        );
      }, [set, collapsed]);
      let controls = useMemo(
        () => ({
          start: __name(() => emit(EVENTS3.START, { storyId }), "start"),
          back: __name(() => emit(EVENTS3.BACK, { storyId }), "back"),
          goto: __name((callId) => emit(EVENTS3.GOTO, { storyId, callId }), "goto"),
          next: __name(() => emit(EVENTS3.NEXT, { storyId }), "next"),
          end: __name(() => emit(EVENTS3.END, { storyId }), "end"),
          rerun: __name(() => {
            emit(FORCE_REMOUNT, { storyId });
          }, "rerun")
        }),
        [emit, storyId]
      ), storyFilePath = useParameter("fileName", ""), [fileName] = storyFilePath.toString().split("/").slice(-1), scrollToTarget = __name(() => scrollTarget?.scrollIntoView({ behavior: "smooth", block: "end" }), "scrollToTarget"), hasException = !!caughtException || !!unhandledErrors || interactions.some(
        (v22) => v22.status === "error"
        /* ERROR */
      ), browserTestStatus = useMemo(() => status !== "playing" && (interactions.length > 0 || hasException) ? hasException ? "error" : "done" : status === "playing" ? "active" : void 0, [status, interactions, hasException]);
      return useEffect(() => {
        if (browserTestStatus && statusValue && statusValue !== "status-value:pending" && statusValue !== storyStatusMap[browserTestStatus]) {
          let timeout = setTimeout(
            () => setResultMismatch((currentValue) => (currentValue || emit(STORYBOOK_ADDON_TEST_CHANNEL, {
              type: "test-discrepancy",
              payload: {
                browserStatus: browserTestStatus === "done" ? "PASS" : "FAIL",
                cliStatus: browserTestStatus === "done" ? "FAIL" : "PASS",
                storyId,
                testRunId
              }
            }), !0)),
            2e3
          );
          return () => clearTimeout(timeout);
        } else
          setResultMismatch(!1);
      }, [emit, browserTestStatus, statusValue, storyId, testRunId]), react_default.createElement(Fragment, { key: "component-tests" }, react_default.createElement(
        InteractionsPanel,
        {
          storyUrl,
          status,
          hasResultMismatch,
          browserTestStatus,
          calls: calls.current,
          controls,
          controlStates: { ...controlStates, detached: !!refId || controlStates.detached },
          interactions,
          fileName,
          hasException,
          caughtException,
          unhandledErrors,
          pausedAt,
          endRef,
          onScrollToEnd: scrollTarget && scrollToTarget,
          importPath,
          canOpenInEditor,
          api
        }
      ));
    }, "PanelMemoized")
  );
  function PanelTitle() {
    let selectedPanel = useStorybookApi().getSelectedPanel(), [addonState = {}] = useAddonState(ADDON_ID72), { status, hasException, interactionsCount } = addonState;
    return react_default.createElement("div", { style: { display: "flex", alignItems: "center", gap: 6 } }, react_default.createElement("span", null, "Interactions"), interactionsCount && status !== "errored" && !hasException ? react_default.createElement(Badge, { compact: !0, status: selectedPanel === PANEL_ID22 ? "active" : "neutral" }, interactionsCount) : null, status === "errored" || hasException ? react_default.createElement(StatusIcon2, {
      status: "error"
      /* ERROR */
    }) : null);
  }
  __name(PanelTitle, "PanelTitle");
  var manager_default3 = addons.register(ADDON_ID72, () => {
    if (globalThis?.FEATURES?.interactions) {
      let filter = __name(({ state: state3 }) => {
        let origin = state3.refId && state3.refs[state3.refId]?.url || document.location.origin, { pathname, search = "" } = state3.location, path = pathname + (state3.refId ? search.replace(`/${state3.refId}_`, "/") : search);
        return {
          refId: state3.refId,
          storyId: state3.storyId,
          storyUrl: origin + path
        };
      }, "filter");
      addons.add(PANEL_ID22, {
        type: types.PANEL,
        title: __name(() => react_default.createElement(PanelTitle, null), "title"),
        match: __name(({ viewMode }) => viewMode === "story", "match"),
        render: __name(({ active }) => react_default.createElement(AddonPanel, { active: !!active }, react_default.createElement(Consumer, { filter }, (props) => react_default.createElement(Panel, { ...props }))), "render")
      });
    }
  }), BackgroundTool = memo(__name(function() {
    let config2 = useParameter(PARAM_KEY), [globals, updateGlobals, storyGlobals] = useGlobals(), [isTooltipVisible, setIsTooltipVisible] = useState(!1), { options = DEFAULT_BACKGROUNDS, disable = !0 } = config2 || {};
    if (disable)
      return null;
    let data = globals[PARAM_KEY] || {}, backgroundName = data.value, isGridActive = data.grid || !1, item = options[backgroundName], isLocked = !!storyGlobals?.[PARAM_KEY], length2 = Object.keys(options).length;
    return react_default.createElement(
      Pure,
      {
        length: length2,
        backgroundMap: options,
        item,
        updateGlobals,
        backgroundName,
        setIsTooltipVisible,
        isLocked,
        isGridActive,
        isTooltipVisible
      }
    );
  }, "BackgroundSelector")), Pure = memo(__name(function(props) {
    let {
      item,
      length: length2,
      updateGlobals,
      setIsTooltipVisible,
      backgroundMap,
      backgroundName,
      isLocked,
      isGridActive: isGrid,
      isTooltipVisible
    } = props, update = useCallback(
      (input) => {
        updateGlobals({
          [PARAM_KEY]: input
        });
      },
      [updateGlobals]
    );
    return react_default.createElement(Fragment, null, react_default.createElement(
      IconButton,
      {
        key: "grid",
        active: isGrid,
        disabled: isLocked,
        title: "Apply a grid to the preview",
        onClick: () => update({ value: backgroundName, grid: !isGrid })
      },
      react_default.createElement(GridIcon, null)
    ), length2 > 0 ? react_default.createElement(
      WithTooltip,
      {
        key: "background",
        placement: "top",
        closeOnOutsideClick: !0,
        tooltip: ({ onHide }) => react_default.createElement(
          TooltipLinkList,
          {
            links: [
              ...item ? [
                {
                  id: "reset",
                  title: "Reset background",
                  icon: react_default.createElement(RefreshIcon, null),
                  onClick: __name(() => {
                    update(void 0), onHide();
                  }, "onClick")
                }
              ] : [],
              ...Object.entries(backgroundMap).map(([k22, value2]) => ({
                id: k22,
                title: value2.name,
                icon: react_default.createElement(CircleIcon, { color: value2?.value || "grey" }),
                active: k22 === backgroundName,
                onClick: __name(() => {
                  update({ value: k22, grid: isGrid }), onHide();
                }, "onClick")
              }))
            ].flat()
          }
        ),
        onVisibleChange: setIsTooltipVisible
      },
      react_default.createElement(
        IconButton,
        {
          disabled: isLocked,
          key: "background",
          title: "Change the background of the preview",
          active: !!item || isTooltipVisible
        },
        react_default.createElement(PhotoIcon, null)
      )
    ) : null);
  }, "PureTool")), manager_default4 = addons.register(ADDON_ID, () => {
    globalThis?.FEATURES?.backgrounds && addons.add(ADDON_ID, {
      title: "Backgrounds",
      type: types.TOOL,
      match: __name(({ viewMode, tabId }) => !!(viewMode && viewMode.match(/^(story|docs)$/)) && !tabId, "match"),
      render: __name(() => react_default.createElement(BackgroundTool, null), "render")
    });
  }), Tool = __name(() => {
    let [globals, updateGlobals] = useGlobals(), { measureEnabled } = globals || {}, api = useStorybookApi(), toggleMeasure = useCallback(
      () => updateGlobals({
        measureEnabled: !measureEnabled
      }),
      [updateGlobals, measureEnabled]
    );
    return useEffect(() => {
      api.setAddonShortcut(ADDON_ID2, {
        label: "Toggle Measure",
        defaultShortcut: ["M"],
        actionName: "measure",
        showInMenu: !1,
        action: toggleMeasure
      });
    }, [toggleMeasure, api]), react_default.createElement(
      IconButton,
      {
        key: TOOL_ID,
        active: measureEnabled,
        title: "Enable measure",
        onClick: toggleMeasure
      },
      react_default.createElement(RulerIcon, null)
    );
  }, "Tool"), manager_default5 = addons.register(ADDON_ID2, () => {
    globalThis?.FEATURES?.measure && addons.add(TOOL_ID, {
      type: types.TOOL,
      title: "Measure",
      match: __name(({ viewMode, tabId }) => viewMode === "story" && !tabId, "match"),
      render: __name(() => react_default.createElement(Tool, null), "render")
    });
  }), OutlineSelector = memo(__name(function() {
    let [globals, updateGlobals] = useGlobals(), api = useStorybookApi(), isActive = [!0, "true"].includes(globals[PARAM_KEY3]), toggleOutline = useCallback(
      () => updateGlobals({
        [PARAM_KEY3]: !isActive
      }),
      [isActive]
    );
    return useEffect(() => {
      api.setAddonShortcut(ADDON_ID3, {
        label: "Toggle Outline",
        defaultShortcut: ["alt", "O"],
        actionName: "outline",
        showInMenu: !1,
        action: toggleOutline
      });
    }, [toggleOutline, api]), react_default.createElement(
      IconButton,
      {
        key: "outline",
        active: isActive,
        title: "Apply outlines to the preview",
        onClick: toggleOutline
      },
      react_default.createElement(OutlineIcon, null)
    );
  }, "OutlineSelector")), manager_default6 = addons.register(ADDON_ID3, () => {
    globalThis?.FEATURES?.outline && addons.add(ADDON_ID3, {
      title: "Outline",
      type: types.TOOL,
      match: __name(({ viewMode, tabId }) => !!(viewMode && viewMode.match(/^(story|docs)$/)) && !tabId, "match"),
      render: __name(() => react_default.createElement(OutlineSelector, null), "render")
    });
  }), getCurrentViewportIndex = __name((viewportsKeys, current) => viewportsKeys.indexOf(current), "getCurrentViewportIndex"), getNextViewport = __name((viewportsKeys, current) => {
    let currentViewportIndex = getCurrentViewportIndex(viewportsKeys, current);
    return currentViewportIndex === viewportsKeys.length - 1 ? viewportsKeys[0] : viewportsKeys[currentViewportIndex + 1];
  }, "getNextViewport"), getPreviousViewport = __name((viewportsKeys, current) => {
    let currentViewportIndex = getCurrentViewportIndex(viewportsKeys, current);
    return currentViewportIndex < 1 ? viewportsKeys[viewportsKeys.length - 1] : viewportsKeys[currentViewportIndex - 1];
  }, "getPreviousViewport"), registerShortcuts = __name(async (api, viewport, updateGlobals, viewportsKeys) => {
    await api.setAddonShortcut(ADDON_ID5, {
      label: "Previous viewport",
      defaultShortcut: ["alt", "shift", "V"],
      actionName: "previous",
      action: __name(() => {
        updateGlobals({
          viewport: getPreviousViewport(viewportsKeys, viewport)
        });
      }, "action")
    }), await api.setAddonShortcut(ADDON_ID5, {
      label: "Next viewport",
      defaultShortcut: ["alt", "V"],
      actionName: "next",
      action: __name(() => {
        updateGlobals({
          viewport: getNextViewport(viewportsKeys, viewport)
        });
      }, "action")
    }), await api.setAddonShortcut(ADDON_ID5, {
      label: "Reset viewport",
      defaultShortcut: ["alt", "control", "V"],
      actionName: "reset",
      action: __name(() => {
        updateGlobals({
          viewport: { value: void 0, isRotated: !1 }
        });
      }, "action")
    });
  }, "registerShortcuts"), ActiveViewportSize = styled.div({
    display: "inline-flex",
    alignItems: "center"
  }), ActiveViewportLabel = styled.div(({ theme: theme3 }) => ({
    display: "inline-block",
    textDecoration: "none",
    padding: 10,
    fontWeight: theme3.typography.weight.bold,
    fontSize: theme3.typography.size.s2 - 1,
    lineHeight: "1",
    height: 40,
    border: "none",
    borderTop: "3px solid transparent",
    borderBottom: "3px solid transparent",
    background: "transparent"
  })), IconButtonWithLabel = styled(IconButton)(() => ({
    display: "inline-flex",
    alignItems: "center"
  })), IconButtonLabel = styled.div(({ theme: theme3 }) => ({
    fontSize: theme3.typography.size.s2 - 1,
    marginLeft: 10
  })), iconsMap = {
    desktop: react_default.createElement(BrowserIcon, null),
    mobile: react_default.createElement(MobileIcon, null),
    tablet: react_default.createElement(TabletIcon, null),
    other: react_default.createElement(Fragment, null)
  }, ViewportTool = __name(({ api }) => {
    let config2 = useParameter(PARAM_KEY5), [globals, updateGlobals, storyGlobals] = useGlobals(), [isTooltipVisible, setIsTooltipVisible] = useState(!1), { options = MINIMAL_VIEWPORTS, disable } = config2 || {}, data = globals?.[PARAM_KEY5] || {}, viewportName = typeof data == "string" ? data : data.value, isRotated = typeof data == "string" ? !1 : !!data.isRotated, item = options[viewportName] || responsiveViewport, isActive = isTooltipVisible || item !== responsiveViewport, isLocked = PARAM_KEY5 in storyGlobals, length2 = Object.keys(options).length;
    if (useEffect(() => {
      registerShortcuts(api, viewportName, updateGlobals, Object.keys(options));
    }, [options, viewportName, updateGlobals, api]), item.styles === null || !options || length2 < 1)
      return null;
    if (typeof item.styles == "function")
      return console.warn(
        "Addon Viewport no longer supports dynamic styles using a function, use css calc() instead"
      ), null;
    let width = isRotated ? item.styles.height : item.styles.width, height = isRotated ? item.styles.width : item.styles.height;
    return disable ? null : react_default.createElement(
      Pure2,
      {
        item,
        updateGlobals,
        viewportMap: options,
        viewportName,
        isRotated,
        setIsTooltipVisible,
        isLocked,
        isActive,
        width,
        height
      }
    );
  }, "ViewportTool"), Pure2 = react_default.memo(__name(function(props) {
    let {
      item,
      viewportMap,
      viewportName,
      isRotated,
      updateGlobals,
      setIsTooltipVisible,
      isLocked,
      isActive,
      width,
      height
    } = props, update = useCallback(
      (input) => updateGlobals({ [PARAM_KEY5]: input }),
      [updateGlobals]
    );
    return react_default.createElement(Fragment, null, react_default.createElement(
      WithTooltip,
      {
        placement: "bottom",
        tooltip: ({ onHide }) => react_default.createElement(
          TooltipLinkList,
          {
            links: [
              ...length > 0 && item !== responsiveViewport ? [
                {
                  id: "reset",
                  title: "Reset viewport",
                  icon: react_default.createElement(RefreshIcon, null),
                  onClick: __name(() => {
                    update(void 0), onHide();
                  }, "onClick")
                }
              ] : [],
              ...Object.entries(viewportMap).map(([k22, value2]) => ({
                id: k22,
                title: value2.name,
                icon: iconsMap[value2.type],
                active: k22 === viewportName,
                onClick: __name(() => {
                  update({ value: k22, isRotated: !1 }), onHide();
                }, "onClick")
              }))
            ].flat()
          }
        ),
        closeOnOutsideClick: !0,
        onVisibleChange: setIsTooltipVisible
      },
      react_default.createElement(
        IconButtonWithLabel,
        {
          disabled: isLocked,
          key: "viewport",
          title: "Change the size of the preview",
          active: isActive,
          onDoubleClick: () => {
            update({ value: void 0, isRotated: !1 });
          }
        },
        react_default.createElement(GrowIcon, null),
        item !== responsiveViewport ? react_default.createElement(IconButtonLabel, null, item.name, " ", isRotated ? "(L)" : "(P)") : null
      )
    ), react_default.createElement(
      Global,
      {
        styles: {
          'iframe[data-is-storybook="true"]': { width, height }
        }
      }
    ), item !== responsiveViewport ? react_default.createElement(ActiveViewportSize, null, react_default.createElement(ActiveViewportLabel, { title: "Viewport width" }, width.replace("px", "")), isLocked ? "/" : react_default.createElement(
      IconButton,
      {
        key: "viewport-rotate",
        title: "Rotate viewport",
        onClick: () => {
          update({ value: viewportName, isRotated: !isRotated });
        }
      },
      react_default.createElement(TransferIcon, null)
    ), react_default.createElement(ActiveViewportLabel, { title: "Viewport height" }, height.replace("px", ""))) : null);
  }, "PureTool")), manager_default7 = addons.register(ADDON_ID5, (api) => {
    globalThis?.FEATURES?.viewport && addons.add(TOOL_ID2, {
      title: "viewport / media-queries",
      type: types.TOOL,
      match: __name(({ viewMode, tabId }) => viewMode === "story" && !tabId, "match"),
      render: __name(() => createElement(ViewportTool, { api }), "render")
    });
  }), TAG_FILTERS = "tag-filters", STATIC_FILTER = "static-filter", tagFiltersManager = addons.register(TAG_FILTERS, (api) => {
    let staticExcludeTags = Object.entries(scope.TAGS_OPTIONS ?? {}).reduce(
      (acc, entry) => {
        let [tag, option] = entry;
        return option.excludeFromSidebar && (acc[tag] = !0), acc;
      },
      {}
    );
    api.experimental_setFilter(STATIC_FILTER, (item) => {
      let tags = item.tags ?? [];
      return (
        // we can filter out the primary story, but we still want to show autodocs
        (tags.includes("dev") || item.type === "docs") && tags.filter((tag) => staticExcludeTags[tag]).length === 0
      );
    });
  });
})();
}catch(e){ console.error("[Storybook] One of your manager-entries failed: " + import.meta.url, e); }
